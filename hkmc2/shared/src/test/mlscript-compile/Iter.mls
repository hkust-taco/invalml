import "./Predef.mls"

open Predef

// * Implements the `Iterable` protocol.
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterable_protocol
class Iterable(mk) with
  set this.(Symbol.iterator) = mk

// * Implements the `Iterator` protocol.
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterator_protocol
class Iterator(val next)

module Result with
  class Next(val value) with
    val done = false
  object Done with
    val done = true

module Iter with ...

fun adaptIterable(iterable, makeNext) = Iterable of () =>
  let iterator = iterable.(Symbol.iterator)()
  Iterator of makeNext of iterator

fun mapping(xs, op) =
  xs adaptIterable of iterator => () =>
    let next = iterator.next()
    if next.done then
      Result.Done
    else
      Result.Next of op(next.value)

fun filtering(xs, op) =
  xs adaptIterable of iterator => () =>
    let next = iterator.next()
    while next.done is false and op(next.value) is false do
      set next = iterator.next()
    if next.done then
      Result.Done
    else
      Result.Next of next.value

fun taking(xs, n) =
  let i = 0
  filtering of xs, _ =>
    set i = i + 1
    i <= n

fun zippingWithIndex(xs) =
  let i = 0
  mapping of xs, x =>
    let j = i
    set i = i + 1
    [x, j]

fun foldingImpl(iterator, acc, op) =
  let next = iterator.next()
  while next.done is false do
    set acc = op(acc, next.value)
    set next = iterator.next()
  acc

fun reduced(xs, op) =
  let iterator = xs.(Symbol.iterator)()
  let next = iterator.next()
  if next.done do
    throw new Error("Empty iterator")
  foldingImpl(iterator, next.value, op)

fun folded(xs, z, op) =
  let iterator = xs.(Symbol.iterator)()
  foldingImpl(iterator, z, op)

fun rightFolded(xs, z, op) =
  let iterator = xs.(Symbol.iterator)()
  fun go() = if
    let next = iterator.next()
    next.done is true then
      z
    else
      op of next.value, go()
  go()

fun joined(xs, sep) =
  let iterator = xs.(Symbol.iterator)()
  let next = iterator.next()
  if next.done then "" else
    let sep' = String(sep)
    foldingImpl of
      iterator
      String(next.value)
      (acc, x) => acc + sep + String(x)

fun toArray(view) = Array.from(view)
