import "../Predef.mls"
import "../Option.mls"
import "../Stack.mls"
import "../BetterMap.mls"
import "../TreeTracer.mls"
import "../Iter.mls"
import "../apps/Lexer.mls"
import "./parsing/Token.mls"
import "./parsing/TokenHelpers.mls"
import "./parsing/Keyword.mls"
import "./parsing/Precedence.mls"
import "./parsing/Tree.mls"
import "./parsing/ParseRule.mls"

open Predef
open Option
open Stack
open BetterMap
open TreeTracer { TreeTracer }
open Token { LiteralKind, BracketKind }
open Precedence { Keywords, TypeKeywords, appPrec, opPrec }
open Keyword { Keyword }
open ParseRule { ParseRule, Choice, rule }

type Opt[A] = Some[A] | None

module Parser with ...

//  ____       _
// |  _ \  ___| |__  _   _  __ _
// | | | |/ _ \ '_ \| | | |/ _` |
// | |_| |  __/ |_) | |_| | (_| |
// |____/ \___|_.__/ \__,_|\__, |
//                         |___/
// ==============================

val tracer = new TreeTracer

fun letBinding(hasInClause: Bool) =
  let intro = "let binding: "
  fun makeBinding(bindingBody) = Choice.expr of
    if hasInClause then
      (head, bodyAndLetIn) => if bodyAndLetIn is
        [body, Tree.LetIn(bindings, letBody)] then
          Tree.LetIn([head, body] :: bindings, letBody)
    else
      (head, bodyAndDefine) => if bodyAndDefine is
        [body, Tree.Define(kind, defs)] then
          Tree.Define(kind, [head, body] :: defs)
    intro + "left-hand side"
    Choice.keyword of
      Keywords._equal
      intro + "right-hand side"
      bindingBody
  fun makeItems(get) = Choice.expr of
    (body, defLike) => [body, defLike]
    intro + "right-hand side"
    Choice.keyword of
      Keywords._and
      intro + "`and` keyword"
      makeBinding of Choice.Lazy(get, makeItems)
    ...if hasInClause then tuple of
      Choice.keyword of
        Keywords._in
        intro + "`in` keyword"
        Choice.expr of
          (body, _) => Tree.LetIn(Nil, body)
          intro + "body"
          Choice.end of ()
      Choice.end of Tree.LetIn(Nil, Tree.empty)
    else tuple of Choice.end of Tree.Define(Tree.DefineKind.Let(false), Nil)
  let items = Choice.lazy of makeItems
  Choice.keyword of
    Keywords._let
    intro + "keyword"
    Choice.Optional of
      rule of
        intro + "keyword"
        Choice.keyword of
          Keywords._rec
          intro + "`rec` keyword"
          Choice.end of ()
      rule of
        intro + "body"
        makeBinding of items

let letExpression = letBinding(true)
let letDefinition = letBinding(false)

fun ifThenElse() =
  let intro = "if-then-else: "
  Choice.keyword of
    Keywords._if
    intro + "`if` keyword"
    Choice.expr of
      (tst, conAndAlt) => if conAndAlt is [con, alt] then
        Tree.Ternary(Keywords._if, tst, con, alt)
      intro + "condition"
      Choice.keyword of
        Keywords._then
        intro + "`then` keyword"
        Choice.expr of
          (con, optAlt) => [con, optAlt]
          intro + "consequent"
          Choice.keyword of
            Keywords._else
            intro + "`else` keyword"
            Choice.expr of
              (alt, _) => Some(alt)
              intro + "alternative"
              Choice.end of None
          Choice.end of None

fun funChoice() =
  let intro = "function expression: "
  Choice.keyword of
    Keywords._fun
    intro + "keyword"
    Choice.expr of
      (params, body) => Tree.Lambda(params :: Nil, body)
      intro + "parameters"
      Choice.keyword of
        Keywords._thinArrow
        intro + "arrow"
        Choice.expr of
          (body, _) => body
          intro + "body"
          Choice.end of None

fun patternMatchingBody(intro, cons, nil) =
  fun makeMatchArms(get) = Choice.expr of
    (pat, rhsAndRest) => if rhsAndRest is [rhs, rest] then
      cons of Tree.Infix(Keywords._thinArrow, pat, rhs), rest
    intro + "pattern"
    Choice.keyword of
      Keywords._thinArrow
      intro + "arrow"
      Choice.expr of
        (curr, next) => [curr, next]
        intro + "body"
        Choice.end of nil
        Choice.keyword of
          Keywords._bar
          intro + "leading bar"
          Choice.Lazy(get, makeMatchArms)
  let matchArms = Choice.lazy of makeMatchArms
  tuple of
    Choice.Optional of
      rule of
        intro + "body"
        Choice.keyword of
          Keywords._bar
          intro + "leading bar"
          Choice.end of ()
      rule of
        intro + "body"
        matchArms

fun matchWithChoice() =
  let intro = "`match` expression: "
  Choice.keyword of
    Keywords._match
    intro + "keyword"
    Choice.expr of
      (scrutinee, branches) => Tree.Match(scrutinee, branches)
      intro + "scrutinee"
      Choice.keyword of
        Keywords._with
        intro + "with"
        ...patternMatchingBody(intro, (x, xs) => x :: xs, Nil)

fun matchFunctionChoice() =
  let intro = "`function` definition: "
  Choice.keyword of
    Keywords._function
    intro + "`function` keyword"
    ...patternMatchingBody of
      intro
      (x, xs) => if xs is
        Tree.Match(scrut, arms) then Tree.Match(scrut, x :: arms)
      Tree.Match(Tree.empty, Nil)

let whileTerm = Choice.keyword of
  Keywords._while
  "while condition"
  Choice.expr of
    Tree.While
    "while body"
    Choice.keyword of
      Keywords._do
      "while body"
      Choice.expr of
        (body, _) => body
        "while end"
        Choice.keyword of
          Keywords._done
          "while end"
          Choice.end of ()

fun forTerm =
  let intro = "for: "
  let innerPart = Choice.expr of
    (end, body) => [end, body]
    intro + "`do` keyword"
    Choice.keyword of
      Keywords._do
      intro + "body expression"
      Choice.expr of
        (body, _) => body
        intro + "`done` keyword"
        Choice.keyword of
          Keywords._done
          "the end"
          Choice.end of ()
  Choice.keyword of
    Keywords._for
    intro + "left-hand side"
    Choice.expr of
      (head, startEndBody) => if startEndBody is
        [start, end, body] then
          Tree.For(head, start, end, body)
      intro + "head"
      Choice.keyword of
        Keywords._equal
        intro + "start expression"
        Choice.expr of
          (start, endBody) => if endBody is [end, body] then
            [start, end, body]
          intro + "`to` or `downto` keyword"
          Choice.keyword of
            Keywords._to
            "end expression"
            innerPart
          Choice.keyword of
            Keywords._downto
            "end expression"
            innerPart

fun makeInfixChoice(keyword: Keyword, compose: (Tree, Tree) -> Tree) =
  Choice.keyword of
    keyword
    "operator `" + keyword.name + "`"
    Choice.expr of
      (rhs, _) => lhs => compose(lhs, rhs)
      "operator `" + keyword.name + "` right-hand side"
      Choice.end of ()

val exprInfixRules = rule of
  "infix rules for expressions"
  // Tuple (separated by commas)
  makeInfixChoice of Keywords._comma, (lhs, rhs) => if rhs is
    Tree.Tuple(tail) then Tree.Tuple(lhs :: tail)
    else Tree.Tuple(lhs :: rhs :: Nil)
  // Sequence (separated by semicolons)
  makeInfixChoice of Keywords._semicolon, (lhs, rhs) => if rhs is
    Tree.Sequence(tail) then Tree.Sequence(lhs :: tail)
    else Tree.Sequence(lhs :: rhs :: Nil)
  // Type ascription: <expr> ":" <typexpr>
  Choice.keyword of
    Keywords._colon
    "type ascription"
    Choice.typeExpr of
      (rhs, _) => lhs => Tree.Infix(Keywords._colon, lhs, rhs)
      "right-hand side type"
      Choice.end of ()

// Prefix rules and infix rules for expressions.
val exprRules = rule of
  "prefix rules for expressions"
  letExpression
  funChoice()
  matchWithChoice()
  matchFunctionChoice()
  ifThenElse()
  whileTerm
  forTerm
  // We put the infix rules here just for the railroad diagrams.
  Choice.Expr of
    false
    (lhs, compose) => compose(lhs)
    exprInfixRules

// TODO: merge with `makeInfixChoice` after we change `isType` to category names.
fun makeTypeInfixChoice(keyword: Keyword, compose: (Tree, Tree) -> Tree) =
  Choice.keyword of
    keyword
    "operator `" + keyword.name + "`"
    Choice.typeExpr of
      (rhs, _) => lhs => compose(lhs, rhs)
      "operator `" + keyword.name + "` right-hand side"
      Choice.end of ()

val typeInfixRules = rule of
  "infix rules for types"
  // Tuple (separated by commas)
  makeTypeInfixChoice of TypeKeywords._comma, (lhs, rhs) => if rhs is
    Tree.Tuple(tail) then Tree.Tuple(lhs :: tail)
    else Tree.Tuple(lhs :: rhs :: Nil)
  // Sequence (separated by semicolons)
  makeTypeInfixChoice of TypeKeywords._semicolon, (lhs, rhs) => if rhs is
    Tree.Sequence(tail) then Tree.Sequence(lhs :: tail)
    else Tree.Sequence(lhs :: rhs :: Nil)

// Prefix rules and infix rules for types.
val typeRules = rule of
  "rules for types"
  Choice.Expr of
    true
    (lhs, compose) => compose(lhs)
    typeInfixRules

fun typeDefinition() =
  let intro = "type definition: "
  fun typedefs(tail) =
    Choice.typeExpr of
      (head, bodyAndDefine) => if bodyAndDefine is
        [body, Tree.Define(kind, typedefs)] then
          Tree.Define(kind, [head, body] :: typedefs)
      intro + "name"
      Choice.keyword of
        Keywords._equal
        intro + "equal sign"
        Choice.typeExpr of
          (body, define) => [body, define]
          intro + "body"
          Choice.end of Tree.Define(Tree.DefineKind.Type, Nil)
          tail
  fun makeTypedefsTail(get) = Choice.keyword of
    Keywords._and
    intro + "more typedefs"
    typedefs of Choice.Lazy(get, makeTypedefsTail)
  let typedefsTail = Choice.lazy of makeTypedefsTail
  Choice.keyword of
    Keywords._type
    intro + "`type` keyword"
    typedefs of typedefsTail

fun exceptionDefinition() =
  let intro = "exception definition: "
  Choice.keyword of
    Keywords._exception
    intro + "keyword"
    Choice.typeExpr of
      (name, body) => Tree.Define(Tree.DefineKind.Exception, [name, body] :: Nil)
      intro + "name"
      Choice.keyword of
        Keywords._equal
        intro + "equal sign"
        Choice.typeExpr of
          (body, _) => body
          intro + "body"
          Choice.end of ()
      Choice.end of Tree.empty

val moduleRules = rule of
  "prefix rules for module items"
  letDefinition
  typeDefinition()
  exceptionDefinition()

fun parse(tokens) =
  let
    current = tokens
    counter = 0
  
  fun yeetSpaces =
    while current is Token.Space :: tail do
      tracer.print of "skipped a space at " + counter
      set
        current = tail
        counter = counter + 1
    current
    
  fun consume =
    if current is head :: tail then
      tracer.print of "consumed `" + Token.summary(head) + "` at " + counter
      set current = tail
      set counter = counter + 1
    else
      tracer.print of "consumed: EOF"
  
  // Useful when consuming matched brackets.
  fun require(result: Tree, expected) = if yeetSpaces is
    actual :: _ and
      expected Token.same(actual) then
        consume
        result
      else result Tree.Error of mkStr of
        "Expected token "
        expected Token.summary()
        ", but found "
        actual Token.summary() 
    Nil then result Tree.Error of mkStr of
      "Expected token "
      expected Token.summary()
      ", but found end of input"
  
  fun closeBy(acc: Tree, kind) = if yeetSpaces is
    Token.Close(kind') :: _ and
      kind == kind' then
        consume
        acc
      else Tree.error("Mismatched bracket")
    token :: _ then
      acc Tree.Error of "Expect a close bracket instead of " + token
    Nil then acc Tree.Error("Expected a close bracket, but found the end of input")
  
  fun parseRule(prec: Int, rule: ParseRule) = tracer.trace of
    "parsing rule \"" + rule.name + "\" with precedence " + prec
    result => "parsed: " + result Tree.summary()
    () => ...
    if yeetSpaces is
      Token.Close(encountered) :: _ and rule.endChoice is
        Some(result) then result
        None then
          consume
          Tree.error("unexpected close bracket `" + encountered + "`")
      Token.Identifier(name, _) :: _ and
        do tracer.print of "found an identifier \"" + name + "\"", source.line
        Keywords.all.get(name) is Some(keyword) and
          do tracer.print of keyword.toString(), source.line
          do tracer.print of "keyword choices: ", rule.keywordChoices
            Iter.mapping of case [k, v] then "`" + k + "`"
            Iter.joined(", ")
          rule.keywordChoices.get(name) is
            Some(rest) then
              tracer.print of "found a rule starting with `" + name + "`", source.line
              tracer.print of "the rest of the rule: " + rest.display, source.line
              consume
              // parseRule(keyword.rightPrecOrMax, rest)
              parseRule(0, rest)
            None and
              do tracer.print of "no rule starting with `" + name + "` was found", source.line
              do tracer.print of "the left prec of `" + name + "` is " + keyword.leftPrec, source.line
              rule.exprChoice is Some([isType, process, rest]) and
                // keyword.leftPrecOrMin > prec then
                true then
                  let acc = (if isType then typeExpr else simpleExpr) of prec
                  let tree = parseRule(prec, rest)
                  process(acc, tree)
              do tracer.print of "no exprChoice or the prec is less than " + prec, source.line
              rule.endChoice is Some(value) then
                tracer.print of "found end choice", source.line
                value
              else ???
        do tracer.print of "\"" + name + "\" is not a keyword", source.line
      other :: _ and
        do tracer.print of "try parse an expression from " + TokenHelpers.preview(current), source.line
        // simpleExpr(prec) is
        //   Tree.Error(Tree.Empty(), _) and rule.endChoice is
        //     Some(value) then value
        //   reserve and rule.exprChoice is
        //     Some([isType, process, rest]) then 
        //       let rhs = parseRule(prec, rest)
        //       tracer.print of "the reserved expression: " + reserve Tree.summary(), source.line
        //       tracer.print of "the result from sub-rule: " + rhs Tree.summary(), source.line
        //       process(reserve, rhs)
        //     None then
        //       tracer.print of "the rule doesn't have a choice starting with expressions", source.line
        //       tracer.print of rule.display, source.line
        //       Tree.error("unexpected expression")
        // ----
        rule.exprChoice is Some([isType, process, rest]) and
          let acc = (if isType then typeExpr else simpleExpr)(prec)
          acc Tree.nonEmptyError() then
            let tree = parseRule(prec, rest)
            tracer.print of "acc: " + acc Tree.summary(), source.line
            tracer.print of "tree: " + tree Tree.summary(), source.line
            process(acc, tree)
          do tracer.print of "fallback to end choice", source.line
        do tracer.print of "no expression choice", source.line
        rule.endChoice is Some(value) then
          tracer.print of "found end choice", source.line
          value
        do tracer.print of "no end choice", source.line
      Nil and rule.endChoice is
        Some(value) then value
        None then Tree.error("unexpected end of input")
  
  fun bracketed(content, kind) = if
    content is Tree.Empty and kind is
      Token.Round then Tree.Tuple(Nil)
      Token.Square then Tree.Bracketed(Token.Square, Tree.Sequence(Nil))
      Token.BeginEnd then Tree.Sequence(Nil)
    kind is
      Token.Square then Tree.Bracketed(Token.Square, content)
      else content
  
  fun simpleExpr(prec: Int) = tracer.trace of
    "simple expression <<< " + prec + " " + TokenHelpers.preview(current)
    result => "simple expression >>> " + result Tree.summary()
    () => ...
    if yeetSpaces is
      Token.Identifier(name, symbolic) :: _ and Keywords.all.get(name) is
        Some(keyword) and exprRules.keywordChoices.get(name) is
          Some(rule) and
            keyword.leftPrecOrMin > prec then
              consume
              let acc = parseRule(keyword.rightPrecOrMax, rule)
              exprCont(acc, prec)
            else
              tracer.print of "the left precedence is less" + name, source.line
              Tree.empty
          None then
            tracer.print("no rule starting with " + name, source.line)
            Tree.empty
        None then
          consume
          exprCont(Tree.Ident(name, symbolic), prec)
      Token.Literal(kind, literal) :: _ then
        consume
        exprCont(Tree.Literal(kind, literal), prec)
      Token.Open(kind) :: _ then
        consume
        simpleExpr(0, Some(kind))
          closeBy(kind)
          bracketed(kind)
          exprCont(prec)
      Token.Close(kind) :: _ then Tree.Empty()
      token :: _ then Tree.error("unrecognized token: " + token)
      Nil then Tree.error("unexpected EOF")
  
  fun exprCont(acc: Tree, prec: Int) = if yeetSpaces is
    do tracer.print(">>> exprCont " + prec + " " + acc Tree.summary() + " <<<", source.line)
    // Look up the infix rules.
    Token.Identifier(name, _) :: _ and Keywords.all.get(name) is Some(keyword) and
      do tracer.print of "found a keyword: " + name, source.line
      // Note: we can also get the infix rules from `exprRules.exprChoice` but
      // that just adds another pattern matching.
      exprInfixRules.keywordChoices.get(name) is Some(rule) and
        do tracer.print of "the keyword is found in infix rules" + name, source.line
        keyword.leftPrecOrMin > prec and rule.exprChoice is
          Some([isType, process, rest]) then
            consume
            let rhs = (if isType then typeExpr else simpleExpr) of keyword.rightPrecOrMin
            let acc' = process(rhs)(acc)
            exprCont(acc', prec)
          None then acc
      do tracer.print of "keyword `" + name + "` does not have infix rules", source.line
    Token.Identifier(name, true) :: _ and Keywords.all.get(name) is None and
      do tracer.print of "found an operator \"" + name + "\"", source.line
      opPrec(name) is [leftPrec, rightPrec] and
        do tracer.print of "its precedence is " + leftPrec, source.line
        leftPrec > prec then
          consume
          let op = Tree.Ident(name, true)
          let rhs = simpleExpr(rightPrec)
          exprCont(Tree.App(op, acc :: rhs :: Nil), prec)
        else
          acc
    Token.Close(kind) :: _ then acc
    token :: _ and
      appPrec > prec then
        do tracer.print of "found an application", source.line
        if simpleExpr(appPrec) is
          Tree.Empty then acc
          Tree.Error then acc
          rhs then exprCont(Tree.App(acc, rhs :: Nil), prec)
      else
        tracer.print of "cannot consume " + token, source.line
        acc
    Nil then acc
  
  fun typeExpr(prec: Int): Tree = tracer.trace of
    "typeExpr <<< " + prec + " " + TokenHelpers.preview(current)
    result => "typeExpr >>> " + result Tree.summary()
    () => ...
    if yeetSpaces is
      // * Type expressions that begin with a single bar are allowed.
      Token.Identifier("|", _) :: _ then
        consume
        typeExpr(prec)
      Token.TypeVariable(name) :: _ then
        consume
        // What's the corresponding tree of type variables?
        typeExprCont(Tree.Ident("'" + name), prec)
      Token.Identifier("_", _) :: _ then
        consume
        typeExprCont(Tree.Underscore(), prec)
      Token.Identifier(name, false) :: _ then
        consume
        typeExprCont(Tree.Ident(name), prec)
      // Handle opening brackets (mostly round and curly)
      Token.Open(kind) :: _ then
        tracer.print of "found an open ", kind, " bracket", source.line
        consume
        typeExpr(0, Some(kind))
          (if kind is Token.Curly then Tree.Bracketed(Token.Curly, _) else id)()
          closeBy(kind)
          typeExprCont of prec
      // Handle closing brackets.
      Token.Close(kind) :: _ then Tree.Empty()
      else Tree.empty
  
  fun typeExprCont(acc: Tree, prec: Int) =
    tracer.print of ">>> typeExprCont " + prec + " " + acc Tree.summary() + " <<<", source.line
    if yeetSpaces is
      Token.Close :: _ then acc
      do tracer.print of "check keyword " + TokenHelpers.preview(current), source.line
      Token.Identifier(name, _) :: _ and TypeKeywords.all.get(name) is Some(keyword) and
        typeInfixRules.keywordChoices.get(name) is Some(rule) and
          do tracer.print of "the keyword is found in infix rules" + name, source.line
          keyword.leftPrecOrMin > prec and rule.exprChoice is
            Some([isType, process, rest]) then
              consume
              let rhs = (if isType then typeExpr else simpleExpr) of keyword.rightPrecOrMin
              let acc' = process(rhs)(acc)
              typeExprCont(acc', prec)
            None then acc
          do tracer.print of "keyword `" + name + "` does not have infix rules", source.line
      Token.Identifier(name, _) :: _ and TypeKeywords.all.get(name) is
        Some(keyword) and
          do tracer.print of "found a keyword " + name, source.line
          keyword.leftPrecOrMin > prec then
            consume
            let rhs = typeExpr(keyword.rightPrecOrMax)
            typeExprCont(Tree.Infix(keyword, acc, rhs), prec)
          else
            acc
      // * the case of type application
      do tracer.print of "not a keyword", source.line
      Token.Identifier(name, false) :: _ and
        TypeKeywords.appPrec > prec then
          do tracer.print of "found an application", source.line
          if typeExpr(TypeKeywords.appPrec) is
            Tree.Empty then acc
            Tree.Error then acc
            rhs then typeExprCont(Tree.App(rhs, acc :: Nil), prec)
      token :: _ then
        tracer.print of "cannot consume " + token, source.line
        acc
      Nil then acc
  
  fun mod(acc: Stack[Tree]) = if yeetSpaces is
    do tracer.print of ">>>>>> mod <<<<<<", source.line
    Token.Identifier(";;", _) :: _ then
      consume
      mod
    Token.Identifier(name, _) :: _ and
      Keywords.all.get(name) is Some(keyword) and
        exprRules.keywordChoices.get(name) is Some(rule) then
          consume
          let tree = parseRule(0, rule, None)
          if tree is Tree.LetIn(bindings, Tree.Empty) then
            // If the body is empty, then this is a let-definition.
            modCont of Tree.Define(Tree.DefineKind.Let(false), bindings) :: acc
          else
            modCont of tree :: acc
        moduleRules.keywordChoices.get(name) is Some(rule) then
          consume
          let tree = parseRule(0, rule, None)
          modCont(tree :: acc)
    _ :: _ then modCont of simpleExpr(0, None) :: acc
    Nil then acc reverse()
  
  fun modCont(acc: Stack[Tree]) = if yeetSpaces is
    do tracer.print of ">>>>>> modCont <<<<<<", source.line
    Token.Identifier(";;", _) :: _ then
      consume
      acc mod()
    _ :: _ then modCont of parseRule(0, moduleRules, None) :: acc
    Nil then acc reverse()
  
  let tree = tracer.trace of
    "module <<< "
    result => "module >>> " + result Tree.summary()
    () => mod(Nil)
  
  if yeetSpaces is
    token :: _ then
      let message = "expect EOF instead of " + token
      tracer.print of message, source.line
      tree Tree.Error(message)
    Nil then tree
