import "../Predef.mls"
import "../Option.mls"
import "../Stack.mls"
import "../BetterMap.mls"
import "../TreeTracer.mls"
import "../Iter.mls"
import "../apps/Lexer.mls"
import "./parsing/Token.mls"
import "./parsing/TokenHelpers.mls"
import "./parsing/Keyword.mls"
import "./parsing/Precedence.mls"
import "./parsing/Tree.mls"
import "./parsing/ParseRule.mls"

open Predef
open Option
open Stack
open BetterMap
open TreeTracer { TreeTracer }
open Token { LiteralKind, BracketKind }
open Precedence { Keywords, TypeKeywords, appPrec, opPrec }
open Keyword { Keyword }
open ParseRule { ParseRule, Choice, rule }

type Opt[A] = Some[A] | None

module Parser with ...

//  _     _     _
// | |   (_)___| |_
// | |   | / __| __|
// | |___| \__ \ |_
// |_____|_|___/\__|
// 
// =================

fun at(target, index) = target.at(index)

fun toStack(array) =
  let
    length = array.length
    i = length - 1
    reserve = Nil
  while i >= 0 do
    set reserve = array.at(i) :: reserve
    set i = i - 1
  reserve

fun stack(...args) = args toStack()

fun mapJoin[A](stack: Stack[A], op: A -> Str, sep: Str) =
  let buffer = ""
  while stack is head :: tail do
    set buffer = buffer + op(head)
    if tail is _ :: _ do
      set buffer = buffer + sep
    set stack = tail
  buffer

fun collectFirst[A, B](stack: Stack[A], op) =
  let lastResult = None
  while stack is head :: tail and
    do set lastResult = op(head)
    lastResult is None do
      set stack = tail
  lastResult

fun collectToArray[A, B](stack: Stack[A], p) =
  let elements = []
  while stack is head :: tail do
    if p(head) is Some(value) do
      elements.push of value
    set stack = tail
  elements

fun map(xs, op) = if xs is
  Nil then Nil
  head :: tail then ...
  let
    result = op(head) :: Nil
    current = result
    rest = tail
  while rest is head :: tail do
    let next = op(head) :: Nil
    set
      current.tail = next
      current = next
      rest = tail
  result

//  ____       _
// |  _ \  ___| |__  _   _  __ _
// | | | |/ _ \ '_ \| | | |/ _` |
// | |_| |  __/ |_) | |_| | (_| |
// |____/ \___|_.__/ \__,_|\__, |
//                         |___/
// ==============================

val tracer = new TreeTracer

fun letBinding(hasInClause: Bool) =
  let intro = "let binding: "
  fun makeBinding(bindingBody) = Choice.expr of
    if hasInClause then
      (head, bodyAndLetIn) => if bodyAndLetIn is
        [body, Tree.LetIn(bindings, letBody)] then
          Tree.LetIn([head, body] :: bindings, letBody)
    else
      (head, bodyAndDefine) => if bodyAndDefine is
        [body, Tree.Define(kind, defs)] then
          Tree.Define(kind, [head, body] :: defs)
    intro + "left-hand side"
    Choice.keyword of
      Keywords._equal
      intro + "right-hand side"
      bindingBody
  fun makeItems(get) = Choice.expr of
    (body, defLike) => [body, defLike]
    intro + "right-hand side"
    Choice.keyword of
      Keywords._and
      intro + "`and` keyword"
      makeBinding of Choice.Lazy(get, makeItems)
    ...if hasInClause then tuple of
      Choice.keyword of
        Keywords._in
        intro + "`in` keyword"
        Choice.expr of
          (body, _) => Tree.LetIn(Nil, body)
          intro + "body"
          Choice.end of ()
      Choice.end of Tree.LetIn(Nil, Tree.empty)
    else tuple of Choice.end of Tree.Define(Tree.DefineKind.Let(false), Nil)
  let items = Choice.lazy of makeItems
  Choice.keyword of
    Keywords._let
    intro + "keyword"
    Choice.Optional of
      rule of
        intro + "keyword"
        Choice.keyword of
          Keywords._rec
          intro + "`rec` keyword"
          Choice.end of ()
      rule of
        intro + "body"
        makeBinding of items

let letExpression = letBinding(true)
let letDefinition = letBinding(false)

fun ifThenElse() =
  let intro = "if-then-else: "
  Choice.keyword of
    Keywords._if
    intro + "`if` keyword"
    Choice.expr of
      (tst, conAndAlt) => if conAndAlt is [con, alt] then
        Tree.Ternary(Keywords._if, tst, con, alt)
      intro + "condition"
      Choice.keyword of
        Keywords._then
        intro + "`then` keyword"
        Choice.expr of
          (con, optAlt) => [con, optAlt]
          intro + "consequent"
          Choice.keyword of
            Keywords._else
            intro + "`else` keyword"
            Choice.expr of
              (alt, _) => Some(alt)
              intro + "alternative"
              Choice.end of None
          Choice.end of None

fun funChoice() =
  let intro = "function expression: "
  Choice.keyword of
    Keywords._fun
    intro + "keyword"
    Choice.expr of
      (params, body) => Tree.Lambda(params :: Nil, body)
      intro + "parameters"
      Choice.keyword of
        Keywords._thinArrow
        intro + "arrow"
        Choice.expr of
          (body, _) => body
          intro + "body"
          Choice.end of None

fun patternMatchingBody(intro, cons, nil) =
  fun makeMatchArms(get) = Choice.expr of
    (pat, rhsAndRest) => if rhsAndRest is [rhs, rest] then
      cons of Tree.Infix(Keywords._thinArrow, pat, rhs), rest
    intro + "pattern"
    Choice.keyword of
      Keywords._thinArrow
      intro + "arrow"
      Choice.expr of
        (curr, next) => [curr, next]
        intro + "body"
        Choice.end of nil
        Choice.keyword of
          Keywords._bar
          intro + "leading bar"
          Choice.Lazy(get, makeMatchArms)
  let matchArms = Choice.lazy of makeMatchArms
  tuple of
    Choice.Optional of
      rule of
        intro + "body"
        Choice.keyword of
          Keywords._bar
          intro + "leading bar"
          Choice.end of ()
      rule of
        intro + "body"
        matchArms

fun matchWithChoice() =
  let intro = "`match` expression: "
  Choice.keyword of
    Keywords._match
    intro + "keyword"
    Choice.expr of
      (scrutinee, branches) => Tree.Match(scrutinee, branches)
      intro + "scrutinee"
      Choice.keyword of
        Keywords._with
        intro + "with"
        ...patternMatchingBody(intro, (x, xs) => x :: xs, Nil)

fun matchFunctionChoice() =
  let intro = "`function` definition: "
  Choice.keyword of
    Keywords._function
    intro + "`function` keyword"
    ...patternMatchingBody of
      intro
      (x, xs) => if xs is
        Tree.Match(scrut, arms) then Tree.Match(scrut, x :: arms)
      Tree.Match(Tree.empty, Nil)

val exprRules = rule of
  "prefix rules for expressions"
  letExpression
  funChoice()
  matchWithChoice()
  matchFunctionChoice()
  ifThenElse()

fun typeDefinition() =
  let intro = "type definition: "
  fun typedefs(tail) =
    Choice.typeExpr of
      (head, bodyAndDefine) => if bodyAndDefine is
        [body, Tree.Define(kind, typedefs)] then
          Tree.Define(kind, [head, body] :: typedefs)
      intro + "name"
      Choice.keyword of
        Keywords._equal
        intro + "equal sign"
        Choice.typeExpr of
          (body, define) => [body, define]
          intro + "body"
          Choice.end of Tree.Define(Tree.DefineKind.Type, Nil)
          tail
  fun makeTypedefsTail(get) = Choice.keyword of
    Keywords._and
    intro + "more typedefs"
    typedefs of Choice.Lazy(get, makeTypedefsTail)
  let typedefsTail = Choice.lazy of makeTypedefsTail
  Choice.keyword of
    Keywords._type
    intro + "`type` keyword"
    typedefs of typedefsTail

fun exceptionDefinition() =
  let intro = "exception definition: "
  Choice.keyword of
    Keywords._exception
    intro + "keyword"
    Choice.typeExpr of
      (name, body) => Tree.Define(Tree.DefineKind.Exception, [name, body] :: Nil)
      intro + "name"
      Choice.keyword of
        Keywords._equal
        intro + "equal sign"
        Choice.typeExpr of
          (body, _) => body
          intro + "body"
          Choice.end of ()
      Choice.end of Tree.empty

val moduleRules = rule of
  "prefix rules for module items"
  letDefinition
  typeDefinition()
  exceptionDefinition()

fun makeInfixChoice(keyword) =
  Choice.keyword of
    keyword
    "operator `" + keyword.name + "`"
    Choice.expr of
      (rhs, _) => lhs => Tree.Infix(keyword, lhs, rhs)
      "operator `" + keyword.name + "` right-hand side"
      Choice.end of ()

val infixRules = rule of
  "the continuation of expressions"
  makeInfixChoice(Keywords._bar)

fun parse(tokens) =
  let
    current = tokens
    counter = 0
  
  fun yeetSpaces =
    while current is Token.Space :: tail do
      tracer.print of "skipped a space at " + counter
      set
        current = tail
        counter = counter + 1
    current
    
  fun consume =
    if current is head :: tail then
      tracer.print of "consumed `" + Token.summary(head) + "` at " + counter
      set current = tail
      set counter = counter + 1
    else
      tracer.print of "consumed: EOF"
  
  // Useful when consuming matched brackets.
  fun require(result: Tree, expected) = if yeetSpaces is
    actual :: _ and
      expected Token.same(actual) then
        consume
        result
      else result Tree.Error of mkStr of
        "Expected token "
        expected Token.summary()
        ", but found "
        actual Token.summary() 
    Nil then result Tree.Error of mkStr of
      "Expected token "
      expected Token.summary()
      ", but found end of input"
  
  fun parseRule(prec: Int, rule: ParseRule, opened) = tracer.trace of
    "parsing rule \"" + rule.name + "\" with precedence " + prec
    result => "parsed: " + result Tree.summary()
    () => ...
    if yeetSpaces is
      Token.Close(encountered) :: _ and opened is
        do tracer.print of "the case of closing brackets", source.line
        Some(expected) and
          encountered == expected and rule.endChoice is
            Some(value) then value
            None then
              // The rule doesn't allow an end here.
              consume
              Tree.error("unexpected close bracket `" + encountered + "`")
          else
            consume
            // The rule expects a different close bracket.
            Tree.error("mismatched brackets")
        None then
          consume
          Tree.error("unexpected bracket: " + encountered)
      Token.Identifier(name, _) :: _ and
        do tracer.print of "found an identifier \"" + name + "\"", source.line
        Keywords.all.get(name) is Some(keyword) and
          do tracer.print of keyword.toString(), source.line
          do tracer.print of "keyword choices: ", rule.keywordChoices
            Iter.mapping of case [k, v] then "`" + k + "`"
            Iter.joined(", ")
          rule.keywordChoices.get(name) is
            Some(rest) then
              tracer.print of "found a rule starting with `" + name + "`", source.line
              tracer.print of "the rest of the rule: " + rest.display, source.line
              consume
              // parseRule(keyword.rightPrecOrMax, rest, opened)
              parseRule(0, rest, opened)
            None and
              do tracer.print of "no rule starting with `" + name + "` was found", source.line
              do tracer.print of "the left prec of `" + name + "` is " + keyword.leftPrec, source.line
              rule.exprChoice is Some([isType, process, rest]) and
                // keyword.leftPrecOrMin > prec then
                true then
                  let acc = (if isType then typeExpr else simpleExpr) of prec, opened
                  let tree = parseRule(prec, rest, opened)
                  process(acc, tree)
              do tracer.print of "no exprChoice or the prec is less than " + prec, source.line
              rule.endChoice is Some(value) then
                tracer.print of "found end choice", source.line
                value
              else ???
        do tracer.print of "\"" + name + "\" is not a keyword", source.line
      other :: _ and
        do tracer.print of "try parse an expression from " + TokenHelpers.preview(current), source.line
        // simpleExpr(prec, opened) is
        //   Tree.Error(Tree.Empty(), _) and rule.endChoice is
        //     Some(value) then value
        //   reserve and rule.exprChoice is
        //     Some([isType, process, rest]) then 
        //       let rhs = parseRule(prec, rest, opened)
        //       tracer.print of "the reserved expression: " + reserve Tree.summary(), source.line
        //       tracer.print of "the result from sub-rule: " + rhs Tree.summary(), source.line
        //       process(reserve, rhs)
        //     None then
        //       tracer.print of "the rule doesn't have a choice starting with expressions", source.line
        //       tracer.print of rule.display, source.line
        //       Tree.error("unexpected expression")
        // ----
        rule.exprChoice is Some([isType, process, rest]) and
          let acc = (if isType then typeExpr else simpleExpr)(prec, opened)
          acc Tree.nonEmptyError() then
            let tree = parseRule(prec, rest, opened)
            tracer.print of "acc: " + acc Tree.summary(), source.line
            tracer.print of "tree: " + tree Tree.summary(), source.line
            process(acc, tree)
          do tracer.print of "fallback to end choice", source.line
        do tracer.print of "no expression choice", source.line
        rule.endChoice is Some(value) then
          tracer.print of "found end choice", source.line
          value
        do tracer.print of "no end choice", source.line
      Nil and rule.endChoice is
        Some(value) then value
        None then Tree.error("unexpected end of input")
  
  fun simpleExpr(prec: Int, bracket) = tracer.trace of
    "simple expression <<< " + prec + " " + TokenHelpers.preview(current)
    result => "simple expression >>> " + result Tree.summary()
    () => ...
    if yeetSpaces is
      Token.Identifier(name, symbolic) :: _ and Keywords.all.get(name) is
        Some(keyword) and exprRules.keywordChoices.get(name) is
          Some(rule) and
            keyword.leftPrecOrMin > prec then
              consume
              let acc = parseRule(keyword.rightPrecOrMax, rule, bracket)
              exprCont(acc, prec, bracket)
            else
              tracer.print of "the left precedence is less" + name, source.line
              Tree.empty
          None then
            tracer.print("no rule starting with " + name, source.line)
            Tree.empty
        None then
          consume
          exprCont(Tree.Ident(name, symbolic), prec, bracket)
      Token.Literal(kind, literal) :: _ then
        consume
        exprCont(Tree.Literal(kind, literal), prec, bracket)
      Token.Open(kind) :: _ then
        consume
        let content = if
          let content = simpleExpr(0, Some(kind))
          yeetSpaces is
            Token.Close(kind') :: _ and
              kind == kind' then
                tracer.print of "closing bracket " + kind, source.line
                consume
                if
                  content is Tree.Empty and kind is
                    Token.Round then Tree.Tuple(Nil)
                    Token.Square then Tree.Bracketed(Token.Square, Tree.Sequence(Nil))
                    Token.BeginEnd then Tree.Sequence(Nil)
                  kind is
                    Token.Square then Tree.Bracketed(Token.Square, content)
                    else content
              else content Tree.Error("mismatched brackets")
            token :: _ then
              let message = "expect a close bracket instead of " + token
              tracer.print of message, source.line
              content Tree.Error(message)
            Nil then
              let message = "expect a close bracket instead of EOF"
              tracer.print of message, source.line
              content Tree.Error(message)
        exprCont(content, prec, bracket)
      Token.Close(kind) :: _ and bracket is
        Some(kind') and
          kind == kind' then Tree.Empty()
          else Tree.error("mismatched brackets")
        None then
          tracer.print("missing close bracket", source.line)
          Tree.error("missing close bracket")
      token :: _ then Tree.error("unrecognized token: " + token)
      Nil then Tree.error("unexpected EOF")
  
  fun exprCont(acc: Tree, prec: Int, bracket) = if yeetSpaces is
    do tracer.print(">>> exprCont " + prec + " " + acc Tree.summary() + " <<<", source.line)
    Token.Identifier(name, _) :: _ and Keywords.all.get(name) is Some(keyword) and
      do tracer.print of "found a keyword: " + name, source.line
      infixRules.keywordChoices.get(name) is Some(rule) and
        do tracer.print of "found an infix keyword " + name, source.line
        keyword.leftPrecOrMin > prec and rule.exprChoice is
          Some([isType, process, rest]) then
            consume
            let rhs = simpleExpr(keyword.rightPrecOrMin, bracket)
            let acc' = Tree.Infix(keyword, acc, rhs)
            exprCont(acc', prec, bracket)
          None then acc
      do tracer.print of "keyword `" + name + "` does not have infix rules", source.line
    Token.Identifier(name, true) :: _ and Keywords.all.get(name) is None and
      do tracer.print of "found an operator \"" + name + "\"", source.line
      opPrec(name) is [leftPrec, rightPrec] and
        do tracer.print of "its precedence is " + leftPrec, source.line
        leftPrec > prec then
          consume
          let op = Tree.Ident(name, true)
          let rhs = simpleExpr(rightPrec, bracket)
          exprCont(Tree.App(op, acc :: rhs :: Nil), prec, bracket)
        else
          acc
    Token.Close(kind) :: _ and bracket is
      do tracer.print of "found a close bracket of " + kind, source.line
      Some(kind') and
        kind == kind' then acc
        else acc Tree.Error("mismatched brackets")
      None then acc Tree.Error("missing close bracket")
    // TODO: BEGIN deduplication
    Token.Semicolon :: _ and
      do tracer.print of "found a semicolon", source.line
      Keywords._semicolon.leftPrec Option.unsafe.get() > prec then
        consume
        simpleExpr(Keywords._semicolon.rightPrec Option.unsafe.get(), bracket)
          Tree.sequenceWithHead of acc
          exprCont of prec, bracket
      else
        tracer.print of "cannot consume the semicolon", source.line
        acc
    Token.Comma :: _ and
      do tracer.print of "found a comma", source.line
      Keywords._comma.leftPrec Option.unsafe.get() > prec then
        consume
        simpleExpr(Keywords._comma.rightPrec Option.unsafe.get(), bracket)
          Tree.tupleWithHead of acc
          exprCont of prec, bracket
      else
        tracer.print of "cannot consume the comma", source.line
        acc
    // TODO: END deduplication
    token :: _ and
      appPrec > prec then
        do tracer.print of "found an application", source.line
        if simpleExpr(appPrec, bracket) is
          Tree.Empty then acc
          Tree.Error then acc
          rhs then exprCont(Tree.App(acc, rhs :: Nil), prec, bracket)
      else
        tracer.print of "cannot consume " + token, source.line
        acc
    Nil and bracket is
      do tracer.print of "found an EOF", source.line
      Some then acc Tree.Error("expect a close bracket instead of EOF")
      None then acc
  
  fun typeExpr(prec: Int, bracket: Opt[BracketKind]): Tree = tracer.trace of
    "typeExpr <<< " + prec + " " + bracket + " " + TokenHelpers.preview(current)
    result => "typeExpr >>> " + result Tree.summary()
    () => ...
    if yeetSpaces is
      // * Type expressions that begin with a single bar are allowed.
      Token.Identifier("|", _) :: _ then
        consume
        typeExpr(prec, bracket)
      // * Only allow polymorphic variant tags in the beginning.
      Token.TagName(name) :: _ then
        consume
        typeExprCont(Tree.Ident("`" + name), prec, bracket)
      Token.TypeVariable(name) :: _ then
        consume
        // What's the corresponding tree of type variables?
        typeExprCont(Tree.Ident("'" + name), prec, bracket)
      Token.Identifier("_", _) :: _ then
        consume
        typeExprCont(Tree.Underscore(), prec, bracket)
      Token.Identifier("..", _) :: _ then
        consume
        typeExprCont(Tree.Ident(".."), prec, bracket)
      Token.Identifier(name, false) :: _ then
        consume
        typeExprCont(Tree.Ident(name), prec, bracket)
      // '[' is special because of the open/close variant markers.
      Token.Open(Token.Square) :: _ then
        consume
        // OCaml disallows spaces between '[' and '<'/'>'.
        let openness = if current is
          (Token.Identifier(">", _) as marker) :: _ then
            consume
            Some(marker)
          (Token.Identifier("<", _) as marker) :: _ then
            consume
            // An optional `|` is allowed only after "<".
            if yeetSpaces is Token.Identifier("|", _) :: _ do consume
            Some(marker)
          else None
        typeExpr(0, Some(Token.Square))
          require of Token.Close(Token.Square)
          typeExprCont of prec, bracket
      // Handle opening brackets (mostly round and curly)
      Token.Open(kind) :: _ then
        tracer.print of "found an open ", kind, " bracket", source.line
        consume
        typeExpr(0, Some(kind))
          (if kind is Token.Curly then Tree.Bracketed(Token.Curly, _) else id)()
          require of Token.Close(kind)
          typeExprCont of prec, bracket
      // Handle closing brackets.
      Token.Close(kind) :: _ and bracket is
        Some(kind') then Tree.Empty()
        Some(kind) then Tree.error("mismatched brackets")
        None then Tree.error("unexpected close bracket")
      // `<` and `>` in type expressions are not infix operators
      Token.Identifier("<", _) :: _ then
        consume
        typeExpr(0, Some(Token.Angle))
          Tree.asSequence()
          Tree.bracketed of Token.Angle
          require of Token.Identifier(">", true)
          typeExprCont of prec, bracket
      // Closing ">" is handled in the same way as closing other brackets.
      Token.Identifier(">", _) :: _ and bracket is
        Some(Token.Angle) then Tree.Empty()
        Some(kind) then Tree.error("mismatched brackets")
        None then Tree.error("unexpected close bracket")
      else Tree.empty
  
  fun typeExprCont(acc: Tree, prec: Int, bracket: Opt[BracketKind]) =
    tracer.print of ">>> typeExprCont " + prec + " " + acc Tree.summary() + " <<<", source.line
    if yeetSpaces is
      Token.Close(kind) :: _ and bracket is
        Some(kind') and
          kind == kind' then acc
          else Tree.error("mismatched brackets")
        None then Tree.error("unexpected close bracket")
      Token.Identifier(">", _) :: _ and bracket is
        Some(Token.Angle) then acc
        Some(kind) then Tree.error("mismatched brackets")
        None then Tree.error("unexpected close bracket")
      // TODO: BEGIN deduplication
      Token.Semicolon :: _ and
        do tracer.print of "found a semicolon", source.line
        TypeKeywords._semicolon.leftPrec Option.unsafe.get() > prec then
          consume
          typeExpr(TypeKeywords._semicolon.rightPrec Option.unsafe.get(), bracket)
            Tree.sequenceWithHead of acc
            tap of x => tracer.print of "bruh: " + x
            typeExprCont of prec, bracket
        else
          tracer.print of "cannot consume the semicolon", source.line
          acc
      Token.Comma :: _ and
        do tracer.print of "found a comma", source.line
        TypeKeywords._comma.leftPrec Option.unsafe.get() > prec then
          consume
          typeExpr(TypeKeywords._comma.rightPrec Option.unsafe.get(), bracket)
            Tree.tupleWithHead of acc
            typeExprCont of prec, bracket
        else
          tracer.print of "cannot consume the comma", source.line
          acc
      // TODO: END deduplication
      do tracer.print of "check keyword " + TokenHelpers.preview(current), source.line
      Token.Identifier(name, _) :: _ and TypeKeywords.all.get(name) is
        Some(keyword) and
          do tracer.print of "found a keyword " + name, source.line
          keyword.leftPrecOrMin > prec then
            consume
            let rhs = typeExpr(keyword.rightPrecOrMax, bracket)
            typeExprCont(Tree.Infix(keyword, acc, rhs), prec, bracket)
          else
            acc
      // * the case of type application
      do tracer.print of "not a keyword", source.line
      Token.Identifier(name, false) :: _ and
        TypeKeywords.appPrec > prec then
          do tracer.print of "found an application", source.line
          if typeExpr(TypeKeywords.appPrec, bracket) is
            Tree.Empty then acc
            Tree.Error then acc
            rhs then typeExprCont(Tree.App(rhs, acc :: Nil), prec, bracket)
      token :: _ then
        tracer.print of "cannot consume " + token, source.line
        acc
      Nil then acc
  
  fun mod(acc: Stack[Tree]) = if yeetSpaces is
    do tracer.print of ">>>>>> mod <<<<<<", source.line
    Token.Identifier(";;", _) :: _ then
      consume
      mod
    Token.Identifier(name, _) :: _ and
      Keywords.all.get(name) is Some(keyword) and
        exprRules.keywordChoices.get(name) is Some(rule) then
          consume
          let tree = parseRule(0, rule, None)
          if tree is Tree.LetIn(bindings, Tree.Empty) then
            // If the body is empty, then this is a let-definition.
            modCont of Tree.Define(Tree.DefineKind.Let(false), bindings) :: acc
          else
            modCont of tree :: acc
        moduleRules.keywordChoices.get(name) is Some(rule) then
          consume
          let tree = parseRule(0, rule, None)
          modCont(tree :: acc)
    _ :: _ then modCont of simpleExpr(0, None) :: acc
    Nil then acc reverse()
  
  fun modCont(acc: Stack[Tree]) = if yeetSpaces is
    do tracer.print of ">>>>>> modCont <<<<<<", source.line
    Token.Identifier(";;", _) :: _ then
      consume
      acc mod()
    _ :: _ then modCont of parseRule(0, moduleRules, None) :: acc
    Nil then acc reverse()
  
  let tree = tracer.trace of
    "module <<< "
    result => "module >>> " + result Tree.summary()
    () => mod(Nil)
  
  if yeetSpaces is
    token :: _ then
      let message = "expect EOF instead of " + token
      tracer.print of message, source.line
      tree Tree.Error(message)
    Nil then tree
