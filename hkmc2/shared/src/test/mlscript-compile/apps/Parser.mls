import "../Predef.mls"
import "../Option.mls"
import "../Stack.mls"
import "../BetterMap.mls"
import "../TreeTracer.mls"
import "../Iter.mls"
import "../apps/Lexer.mls"
import "./parsing/Token.mls"
import "./parsing/TokenHelpers.mls"
import "./parsing/Keyword.mls"
import "./parsing/Precedence.mls"
import "./parsing/Tree.mls"
import "./parsing/ParseRule.mls"

open Predef
open Option
open Stack
open BetterMap
open TreeTracer { TreeTracer }
open Token { LiteralKind, BracketKind }
open Precedence { Keywords, appPrec, opPrec }
open Keyword { allKeywords, Keyword }
open ParseRule { ParseRule, Choice, rule }

type Option[A] = Some[A] | None

module Parser with ...

//  _     _     _
// | |   (_)___| |_
// | |   | / __| __|
// | |___| \__ \ |_
// |_____|_|___/\__|
// 
// =================

fun at(target, index) = target.at(index)

fun first(array) = if array is [first, ...] then first

fun second(array) = if array is [_, second, ...] then second

fun toStack(array) =
  let
    length = array.length
    i = length - 1
    reserve = Nil
  while i >= 0 do
    set reserve = array.at(i) :: reserve
    set i = i - 1
  reserve

fun stack(...args) = args toStack()

fun mapJoin[A](stack: Stack[A], op: A -> Str, sep: Str) =
  let buffer = ""
  while stack is head :: tail do
    set buffer = buffer + op(head)
    if tail is _ :: _ do
      set buffer = buffer + sep
    set stack = tail
  buffer

fun collectFirst[A, B](stack: Stack[A], op) =
  let lastResult = None
  while stack is head :: tail and
    do set lastResult = op(head)
    lastResult is None do
      set stack = tail
  lastResult

fun collectToArray[A, B](stack: Stack[A], p) =
  let elements = []
  while stack is head :: tail do
    if p(head) is Some(value) do
      elements.push of value
    set stack = tail
  elements

fun map(xs, op) = if xs is
  Nil then Nil
  head :: tail then ...
  let
    result = op(head) :: Nil
    current = result
    rest = tail
  while rest is head :: tail do
    let next = op(head) :: Nil
    set
      current.tail = next
      current = next
      rest = tail
  result

//  ____       _
// |  _ \  ___| |__  _   _  __ _
// | | | |/ _ \ '_ \| | | |/ _` |
// | |_| |  __/ |_) | |_| | (_| |
// |____/ \___|_.__/ \__,_|\__, |
//                         |___/
// ==============================

val tracer = new TreeTracer

fun indented(text) = text.split("\n").join("\n  ")

fun showAsTree(thing) =
  fun itemize(something) = if something is
    Some(content) then tuple of ["Some of " + go(content)], []
    None then tuple of "None", []
    head :: tail then
      let
        items = [go(head)]
        remaining = tail
      while remaining is
        head' :: tail' do
          items.push(go of head')
          set remaining = tail'
      tuple of ("Stack of \n" + "  " + indented of items.join("\n")), []
    Nil then ["Nil", []]
    Str then [JSON.stringify(something), []] // TODO: This doesn't work.
    Int then [something.toString(), []]
    Tree.Empty then ["Empty", []]
    Tree.Error(Tree.Empty, m) then tuple of "Error", [["message", go(m)]]
    Tree.Error(t, m) then tuple of "Error", [["tree", go(t)], ["message", go(m)]]
    Tree.Ident(n, _) then tuple of "Ident", [["name", go(n)]]
    Tree.Underscore() then tuple of "Underscore", []
    Tree.Modified(m, s) then
      tuple of "Modified", [["modifier", go(m)], ["subject", go(s)]]
    Tree.Tuple(t) then tuple of "Tuple", [["items", go(t)]]
    Tree.Sequence(t) then tuple of "Sequence", [["items", go(t)]]
    Tree.Literal(k, v) then tuple of ("Literal#" + go(k) + " of " + go(v)), []
    Tree.Match(scrutinee, branches) then tuple of
      "Match", [["scrutinee", scrutinee], ["branches", go(branches)]]
    Tree.App(c, a) then tuple of "App", [["callee", go(c)], ["arguments", go(a)]]
    Tree.Infix(op, lhs, rhs) then tuple of
      "Infix", [["op", go(op)], ["lhs", go(lhs)], ["rhs", go(rhs)]]
    Tree.Ternary(n, l, r, b) then tuple of
      "Ternary", [["name", go(n)], ["lhs", go(l)], ["rhs", go(r)], ["body", go(b)]]
    Tree.Lambda(p, b) then tuple of "Lambda", [["params", go(p)], ["body", go(b)]]
    Keyword as keyword then [keyword.toString(), []]
    LiteralKind.Integer then tuple of "Integer", []
    LiteralKind.Decimal then tuple of "Decimal", []
    LiteralKind.String then tuple of "String", []
    LiteralKind.Boolean then tuple of "Boolean", []
    else tuple of "Unknown", [["JSON.stringify(_)", JSON.stringify(something)]]
  fun go(something) = if itemize(something) is
    [intro, []] then intro
    [intro, [field]] and intro != "Unknown" then intro + " of " + second of field
    [intro, fields] then
      let dialogue = fields.map of (field, _, _) =>
        field first() + " = " + field second()
      intro + ":\n  " + indented of dialogue.join("\n")
  go(thing)

fun letBinding(keyword: Keyword) =
  let intro = keyword.name + " binding: "
  fun makeBinding(body) = Choice.expr of
    (lhs, rhsAndBody) => if rhsAndBody is [rhs, body] then
      Tree.Ternary(Keywords._let, lhs, rhs, body)
    intro + "left-hand side"
    Choice.keyword of
      Keywords._equal
      intro + "equal sign"
      body
  fun makeItems(get) = Choice.expr of
    (rhs, body) => [rhs, body]
    intro + "right-hand side"
    Choice.keyword of
      Keywords._and
      intro + "`and` keyword"
      makeBinding of Choice.Lazy(get, makeItems)
    Choice.keyword of
      Keywords._in
      intro + "`in` keyword"
      Choice.expr of
        (body, _) => body
        intro + "body"
        Choice.end of ()
    Choice.end of Tree.empty
  let items = Choice.lazy of makeItems
  Choice.keyword of
    keyword
    intro + "keyword"
    makeBinding of items

fun recursiveModifier = Choice.keyword of
  Keywords._rec
  "rec keyword"
  Choice.expr of
    (body, _) => Tree.Modified(Keywords._rec, body)
    "body"
    Choice.end of ()

fun typeDefinition() =
  let intro = "type definition: "
  Choice.keyword of
    Keywords._type
    intro + "`type` keyword"
    Choice.expr of
      (name, body) => Tree.Ternary(Keywords._type, name, body, None)
      intro + "name"
      Choice.keyword of
        Keywords._equal
        intro + "equal sign"
        Choice.expr of
          (body, _) => body
          intro + "body"
          Choice.end of ()

fun ifThenElse() =
  let intro = "if-then-else: "
  Choice.keyword of
    Keywords._if
    intro + "`if` keyword"
    Choice.expr of
      (tst, conAndAlt) => if conAndAlt is [con, alt] then
        Tree.Ternary(Keywords._if, tst, con, alt)
      intro + "condition"
      Choice.keyword of
        Keywords._then
        intro + "`then` keyword"
        Choice.expr of
          (con, optAlt) => [con, optAlt]
          intro + "consequent"
          Choice.keyword of
            Keywords._else
            intro + "`else` keyword"
            Choice.expr of
              (alt, _) => Some(alt)
              intro + "alternative"
              Choice.end of None
          Choice.end of None

let letChoice = letBinding(Keywords._let)

fun funChoice() =
  let intro = "function expression: "
  Choice.keyword of
    Keywords._fun
    intro + "keyword"
    Choice.expr of
      (params, body) => Tree.Lambda(params :: Nil, body)
      intro + "parameters"
      Choice.keyword of
        Keywords._thinArrow
        intro + "arrow"
        Choice.expr of
          (body, _) => body
          intro + "body"
          Choice.end of None

fun patternMatchingBody(intro, cons, nil) =
  fun makeMatchArms(get) = Choice.expr of
    (pat, rhsAndRest) => if rhsAndRest is [rhs, rest] then
      cons of Tree.Infix(Keywords._thinArrow, pat, rhs), rest
    intro + "pattern"
    Choice.keyword of
      Keywords._thinArrow
      intro + "arrow"
      Choice.expr of
        (curr, next) => [curr, next]
        intro + "body"
        Choice.end of nil
        Choice.keyword of
          Keywords._bar
          intro + "leading bar"
          Choice.Lazy(get, makeMatchArms)
  let matchArms = Choice.lazy of makeMatchArms
  tuple of
    Choice.Optional of
      rule of
        "match arms"
        Choice.keyword of
          Keywords._bar
          intro + "leading bar"
          Choice.end of ()
      rule of
        "match arms"
        matchArms

fun matchWithChoice() =
  let intro = "`match`-`with` expression: "
  Choice.keyword of
    Keywords._match
    intro + "keyword"
    Choice.expr of
      (scrutinee, branches) => Tree.Match(scrutinee, branches)
      intro + "scrutinee"
      Choice.keyword of
        Keywords._with
        intro + "with"
        ...patternMatchingBody(intro, (x, xs) => x :: xs, Nil)

fun matchFunctionChoice() =
  let intro = "`match` function: "
  Choice.keyword of
    Keywords._function
    intro + "`function` keyword"
    ...patternMatchingBody of
      intro
      (x, xs) => if xs is
        Tree.Match(scrut, arms) then Tree.Match(scrut, x :: arms)
      Tree.Match(Tree.empty, Nil)

val prefixRules = rule of
  "start of the statement"
  letChoice
  recursiveModifier
  funChoice()
  typeDefinition()
  matchWithChoice()
  matchFunctionChoice()
  ifThenElse()
  Choice.keyword of
    Keywords._underscore
    "wildcard pattern"
    Choice.end of Tree.Underscore()

fun makeInfixChoice(keyword) =
  Choice.keyword of
    keyword
    "operator `" + keyword.name + "`"
    Choice.expr of
      (rhs, _) => lhs => Tree.Infix(keyword, lhs, rhs)
      "operator `" + keyword.name + "` right-hand side"
      Choice.end of ()

val infixRules = rule of
  "the continuation of expressions"
  makeInfixChoice(Keywords._bar)

fun parse(tokens) =
  let
    current = tokens
    counter = 0
  
  fun yeetSpaces =
    while current is Token.Space :: tail do
      tracer.print of "skipped a space at " + counter, source.line
      set
        current = tail
        counter = counter + 1
    current
    
  fun consume =
    if current is head :: tail then
      tracer.print of "consumed `" + Token.summary(head) + "` at " + counter, source.line
      set current = tail
      set counter = counter + 1
    else
      tracer.print of "consumed: EOF", source.line
  
  fun parseRule(prec: Int, rule: ParseRule, opened) = tracer.trace of
    "parsing rule \"" + rule.name + "\" with precedence " + prec
    result => "parsed: " + result Tree.summary()
    () => ...
    if yeetSpaces is
      Token.Close(encountered) :: _ and opened is
        do tracer.print of "the case of closing brackets", source.line
        Some(expected) and
          encountered == expected and rule.endChoice is
            Some(value) then value
            None then
              // The rule doesn't allow an end here.
              Tree.error("unexpected close bracket `" + encountered + "`")
          else
            // The rule expects a different close bracket.
            Tree.error("mismatched brackets")
        None then Tree.error("unexpected bracket: " + encountered)
      Token.Identifier(name, _) :: _ and
        do tracer.print of "check if \"" + name + "\" is a keyword or not", source.line
        allKeywords.get(name) is Some(keyword) and
          do tracer.print of "keyword choices: ", rule.keywordChoices
            Iter.mapping of case [k, v] then "`" + k + "`"
            Iter.joined(", ")
          rule.keywordChoices.get(name) is
            Some(rest) then
              tracer.print of "found a rule starting with `" + name + "`", source.line
              tracer.print of "the rest of the rule: " + rest.display, source.line
              tracer.print of "keyword choices of the rule: " + Array(rule.keywordChoices), source.line
              consume
              parseRule(keyword.rightPrecOrMax, rest, opened)
            None then
              tracer.print of "no rule starting with `" + name + "` was found", source.line
              if simpleExpr(prec, opened) is
                Tree.Empty and
                  rule.endChoice is Some(value) then value
                  rule.exprChoice is Some then
                    Tree.error("expect an expression")
                  else ???
                expr and rule.exprChoice is
                  Some([process, rest]) then
                    let rhs = parseRule(prec, rest, opened)
                    process(expr, rhs)
                  None then expr Tree.Error("unexpected expression")
        do tracer.print of "\"" + name + "\" is not a keyword", source.line
      other :: _ and
        do tracer.print of "try parse an expression from " + TokenHelpers.preview(current), source.line
        simpleExpr(prec, opened) is
          Tree.Error(Tree.Empty(), _) and rule.endChoice is
            Some(value) then value
          reserve and rule.exprChoice is
            Some([process, rest]) then 
              let rhs = parseRule(prec, rest, opened)
              tracer.print of "the reserved expression: " + reserve Tree.summary(), source.line
              tracer.print of "the result from sub-rule: " + rhs Tree.summary(), source.line
              process(reserve, rhs)
            None then
              tracer.print of "the rule doesn't have a choice starting with expressions", source.line
              tracer.print of rule.display, source.line
              Tree.error("unexpected expression")
      Nil and rule.endChoice is
        Some(value) then value
        None then Tree.error("unexpected EOF")
  
  fun simpleExpr(prec: Int, bracket) = tracer.trace of
    "simple expression <<< " + prec + " " + TokenHelpers.preview(current)
    result => "simple expression >>> " + result Tree.summary()
    () => ...
    if yeetSpaces is
      Token.Identifier(name, symbolic) :: _ and allKeywords.get(name) is
        Some(keyword) and prefixRules.keywordChoices.get(name) is
          Some(rule) then
            consume
            let acc = parseRule(keyword.rightPrecOrMax, rule, bracket)
            exprCont(acc, prec, bracket)
          None then
            tracer.print("no rule starting with " + name, source.line)
            Tree.empty
        None then
          consume
          exprCont(Tree.Ident(name, symbolic), prec, bracket)
      Token.Literal(kind, literal) :: _ then
        consume
        exprCont(Tree.Literal(kind, literal), prec, bracket)
      Token.Open(kind) :: _ then
        consume
        let content = if
          // TODO: should the prec be 0?
          let content = simpleExpr(0, Some(kind))
          yeetSpaces is
            Token.Close(kind') :: _ and
              kind == kind' then
                tracer.print of "closing bracket " + kind, source.line
                consume
                if content is Tree.Empty and kind is
                  Token.Round then Tree.Tuple(Nil)
                  Token.BeginEnd then Tree.Sequence(Nil)
                else
                  content
              else content Tree.Error("mismatched brackets")
            token :: _ then
              let message = "expect a close bracket instead of " + token
              tracer.print of message, source.line
              content Tree.Error(message)
            Nil then
              let message = "expect a close bracket instead of EOF"
              tracer.print of message, source.line
              content Tree.Error(message)
        exprCont(content, prec, bracket)
      Token.Close(kind) :: _ and bracket is
        Some(kind') and
          kind == kind' then Tree.Empty()
          else Tree.error("mismatched brackets")
        None then
          tracer.print("missing close bracket", source.line)
          Tree.error("missing close bracket")
      token :: _ then Tree.error("unrecognized token: " + token)
      Nil then Tree.error("unexpected EOF")
  
  fun exprCont(acc: Tree, prec: Int, bracket) = if yeetSpaces is
    do tracer.print(">>> exprCont " + prec + " " + acc Tree.summary() + " <<<", source.line)
    Token.Identifier(name, _) :: _ and allKeywords.get(name) is Some(keyword) and
      do tracer.print of "found a keyword: " + name, source.line
      infixRules.keywordChoices.get(name) is Some(rule) and
        do tracer.print of "found an infix keyword " + name, source.line
        keyword.leftPrecOrMin > prec and rule.exprChoice is
          Some([process, rest]) then
            consume
            let rhs = simpleExpr(keyword.rightPrecOrMin, bracket)
            let acc' = Tree.Infix(keyword, acc, rhs)
            exprCont(acc', prec, bracket)
          None then acc
      do tracer.print of "keyword `" + name + "` does not have infix rules", source.line
    Token.Identifier(name, true) :: _ and allKeywords.get(name) is None and
      do tracer.print of "found an operator \"" + name + "\"", source.line
      opPrec(name) is [leftPrec, rightPrec] and
        do tracer.print of "its precedence is " + leftPrec, source.line
        leftPrec > prec then
          consume
          let op = Tree.Ident(name, true)
          let rhs = simpleExpr(rightPrec, bracket)
          exprCont(Tree.App(op, acc :: rhs :: Nil), prec, bracket)
        else
          acc
    Token.Close(kind) :: _ and bracket is
      do tracer.print of "found a close bracket of " + kind, source.line
      Some(kind') and
        kind == kind' then acc
        else acc Tree.Error("mismatched brackets")
      None then acc Tree.Error("missing close bracket")
    Token.Semicolon :: _ then
      tracer.print of "found a semicolon", source.line
      if allKeywords.get(";") is Some(keyword) and
        keyword.leftPrec is Some(leftPrec) and
          leftPrec > prec then
            consume
            if keyword.rightPrec is Some(rightPrec) then ...
            let acc' = if simpleExpr(rightPrec, bracket) is
              Tree.Sequence(trees) then Tree.Sequence(acc :: trees)
              tree then Tree.Sequence(acc :: tree :: Nil)
            exprCont(acc', prec, bracket)
          else
            tracer.print of "cannot consume " + keyword, source.line
            acc
    Token.Comma :: _ then
      tracer.print of "found a comma", source.line
      if allKeywords.get(",") is Some(keyword) and
        keyword.leftPrec is Some(leftPrec) and
          leftPrec > prec then
            consume
            if keyword.rightPrec is Some(rightPrec) then ...
            let acc' = if simpleExpr(rightPrec, bracket) is
              Tree.Tuple(trees) then Tree.Tuple(acc :: trees)
              tree then Tree.Tuple(acc :: tree :: Nil)
            exprCont(acc', prec, bracket)
          else
            tracer.print of "cannot consume " + keyword, source.line
            acc
    token :: _ and
      appPrec > prec then
        do tracer.print of "found an application", source.line
        if simpleExpr(appPrec, bracket) is
          Tree.Empty then acc
          Tree.Error then acc
          rhs then exprCont(Tree.App(acc, rhs :: Nil), prec, bracket)
      else
        tracer.print of "cannot consume " + token, source.line
        acc
    Nil and bracket is
      do tracer.print of "found an EOF", source.line
      Some then acc Tree.Error("expect a close bracket instead of EOF")
      None then acc
  
  let tree = simpleExpr(0, None)
  if yeetSpaces is
    token :: _ then
      let message = "expect EOF instead of " + token
      tracer.print of message, source.line
      tree Tree.Error(message)
    Nil then tree
