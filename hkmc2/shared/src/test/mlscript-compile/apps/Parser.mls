import "../Predef.mls"
import "../Option.mls"
import "../Stack.mls"
import "../BetterMap.mls"
import "../TreeTracer.mls"
import "../Iter.mls"
import "../apps/Lexer.mls"
import "./parsing/Token.mls"
import "./parsing/TokenHelpers.mls"
import "./parsing/Keyword.mls"
import "./parsing/Precedence.mls"
import "./parsing/Tree.mls"
import "./parsing/ParseRule.mls"

open Predef
open Option
open Stack
open BetterMap
open TreeTracer { TreeTracer }
open Token { LiteralKind, BracketKind }
open Precedence { Keywords, appPrec, opPrec }
open Keyword { allKeywords, Keyword }
open ParseRule { ParseRule, Choice, rule }

type Opt[A] = Some[A] | None

module Parser with ...

//  _     _     _
// | |   (_)___| |_
// | |   | / __| __|
// | |___| \__ \ |_
// |_____|_|___/\__|
// 
// =================

fun at(target, index) = target.at(index)

fun first(array) = if array is [first, ...] then first

fun second(array) = if array is [_, second, ...] then second

fun toStack(array) =
  let
    length = array.length
    i = length - 1
    reserve = Nil
  while i >= 0 do
    set reserve = array.at(i) :: reserve
    set i = i - 1
  reserve

fun stack(...args) = args toStack()

fun mapJoin[A](stack: Stack[A], op: A -> Str, sep: Str) =
  let buffer = ""
  while stack is head :: tail do
    set buffer = buffer + op(head)
    if tail is _ :: _ do
      set buffer = buffer + sep
    set stack = tail
  buffer

fun collectFirst[A, B](stack: Stack[A], op) =
  let lastResult = None
  while stack is head :: tail and
    do set lastResult = op(head)
    lastResult is None do
      set stack = tail
  lastResult

fun collectToArray[A, B](stack: Stack[A], p) =
  let elements = []
  while stack is head :: tail do
    if p(head) is Some(value) do
      elements.push of value
    set stack = tail
  elements

fun map(xs, op) = if xs is
  Nil then Nil
  head :: tail then ...
  let
    result = op(head) :: Nil
    current = result
    rest = tail
  while rest is head :: tail do
    let next = op(head) :: Nil
    set
      current.tail = next
      current = next
      rest = tail
  result

//  ____       _
// |  _ \  ___| |__  _   _  __ _
// | | | |/ _ \ '_ \| | | |/ _` |
// | |_| |  __/ |_) | |_| | (_| |
// |____/ \___|_.__/ \__,_|\__, |
//                         |___/
// ==============================

val tracer = new TreeTracer

fun indented(text) = text.split("\n").join("\n  ")

fun showAsTree(thing) =
  fun itemize(something) = if something is
    Some(content) then tuple of ["Some of " + go(content)], []
    None then tuple of "None", []
    head :: tail then
      let
        items = [go(head)]
        remaining = tail
      while remaining is
        head' :: tail' do
          items.push(go of head')
          set remaining = tail'
      tuple of ("Stack of \n" + "  " + indented of items.join("\n")), []
    Nil then ["Nil", []]
    Str then [JSON.stringify(something), []] // TODO: This doesn't work.
    Int then [something.toString(), []]
    Tree.Empty then ["Empty", []]
    Tree.Error(Tree.Empty, m) then tuple of "Error", [["message", go(m)]]
    Tree.Error(t, m) then tuple of "Error", [["tree", go(t)], ["message", go(m)]]
    Tree.Ident(n, _) then tuple of "Ident", [["name", go(n)]]
    Tree.Bracketed(k, items) then tuple of
      "Bracketed#" + k, [["items", go(items)]]
    Tree.Underscore() then tuple of "Underscore", []
    Tree.Modified(m, s) then
      tuple of "Modified", [["modifier", go(m)], ["subject", go(s)]]
    Tree.Tuple(t) then tuple of "Tuple", [["items", go(t)]]
    Tree.Sequence(t) then tuple of "Sequence", [["items", go(t)]]
    Tree.Literal(k, v) then tuple of ("Literal#" + go(k) + " of " + go(v)), []
    Tree.Match(scrutinee, branches) then tuple of
      "Match", [["scrutinee", scrutinee], ["branches", go(branches)]]
    Tree.App(c, a) then tuple of "App", [["callee", go(c)], ["arguments", go(a)]]
    Tree.Infix(op, lhs, rhs) then tuple of
      "Infix", [["op", go(op)], ["lhs", go(lhs)], ["rhs", go(rhs)]]
    Tree.Ternary(n, l, r, b) then tuple of
      "Ternary", [["name", go(n)], ["lhs", go(l)], ["rhs", go(r)], ["body", go(b)]]
    Tree.Lambda(p, b) then tuple of "Lambda", [["params", go(p)], ["body", go(b)]]
    Keyword as keyword then [keyword.toString(), []]
    LiteralKind.Integer then tuple of "Integer", []
    LiteralKind.Decimal then tuple of "Decimal", []
    LiteralKind.String then tuple of "String", []
    LiteralKind.Boolean then tuple of "Boolean", []
    else tuple of "Unknown", [["JSON.stringify(_)", JSON.stringify(something)]]
  fun go(something) = if itemize(something) is
    [intro, []] then intro
    [intro, [field]] and intro != "Unknown" then intro + " of " + second of field
    [intro, fields] then
      let dialogue = fields.map of (field, _, _) =>
        field first() + " = " + field second()
      intro + ":\n  " + indented of dialogue.join("\n")
  go(thing)

fun letBinding(keyword: Keyword) =
  let intro = keyword.name + " binding: "
  fun makeBinding(body) = Choice.expr of
    (lhs, rhsAndBody) => if rhsAndBody is [rhs, body] then
      Tree.Ternary(Keywords._let, lhs, rhs, body)
    intro + "left-hand side"
    Choice.keyword of
      Keywords._equal
      intro + "right-hand side"
      body
  fun makeItems(get) = Choice.expr of
    (rhs, body) => [rhs, body]
    intro + "right-hand side"
    Choice.keyword of
      Keywords._and
      intro + "`and` keyword"
      makeBinding of Choice.Lazy(get, makeItems)
    Choice.keyword of
      Keywords._in
      intro + "`in` keyword"
      Choice.expr of
        (body, _) => body
        intro + "body"
        Choice.end of ()
    // Choice.end of Tree.empty
  let items = Choice.lazy of makeItems
  Choice.keyword of
    keyword
    intro + "keyword"
    makeBinding of items

fun recursiveModifier = Choice.keyword of
  Keywords._rec
  "rec keyword"
  Choice.expr of
    (body, _) => Tree.Modified(Keywords._rec, body)
    "body"
    Choice.end of ()

fun typeDefinition() =
  let intro = "type definition: "
  Choice.keyword of
    Keywords._type
    intro + "`type` keyword"
    Choice.expr of
      (name, body) => Tree.Ternary(Keywords._type, name, body, None)
      intro + "name"
      Choice.keyword of
        Keywords._equal
        intro + "equal sign"
        Choice.expr of
          (body, _) => body
          intro + "body"
          Choice.end of ()

fun ifThenElse() =
  let intro = "if-then-else: "
  Choice.keyword of
    Keywords._if
    intro + "`if` keyword"
    Choice.expr of
      (tst, conAndAlt) => if conAndAlt is [con, alt] then
        Tree.Ternary(Keywords._if, tst, con, alt)
      intro + "condition"
      Choice.keyword of
        Keywords._then
        intro + "`then` keyword"
        Choice.expr of
          (con, optAlt) => [con, optAlt]
          intro + "consequent"
          Choice.keyword of
            Keywords._else
            intro + "`else` keyword"
            Choice.expr of
              (alt, _) => Some(alt)
              intro + "alternative"
              Choice.end of None
          Choice.end of None

let letChoice = letBinding(Keywords._let)

fun funChoice() =
  let intro = "function expression: "
  Choice.keyword of
    Keywords._fun
    intro + "keyword"
    Choice.expr of
      (params, body) => Tree.Lambda(params :: Nil, body)
      intro + "parameters"
      Choice.keyword of
        Keywords._thinArrow
        intro + "arrow"
        Choice.expr of
          (body, _) => body
          intro + "body"
          Choice.end of None

fun patternMatchingBody(intro, cons, nil) =
  fun makeMatchArms(get) = Choice.expr of
    (pat, rhsAndRest) => if rhsAndRest is [rhs, rest] then
      cons of Tree.Infix(Keywords._thinArrow, pat, rhs), rest
    intro + "pattern"
    Choice.keyword of
      Keywords._thinArrow
      intro + "arrow"
      Choice.expr of
        (curr, next) => [curr, next]
        intro + "body"
        Choice.end of nil
        Choice.keyword of
          Keywords._bar
          intro + "leading bar"
          Choice.Lazy(get, makeMatchArms)
  let matchArms = Choice.lazy of makeMatchArms
  tuple of
    Choice.Optional of
      rule of
        intro + "body"
        Choice.keyword of
          Keywords._bar
          intro + "leading bar"
          Choice.end of ()
      rule of
        intro + "body"
        matchArms

fun matchWithChoice() =
  let intro = "`match` expression: "
  Choice.keyword of
    Keywords._match
    intro + "keyword"
    Choice.expr of
      (scrutinee, branches) => Tree.Match(scrutinee, branches)
      intro + "scrutinee"
      Choice.keyword of
        Keywords._with
        intro + "with"
        ...patternMatchingBody(intro, (x, xs) => x :: xs, Nil)

fun matchFunctionChoice() =
  let intro = "`function` definition: "
  Choice.keyword of
    Keywords._function
    intro + "`function` keyword"
    ...patternMatchingBody of
      intro
      (x, xs) => if xs is
        Tree.Match(scrut, arms) then Tree.Match(scrut, x :: arms)
      Tree.Match(Tree.empty, Nil)

val prefixRules = rule of
  "prefix rules for expressions"
  letChoice
  recursiveModifier
  funChoice()
  matchWithChoice()
  matchFunctionChoice()
  ifThenElse()

val moduleRules = rule of
  "start of the statement"
  letChoice
  typeDefinition()

fun makeInfixChoice(keyword) =
  Choice.keyword of
    keyword
    "operator `" + keyword.name + "`"
    Choice.expr of
      (rhs, _) => lhs => Tree.Infix(keyword, lhs, rhs)
      "operator `" + keyword.name + "` right-hand side"
      Choice.end of ()

val infixRules = rule of
  "the continuation of expressions"
  makeInfixChoice(Keywords._bar)

fun parse(tokens) =
  let
    current = tokens
    counter = 0
  
  fun yeetSpaces =
    while current is Token.Space :: tail do
      tracer.print of "skipped a space at " + counter, source.line
      set
        current = tail
        counter = counter + 1
    current
    
  fun consume =
    if current is head :: tail then
      tracer.print of "consumed `" + Token.summary(head) + "` at " + counter
      set current = tail
      set counter = counter + 1
    else
      tracer.print of "consumed: EOF"
  
  // Useful when consuming matched brackets.
  fun require(result: Tree, expected) = if yeetSpaces is
    Some(actual) and
      expected Token.same(actual) then
        consume
        result
      else result Tree.Error of mkStr of
        "Expected token "
        expected Token.summary()
        ", but found "
        actual Token.summary() 
    None then result Tree.Error of mkStr of
      "Expected token "
      expected Token.summary()
      ", but found end of input"
  
  fun parseRule(prec: Int, rule: ParseRule, opened) = tracer.trace of
    "parsing rule \"" + rule.name + "\" with precedence " + prec
    result => "parsed: " + result Tree.summary()
    () => ...
    if yeetSpaces is
      Token.Close(encountered) :: _ and opened is
        do tracer.print of "the case of closing brackets", source.line
        Some(expected) and
          encountered == expected and rule.endChoice is
            Some(value) then value
            None then
              // The rule doesn't allow an end here.
              Tree.error("unexpected close bracket `" + encountered + "`")
          else
            // The rule expects a different close bracket.
            Tree.error("mismatched brackets")
        None then Tree.error("unexpected bracket: " + encountered)
      Token.Identifier(name, _) :: _ and
        do tracer.print of "check if \"" + name + "\" is a keyword or not", source.line
        allKeywords.get(name) is Some(keyword) and
          do tracer.print of "keyword choices: ", rule.keywordChoices
            Iter.mapping of case [k, v] then "`" + k + "`"
            Iter.joined(", ")
          rule.keywordChoices.get(name) is
            Some(rest) then
              tracer.print of "found a rule starting with `" + name + "`", source.line
              tracer.print of "the rest of the rule: " + rest.display, source.line
              consume
              // parseRule(keyword.rightPrecOrMax, rest, opened)
              parseRule(0, rest, opened)
            None and
              do tracer.print of "no rule starting with `" + name + "` was found", source.line
              // if simpleExpr(prec, opened) is
              //   Tree.Empty and
              //     rule.endChoice is Some(value) then value
              //     rule.exprChoice is Some then
              //       Tree.error("expect an expression")
              //     else ???
              //   expr and rule.exprChoice is
              //     Some([isType, process, rest]) then
              //       let rhs = parseRule(prec, rest, opened)
              //       process(expr, rhs)
              //     None then expr Tree.Error("unexpected expression")
              do tracer.print of "the left prec of `" + name + "` is " + keyword.leftPrec, source.line
              rule.exprChoice is Some([isType, process, rest]) and keyword.leftPrecOrMin > prec then
                let acc = simpleExpr(keyword.rightPrecOrMax, opened) // TODO: isType?
                let tree = parseRule(prec, rest, opened)
                process(acc, tree)
              rule.endChoice is Some(value) then
                tracer.print of "found end choice", source.line
                value
              else ???
        do tracer.print of "\"" + name + "\" is not a keyword", source.line
      other :: _ and
        do tracer.print of "try parse an expression from " + TokenHelpers.preview(current), source.line
        // simpleExpr(prec, opened) is
        //   Tree.Error(Tree.Empty(), _) and rule.endChoice is
        //     Some(value) then value
        //   reserve and rule.exprChoice is
        //     Some([isType, process, rest]) then 
        //       let rhs = parseRule(prec, rest, opened)
        //       tracer.print of "the reserved expression: " + reserve Tree.summary(), source.line
        //       tracer.print of "the result from sub-rule: " + rhs Tree.summary(), source.line
        //       process(reserve, rhs)
        //     None then
        //       tracer.print of "the rule doesn't have a choice starting with expressions", source.line
        //       tracer.print of rule.display, source.line
        //       Tree.error("unexpected expression")
        // ----
        rule.exprChoice is Some([isType, process, rest]) and
          let acc = (if isType then typeExpr else simpleExpr)(prec, opened)
          acc Tree.nonEmptyError() then
            let tree = parseRule(prec, rest, opened)
            tracer.print of "acc: " + acc Tree.summary(), source.line
            tracer.print of "tree: " + tree Tree.summary(), source.line
            process(acc, tree)
          do tracer.print of "fallback to end choice", source.line
        do tracer.print of "no expression choice", source.line
        rule.endChoice is Some(value) then
          tracer.print of "found end choice", source.line
          value
        do tracer.print of "no end choice", source.line
      Nil and rule.endChoice is
        Some(value) then value
        None then Tree.error("unexpected end of input")
  
  fun simpleExpr(prec: Int, bracket) = tracer.trace of
    "simple expression <<< " + prec + " " + TokenHelpers.preview(current)
    result => "simple expression >>> " + result Tree.summary()
    () => ...
    if yeetSpaces is
      Token.Identifier(name, symbolic) :: _ and allKeywords.get(name) is
        Some(keyword) and prefixRules.keywordChoices.get(name) is
          Some(rule) then
            consume
            let acc = parseRule(keyword.rightPrecOrMax, rule, bracket)
            exprCont(acc, prec, bracket)
          None then
            tracer.print("no rule starting with " + name, source.line)
            Tree.empty
        None then
          consume
          exprCont(Tree.Ident(name, symbolic), prec, bracket)
      Token.Literal(kind, literal) :: _ then
        consume
        exprCont(Tree.Literal(kind, literal), prec, bracket)
      Token.Open(kind) :: _ then
        consume
        let content = if
          let content = simpleExpr(0, Some(kind))
          yeetSpaces is
            Token.Close(kind') :: _ and
              kind == kind' then
                tracer.print of "closing bracket " + kind, source.line
                consume
                if
                  content is Tree.Empty and kind is
                    Token.Round then Tree.Tuple(Nil)
                    Token.Square then Tree.Bracketed(Token.Square, Nil)
                    Token.BeginEnd then Tree.Sequence(Nil)
                  kind is
                    Token.Square then Tree.Bracketed(Token.Square, content)
                    else content
              else content Tree.Error("mismatched brackets")
            token :: _ then
              let message = "expect a close bracket instead of " + token
              tracer.print of message, source.line
              content Tree.Error(message)
            Nil then
              let message = "expect a close bracket instead of EOF"
              tracer.print of message, source.line
              content Tree.Error(message)
        exprCont(content, prec, bracket)
      Token.Close(kind) :: _ and bracket is
        Some(kind') and
          kind == kind' then Tree.Empty()
          else Tree.error("mismatched brackets")
        None then
          tracer.print("missing close bracket", source.line)
          Tree.error("missing close bracket")
      token :: _ then Tree.error("unrecognized token: " + token)
      Nil then Tree.error("unexpected EOF")
  
  fun exprCont(acc: Tree, prec: Int, bracket) = if yeetSpaces is
    do tracer.print(">>> exprCont " + prec + " " + acc Tree.summary() + " <<<", source.line)
    Token.Identifier(name, _) :: _ and allKeywords.get(name) is Some(keyword) and
      do tracer.print of "found a keyword: " + name, source.line
      infixRules.keywordChoices.get(name) is Some(rule) and
        do tracer.print of "found an infix keyword " + name, source.line
        keyword.leftPrecOrMin > prec and rule.exprChoice is
          Some([isType, process, rest]) then
            consume
            let rhs = simpleExpr(keyword.rightPrecOrMin, bracket)
            let acc' = Tree.Infix(keyword, acc, rhs)
            exprCont(acc', prec, bracket)
          None then acc
      do tracer.print of "keyword `" + name + "` does not have infix rules", source.line
    Token.Identifier(name, true) :: _ and allKeywords.get(name) is None and
      do tracer.print of "found an operator \"" + name + "\"", source.line
      opPrec(name) is [leftPrec, rightPrec] and
        do tracer.print of "its precedence is " + leftPrec, source.line
        leftPrec > prec then
          consume
          let op = Tree.Ident(name, true)
          let rhs = simpleExpr(rightPrec, bracket)
          exprCont(Tree.App(op, acc :: rhs :: Nil), prec, bracket)
        else
          acc
    Token.Close(kind) :: _ and bracket is
      do tracer.print of "found a close bracket of " + kind, source.line
      Some(kind') and
        kind == kind' then acc
        else acc Tree.Error("mismatched brackets")
      None then acc Tree.Error("missing close bracket")
    // TODO: BEGIN deduplication
    Token.Semicolon :: _ and
      do tracer.print of "found a semicolon", source.line
      Keywords._semicolon.leftPrec Option.get() > prec then
        consume
        simpleExpr(Keywords._semicolon.rightPrec Option.get(), bracket)
          Tree.sequenceWithHead of acc
          exprCont of prec, bracket
      else
        tracer.print of "cannot consume the semicolon", source.line
        acc
    Token.Comma :: _ and
      do tracer.print of "found a comma", source.line
      Keywords._comma.leftPrec Option.get() > prec then
        consume
        simpleExpr(Keywords._comma.rightPrec Option.get(), bracket)
          Tree.tupleWithHead of acc
          exprCont of prec, bracket
      else
        tracer.print of "cannot consume the comma", source.line
        acc
    // TODO: END deduplication
    token :: _ and
      appPrec > prec then
        do tracer.print of "found an application", source.line
        if simpleExpr(appPrec, bracket) is
          Tree.Empty then acc
          Tree.Error then acc
          rhs then exprCont(Tree.App(acc, rhs :: Nil), prec, bracket)
      else
        tracer.print of "cannot consume " + token, source.line
        acc
    Nil and bracket is
      do tracer.print of "found an EOF", source.line
      Some then acc Tree.Error("expect a close bracket instead of EOF")
      None then acc
  
  fun typeExpr(prec: Int, bracket: Opt[BracketKind]): Tree = tracer.trace of
    "typeExpr <<< " + prec + " " + bracket + " " + TokenHelpers.preview(current)
    result => "typeExpr >>> " + result Tree.summary()
    () => ...
    if yeetSpaces is
      Token.TypeVariable(name) :: _ then
        consume
        // What's the corresponding tree of type variables?
        typeExprCont(Tree.Ident(name), prec, bracket)
      Token.Identifier("_", _) :: _ then
        consume
        typeExprCont(Tree.Underscore(), prec, bracket)
      Token.Open(Token.Round) :: _ then
        consume
        typeExpr(0, Some(Token.Round))
          require of Token.Close(Token.Round)
          typeExprCont of prec, bracket
      // '[' is special because of the open/close variant markers.
      Token.Open(Token.Square) :: _ then
        consume
        // OCaml disallows spaces between '[' and '<'/'>'.
        let openness = if current is
          (Token.Identifier(">", _) as marker) :: _ then
            consume
            Some(marker)
          (Token.Identifier("<", _) as marker) :: _ then
            consume
            // An optional `|` is allowed only after "<".
            if yeetSpaces is Token.Identifier("|", _) :: _ do consume
            Some(marker)
          else None
        typeExpr(0, Some(Token.Square))
          require of Token.Close(Token.Square)
          typeExprCont of prec, bracket
      // Handle closing brackets.
      Token.Close(kind) :: _ and bracket is
        Some(kind') then Tree.Empty()
        Some(kind) then Tree.error("mismatched brackets")
        None then Tree.error("unexpected close bracket")
      // `<` and `>` in type expressions are not infix operators
      Token.Identifier("<", _) :: _ then
        consume
        typeExpr(0, Some(Token.Angle))
          require of Token.Identifier(">", _)
          typeExprCont of prec, bracket
      // Closing ">" is handled in the same way as closing other brackets.
      Token.Identifier(">", _) :: _ and bracket is
        Some(Token.Angle) then Tree.Empty()
        Some(kind) then Tree.error("mismatched brackets")
        None then Tree.error("unexpected close bracket")
  
  fun typeExprCont(acc: Tree, prec: Int, bracket: Opt[BracketKind]) =
    tracer.print of ">>> typeExprCont " + prec + " " + acc Tree.summary() + " <<<", source.line
    if yeetSpaces is
      Token.Close(kind) :: _ and bracket is
        Some(kind') and
          kind == kind' then acc
          else Tree.error("mismatched brackets")
        None then Tree.error("unexpected close bracket")
      Token.Identifier(">", _) :: _ and bracket is
        Some(Token.Angle) then acc
        Some(kind) then Tree.error("mismatched brackets")
        None then Tree.error("unexpected close bracket")
      // TODO: BEGIN deduplication
      Token.Semicolon :: _ and
        do tracer.print of "found a semicolon", source.line
        Keywords._semicolon.leftPrec Option.get() > prec then
          consume
          typeExpr(Keywords._semicolon.rightPrec Option.get(), bracket)
            Tree.sequenceWithHead of acc
            typeExprCont of prec, bracket
        else
          tracer.print of "cannot consume the semicolon", source.line
          acc
      Token.Comma :: _ and
        do tracer.print of "found a comma", source.line
        Keywords._comma.leftPrec Option.get() > prec then
          consume
          typeExpr(Keywords._comma.rightPrec Option.get(), bracket)
            Tree.tupleWithHead of acc
            typeExprCont of prec, bracket
        else
          tracer.print of "cannot consume the comma", source.line
          acc
      // TODO: END deduplication
      // * the case of type application
      token :: _ and
        appPrec > prec then
          do tracer.print of "found an application", source.line
          if typeExpr(appPrec, bracket) is
            Tree.Empty then acc
            Tree.Error then acc
            rhs then exprCont(Tree.App(acc, rhs :: Nil), prec, bracket)
        else
          tracer.print of "cannot consume " + token, source.line
          acc
  
  // fun mod(acc: Stack[Tree]) = if yeetSpaces is
  //   Token.Identifier(";;", _) :: _ then
  //     consume
  //     mod
  //   Nil then acc reverse()
  
  // fun modCont(acc: Stack[Tree]) = if yeetSpaces is
  //   Token.Identifier(";;", _) :: _ then
  //     consume
  //     acc mod()
  //   _ :: _ then parseRule(0, moduleRules, None) :: acc
  //   Nil then acc mod()
  
  let tree = simpleExpr(0, None)
  if yeetSpaces is
    token :: _ then
      let message = "expect EOF instead of " + token
      tracer.print of message, source.line
      tree Tree.Error(message)
    Nil then tree
