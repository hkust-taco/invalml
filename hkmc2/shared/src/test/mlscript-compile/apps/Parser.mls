import "../Predef.mls"
import "../Option.mls"
import "../Stack.mls"
import "../BetterMap.mls"
import "../TreeTracer.mls"
import "../Iter.mls"
import "../apps/Lexer.mls"
import "./parsing/Token.mls"
import "./parsing/TokenHelpers.mls"
import "./parsing/Keyword.mls"
import "./parsing/Precedence.mls"
import "./parsing/Tree.mls"
import "./parsing/ParseRule.mls"

open Predef
open Option
open Stack
open BetterMap
open TreeTracer { TreeTracer }
open Token { LiteralKind, BracketKind }
open Precedence { Keywords, TypeKeywords, opPrec }
open Keyword { Keyword }
open ParseRule { ParseRule, Choice, rule }

type Opt[A] = Some[A] | None

module Parser with ...

val tracer = new TreeTracer



fun letBinding(hasInClause: Bool) =
  let intro = "let binding: "
  fun makeBinding(bindingBody) = Choice.term of
    if hasInClause then
      (head, bodyAndLetIn) => if bodyAndLetIn is
        [body, Tree.LetIn(bindings, letBody)] then
          Tree.LetIn([head, body] :: bindings, letBody)
    else
      (head, bodyAndDefine) => if bodyAndDefine is
        [body, Tree.Define(kind, defs)] then
          Tree.Define(kind, [head, body] :: defs)
    intro + "left-hand side"
    Choice.keyword of
      Keywords._equal
      intro + "right-hand side"
      bindingBody
  fun makeItems(get) = Choice.term of
    (body, defLike) => [body, defLike]
    intro + "right-hand side"
    Choice.keyword of
      Keywords._and
      intro + "`and` keyword"
      makeBinding of Choice.Lazy(get, makeItems)
    ...if hasInClause then tuple of
      Choice.keyword of
        Keywords._in
        intro + "`in` keyword"
        Choice.term of
          (body, _) => Tree.LetIn(Nil, body)
          intro + "body"
          Choice.end of ()
      Choice.end of Tree.LetIn(Nil, Tree.empty)
    else tuple of Choice.end of Tree.Define(Tree.DefineKind.Let(false), Nil)
  let items = Choice.lazy of makeItems
  Choice.keyword of
    Keywords._let
    intro + "keyword"
    Choice.Optional of
      rule of
        intro + "keyword"
        Choice.keyword of
          Keywords._rec
          intro + "`rec` keyword"
          Choice.end of ()
      rule of
        intro + "body"
        makeBinding of items

let letExpression = letBinding(true)
let letDefinition = letBinding(false)

fun ifThenElse() =
  let intro = "if-then-else: "
  Choice.keyword of
    Keywords._if
    intro + "`if` keyword"
    Choice.term of
      (tst, conAndAlt) => if conAndAlt is [con, alt] then
        Tree.Ternary(Keywords._if, tst, con, alt)
      intro + "condition"
      Choice.keyword of
        Keywords._then
        intro + "`then` keyword"
        Choice.term of
          (con, optAlt) => [con, optAlt]
          intro + "consequent"
          Choice.keyword of
            Keywords._else
            intro + "`else` keyword"
            Choice.term of
              (alt, _) => Some(alt)
              intro + "alternative"
              Choice.end of None
          Choice.end of None

fun funChoice() =
  let intro = "function expression: "
  Choice.keyword of
    Keywords._fun
    intro + "keyword"
    Choice.term of
      (params, body) => Tree.Lambda(params :: Nil, body)
      intro + "parameters"
      Choice.keyword of
        Keywords._thinArrow
        intro + "arrow"
        Choice.term of
          (body, _) => body
          intro + "body"
          Choice.end of None

fun patternMatchingBody(intro, cons, nil) =
  fun makeMatchArms(get) = Choice.term of
    (pat, rhsAndRest) => if rhsAndRest is [rhs, rest] then
      cons of Tree.Infix(Keywords._thinArrow, pat, rhs), rest
    intro + "pattern"
    Choice.keyword of
      Keywords._thinArrow
      intro + "arrow"
      Choice.term of
        (curr, next) => [curr, next]
        intro + "body"
        Choice.end of nil
        Choice.keyword of
          Keywords._bar
          intro + "leading bar"
          Choice.Lazy(get, makeMatchArms)
  let matchArms = Choice.lazy of makeMatchArms
  tuple of
    Choice.Optional of
      rule of
        intro + "body"
        Choice.keyword of
          Keywords._bar
          intro + "leading bar"
          Choice.end of ()
      rule of
        intro + "body"
        matchArms

fun matchWithChoice() =
  let intro = "`match` expression: "
  Choice.keyword of
    Keywords._match
    intro + "keyword"
    Choice.term of
      (scrutinee, branches) => Tree.Match(scrutinee, branches)
      intro + "scrutinee"
      Choice.keyword of
        Keywords._with
        intro + "with"
        ...patternMatchingBody(intro, (x, xs) => x :: xs, Nil)

fun matchFunctionChoice() =
  let intro = "`function` definition: "
  Choice.keyword of
    Keywords._function
    intro + "`function` keyword"
    ...patternMatchingBody of
      intro
      (x, xs) => if xs is
        Tree.Match(scrut, arms) then Tree.Match(scrut, x :: arms)
      Tree.Match(Tree.empty, Nil)

let whileTerm = Choice.keyword of
  Keywords._while
  "while condition"
  Choice.term of
    Tree.While
    "while body"
    Choice.keyword of
      Keywords._do
      "while body"
      Choice.term of
        (body, _) => body
        "while end"
        Choice.keyword of
          Keywords._done
          "while end"
          Choice.end of ()

fun forTerm =
  let intro = "for: "
  let innerPart = Choice.term of
    (end, body) => [end, body]
    intro + "`do` keyword"
    Choice.keyword of
      Keywords._do
      intro + "body expression"
      Choice.term of
        (body, _) => body
        intro + "`done` keyword"
        Choice.keyword of
          Keywords._done
          "the end"
          Choice.end of ()
  Choice.keyword of
    Keywords._for
    intro + "left-hand side"
    Choice.term of
      (head, startEndBody) => if startEndBody is
        [start, end, body] then
          Tree.For(head, start, end, body)
      intro + "head"
      Choice.keyword of
        Keywords._equal
        intro + "start expression"
        Choice.term of
          (start, endBody) => if endBody is [end, body] then
            [start, end, body]
          intro + "`to` or `downto` keyword"
          Choice.keyword of
            Keywords._to
            "end expression"
            innerPart
          Choice.keyword of
            Keywords._downto
            "end expression"
            innerPart

fun makeInfixChoice(keyword: Keyword, rhsKind: Str, compose: (Tree, Tree) -> Tree) =
  Choice.keyword of
    keyword
    "operator `" + keyword.name + "`"
    Choice.reference of
      rhsKind
      (rhs, _) => lhs => compose(lhs, rhs)
      "operator `" + keyword.name + "` right-hand side"
      Choice.end of ()

val termInfixRule = rule of
  "infix rules for expressions"
  // Tuple (separated by commas)
  makeInfixChoice of Keywords._comma, "term", (lhs, rhs) => if rhs is
    Tree.Tuple(tail) then Tree.Tuple(lhs :: tail)
    else Tree.Tuple(lhs :: rhs :: Nil)
  // Sequence (separated by semicolons)
  makeInfixChoice of Keywords._semicolon, "term", (lhs, rhs) => if rhs is
    Tree.Sequence(tail) then Tree.Sequence(lhs :: tail)
    else Tree.Sequence(lhs :: rhs :: Nil)
  // Type ascription: <expr> ":" <typexpr>
  Choice.keyword of
    Keywords._colon
    "type ascription"
    Choice.typeExpr of
      (rhs, _) => lhs => Tree.Infix(Keywords._colon, lhs, rhs)
      "right-hand side type"
      Choice.end of ()

fun makeBracketRule(opening, closing, contentKind, wrapContent) =
  // Pass the error message of closing bracket to the content.
  Choice.keyword of ...
  opening
  contentKind + ": bracket content"
  Choice.reference of ...
  contentKind
  (tree: Tree, end: Tree) => if end is
    Tree.Error(Tree.Empty, msg) then wrapContent(tree) Tree.Error(msg)
    Tree.Empty                  then wrapContent(tree)
  contentKind + ": close bracket"
  Choice.keyword of ...
  closing
  contentKind + ": the end of bracket"
  Choice.end of Tree.empty

// Prefix rules and infix rules for expressions.
val termRule = rule of
  "prefix rules for expressions"
  letExpression
  funChoice()
  matchWithChoice()
  matchFunctionChoice()
  ifThenElse()
  whileTerm
  forTerm
  // Choices for brackets
  makeBracketRule of
    Keywords._leftRound
    Keywords._rightRound
    "term"
    (tree) => if tree is Tree.Empty then Tree.Tuple(Nil) else tree
  makeBracketRule of
    Keywords._leftSquare
    Keywords._rightSquare
    "term"
    (tree) => Tree.Bracketed of Token.Square, if tree is
      Tree.Empty then Tree.Sequence(Nil)
      else tree
  makeBracketRule of
    Keywords._leftCurly
    Keywords._rightCurly
    "term"
    id
  makeBracketRule of
    Keywords._begin
    Keywords._end
    "term"
    (tree) => if tree is Tree.Empty then Tree.Sequence(Nil) else tree
  // We put the infix rules here for the railroad diagrams.
  Choice.Ref of
    "term"
    (lhs, compose) => compose(lhs)
    termInfixRule

// The rule for "{" <label-decl> { ";" <label-decl> } "}"
fun recordTypeChoice =
  let intro = "record type: "
  // <label-decl> ::= <ident> ":" <typexpr> { ";" <label-decl> } "}"
  fun labelDecls(tail) =
    Choice.typeExpr of ...
    (lhs, rhsAndMore) => if rhsAndMore is
      [rhs, Tree.Bracketed(_, Tree.Sequence(more))] then
        let labelDecl = Tree.Infix(TypeKeywords._colon, lhs, rhs)
        Tree.Bracketed(Token.Curly, Tree.Sequence(labelDecl :: more))
    intro + "name" // <ident>
    Choice.keyword of ...
    Keywords._colon // ":"
    intro + "colon"
    Choice.typeExpr of // "<typexpr>"
      (rhs, more) => [rhs, more]
      intro + "body"
      Choice.keyword of // "}"
        TypeKeywords._rightCurly
        intro + "right brace"
        Choice.end of Tree.Bracketed(Token.Curly, Tree.Sequence(Nil))
      tail // ";" <label-decl>
  // ";" <label-decl> { ";" <label-decl> } "}"
  fun makeLabelDeclsTail(get) = Choice.keyword of
    Keywords._semicolon
    intro + "more label-decls"
    labelDecls of Choice.Lazy(get, makeLabelDeclsTail)
  let labelDeclsTail = Choice.lazy of makeLabelDeclsTail
  Choice.keyword of // "{"
    Keywords._leftCurly
    intro + "left brace"
    labelDecls of labelDeclsTail

val typeInfixRule = rule of
  "infix rules for types"
  // Tuple (separated by commas)
  makeInfixChoice of TypeKeywords._comma, "type", (lhs, rhs) => if rhs is
    Tree.Tuple(tail) then Tree.Tuple(lhs :: tail)
    else Tree.Tuple(lhs :: rhs :: Nil)
  makeInfixChoice of TypeKeywords._arrow, "type", (lhs, rhs) =>
    Tree.Infix(TypeKeywords._arrow, lhs, rhs)
  makeInfixChoice of TypeKeywords._asterisk, "type", (lhs, rhs) =>
    Tree.Infix(TypeKeywords._asterisk, lhs, rhs)
  makeInfixChoice of TypeKeywords._of, "type", (lhs, rhs) =>
    Tree.Infix(TypeKeywords._of, lhs, rhs)

// Prefix rules and infix rules for types.
val typeRule = rule of
  "rules for types"
  recordTypeChoice
  // Choices for brackets
  makeBracketRule of TypeKeywords._leftRound, TypeKeywords._rightRound, "type", id
  Choice.Ref of
    "type"
    (lhs, compose) => compose(lhs)
    typeInfixRule

// TODO: rewrite with repetition choices.
fun typeDefinition() =
  let intro = "type definition: "
  fun typedefs(typedefsTail) =
    let variantIntro = "variant type: "
    fun variants(variantsTail, typedefsTail) =
      Choice.typeExpr of
        (currVariant, moreVariantsAndDefine) => if moreVariantsAndDefine is
          Tree.Define then
            [currVariant, moreVariantsAndDefine]
          [Tree.Empty, innerDefine] then [currVariant, innerDefine]
          [moreVariants, innerDefine] then tuple of
            Tree.Infix(TypeKeywords._bar, currVariant, moreVariants)
            innerDefine
        variantIntro + "variant"
        typedefsTail
        variantsTail
        Choice.end of [Tree.empty, Tree.Define(Tree.DefineKind.Type, Nil)]
    fun makeVariantsTail(get) = Choice.keyword of
      Keywords._bar
      variantIntro + "more variants"
      variants of Choice.Lazy(get, makeVariantsTail), typedefsTail
    let variantsTail = Choice.lazy of makeVariantsTail
    // - - - - -
    Choice.typeExpr of
      (head, bodyAndDefine) => if bodyAndDefine is
        [body, Tree.Define(kind, typedefs)] then
          Tree.Define(kind, [head, body] :: typedefs)
      intro + "name"
      Choice.keyword of
        Keywords._equal
        intro + "equal sign"
        variants(variantsTail, typedefsTail)
  fun makeTypedefsTail(get) = Choice.keyword of
    Keywords._and
    intro + "more typedefs"
    typedefs of Choice.Lazy(get, makeTypedefsTail)
  let typedefsTail = Choice.lazy of makeTypedefsTail
  Choice.keyword of
    Keywords._type
    intro + "`type` keyword"
    typedefs of typedefsTail

fun exceptionDefinition() =
  let intro = "exception definition: "
  Choice.keyword of
    Keywords._exception
    intro + "keyword"
    Choice.typeExpr of
      (name, body) => Tree.Define(Tree.DefineKind.Exception, [name, body] :: Nil)
      intro + "name"
      Choice.keyword of
        Keywords._equal
        intro + "equal sign"
        Choice.typeExpr of
          (body, _) => body
          intro + "body"
          Choice.end of ()
      Choice.end of Tree.empty

val declRule = rule of
  "prefix rules for module items"
  letDefinition
  typeDefinition()
  exceptionDefinition()

fun parse(tokens) =
  let
    current = tokens
    counter = 0
  
  fun yeetSpaces =
    while current is Token.Space :: tail do
      tracer.print of "skipped a space at " + counter
      set
        current = tail
        counter = counter + 1
    current
    
  fun consume =
    if current is head :: tail then
      tracer.print of "consumed `" + Token.summary(head) + "` at " + counter
      set current = tail
      set counter = counter + 1
    else
      tracer.print of "consumed: EOF"
  
  // Useful when consuming matched brackets.
  fun require(result: Tree, expected) = if yeetSpaces is
    actual :: _ and
      expected Token.same(actual) then
        consume
        result
      else result Tree.Error of mkStr of
        "Expected token "
        expected Token.summary()
        ", but found "
        actual Token.summary() 
    Nil then result Tree.Error of mkStr of
      "Expected token "
      expected Token.summary()
      ", but found end of input"
  
  fun parseRule(prec: Int, rule: ParseRule, allKeywords) = tracer.trace of
    "parsing rule \"" + rule.name + "\" with precedence " + prec
    result => "parsed: " + result Tree.summary()
    () => ...
    if yeetSpaces is
      Token.Identifier(name, _) :: _ and
        do tracer.print of "found an identifier \"" + name + "\"", source.line
        allKeywords.get(name) is Some(keyword) and
          do tracer.print of keyword.toString(), source.line
          do tracer.print of "keyword choices: ", rule.keywordChoices
            Iter.mapping of case [k, v] then "`" + k + "`"
            Iter.joined(", ")
          rule.keywordChoices.get(name) is
            Some(rest) then
              tracer.print of "found a rule starting with `" + name + "`", source.line
              tracer.print of "the rest of the rule: " + rest.display, source.line
              consume
              parseRule(0, rest, allKeywords)
            None and
              do tracer.print of "no rule starting with `" + name + "` was found", source.line
              do tracer.print of "the left prec of `" + name + "` is " + keyword.leftPrec, source.line
              rule.exprChoice is Some([kind, process, rest]) then
                tracer.print of "found an expression choice", source.line
                let acc = getParsingByKind(kind) of prec
                let tree = parseRule(prec, rest, allKeywords)
                process(acc, tree)
              do tracer.print of "no exprChoice or the prec is less than " + prec, source.line
              rule.endChoice is Some(value) then
                tracer.print of "found end choice", source.line
                value
              else
                consume
                Tree.error("unexpected keyword " + keyword.name)
        do tracer.print of "\"" + name + "\" is not a keyword", source.line
      other :: _ and
        rule.exprChoice is Some([kind, process, rest]) and
          do tracer.print of "parse \"" + kind + "\" kind from " + TokenHelpers.preview(current), source.line
          let acc = getParsingByKind(kind)(prec)
          acc Tree.nonEmptyError() then
            let tree = parseRule(prec, rest, allKeywords)
            tracer.print of "acc: " + acc Tree.summary(), source.line
            tracer.print of "tree: " + tree Tree.summary(), source.line
            process(acc, tree)
          do tracer.print of "fallback to end choice", source.line
        do tracer.print of "no expression choice", source.line
        rule.endChoice is Some(value) then
          tracer.print of "found end choice", source.line
          value
        do tracer.print of "no end choice", source.line
        else
          consume
          Tree.error("unexpected token " + other)
      Nil and rule.endChoice is
        Some(value) then value
        None then
          tracer.print of "no end choice but found the end of input", source.line
          Tree.error("unexpected end of input")
  
  // TODO: make kinds extensible
  fun getParsingByKind(kind: Str): Int -> Tree = if kind is
    "type" then typeExpr
    "term" then term
  
  fun term(prec: Int) = tracer.trace of
    "term <<< " + prec + " " + TokenHelpers.preview(current)
    result => "term >>> " + result Tree.summary()
    () => ...
    if yeetSpaces is
      Token.Identifier(name, symbolic) :: _ and Keywords.all.get(name) is
        Some(keyword) and termRule.keywordChoices.get(name) is
          Some(rule) and
            keyword.leftPrecOrMin > prec then
              consume
              let acc = parseRule(keyword.rightPrecOrMax, rule, Keywords.all)
              termCont(acc, prec)
            else
              tracer.print of "the left precedence is less" + name, source.line
              Tree.empty
          None then
            tracer.print("no rule starting with " + name, source.line)
            Tree.empty
        None then
          consume
          termCont(Tree.Ident(name, symbolic), prec)
      Token.Literal(kind, literal) :: _ then
        consume
        termCont(Tree.Literal(kind, literal), prec)
      token :: _ then Tree.error("unrecognized token: " + token)
      Nil then Tree.error("unexpected end of input")
  
  fun termCont(acc: Tree, prec: Int) = if yeetSpaces is
    do tracer.print(">>> termCont " + prec + " " + acc Tree.summary() + " <<<", source.line)
    // Look up the infix rules.
    Token.Identifier(name, _) :: _ and Keywords.all.get(name) is Some(keyword) and
      do tracer.print of "found a keyword: " + name, source.line
      // Note: we can also get the infix rules from `termRule.exprChoice` but
      // that just adds another pattern matching.
      termInfixRule.keywordChoices.get(name) is Some(rule) and
        do tracer.print of "the keyword is found in infix rules" + name, source.line
        keyword.leftPrecOrMin > prec and rule.exprChoice is
          Some([kind, process, rest]) then
            consume
            let rhs = getParsingByKind(kind) of keyword.rightPrecOrMin
            let acc' = process(rhs)(acc)
            termCont(acc', prec)
          None then acc
      do tracer.print of "keyword `" + name + "` does not have infix rules", source.line
    Token.Identifier(name, true) :: _ and Keywords.all.get(name) is None and
      do tracer.print of "found an operator \"" + name + "\"", source.line
      opPrec(name) is [leftPrec, rightPrec] and
        do tracer.print of "leftPrec = " + leftPrec + "; rightPrec = " + rightPrec, source.line
        leftPrec > prec then
          consume
          let op = Tree.Ident(name, true)
          let rhs = term(rightPrec)
          termCont(Tree.App(op, acc :: rhs :: Nil), prec)
        else
          acc
    token :: _ and
      Keywords.appPrec > prec then
        do tracer.print of "found an application", source.line
        if term(Keywords.appPrec) is
          Tree.Empty then acc
          Tree.Error then acc
          rhs then termCont(Tree.App(acc, rhs :: Nil), prec)
      else
        tracer.print of "cannot consume " + token, source.line
        acc
    Nil then acc
  
  fun typeExpr(prec: Int): Tree = tracer.trace of
    "typeExpr <<< " + prec + " " + TokenHelpers.preview(current)
    result => "typeExpr >>> " + result Tree.summary()
    () => ...
    if yeetSpaces is
      // * Type expressions that begin with a single bar are allowed.
      Token.Identifier("|", _) :: _ then
        consume
        typeExpr(prec)
      Token.TypeVariable(name) :: _ then
        consume
        // What's the corresponding tree of type variables?
        typeExprCont(Tree.Ident("'" + name), prec)
      Token.Identifier(name, symbolic) :: _ and TypeKeywords.all.get(name) is
        Some(keyword) and typeRule.keywordChoices.get(name) is
          Some(rule) and
            keyword.leftPrecOrMin > prec then
              consume
              let acc = parseRule(keyword.rightPrecOrMax, rule, TypeKeywords.all)
              typeExprCont(acc, prec)
            else
              tracer.print of "the left precedence is less" + name, source.line
              Tree.empty
          None then
            tracer.print("no rule starting with " + name, source.line)
            Tree.empty
        None and
          symbolic then
            consume
            Tree.error("unexpected symbolic identifier: " + name)
          else
            consume
            typeExprCont(Tree.Ident(name), prec)
      token :: _ then Tree.error("unrecognized token: " + token)
      else Tree.error("unexpected end of input")
  
  fun typeExprCont(acc: Tree, prec: Int) =
    tracer.print of ">>> typeExprCont " + prec + " " + acc Tree.summary() + " <<<", source.line
    if yeetSpaces is
      do tracer.print of "check keyword " + TokenHelpers.preview(current), source.line
      Token.Identifier(name, _) :: _ and TypeKeywords.all.get(name) is Some(keyword) and
        typeInfixRule.keywordChoices.get(name) is Some(rule) and
          do tracer.print of "the keyword is found in infix rules" + name, source.line
          keyword.leftPrecOrMin > prec and rule.exprChoice is
            Some([kind, process, rest]) then
              consume
              let rhs = getParsingByKind(kind) of keyword.rightPrecOrMin
              let acc' = process(rhs)(acc)
              typeExprCont(acc', prec)
            None then acc
          do tracer.print of "keyword `" + name + "` does not have infix rules", source.line
      // Token.Identifier(name, _) :: _ and TypeKeywords.all.get(name) is
      //   Some(keyword) and
      //     do tracer.print of "found a keyword " + name, source.line
      //     keyword.leftPrecOrMin > prec then
      //       consume
      //       let rhs = typeExpr(keyword.rightPrecOrMax)
      //       typeExprCont(Tree.Infix(keyword, acc, rhs), prec)
      //     else
      //       acc
      // * the case of type application
      do tracer.print of "not a keyword", source.line
      Token.Identifier(name, false) :: _ and
        TypeKeywords.appPrec > prec then
          do tracer.print of "found an application", source.line
          if typeExpr(TypeKeywords.appPrec) is
            Tree.Empty then acc
            Tree.Error then acc
            rhs then typeExprCont(Tree.App(rhs, acc :: Nil), prec)
      token :: _ then
        tracer.print of "cannot consume " + token, source.line
        acc
      Nil then acc
  
  fun mod(acc: Stack[Tree]) = if yeetSpaces is
    do tracer.print of ">>>>>> mod <<<<<<", source.line
    Token.Identifier(";;", _) :: _ then
      consume
      mod
    Token.Identifier(name, _) :: _ and
      Keywords.all.get(name) is Some(keyword) and
        termRule.keywordChoices.get(name) is Some(rule) then
          let tree = term(0)
          if tree is Tree.LetIn(bindings, Tree.Empty) then
            // If the body is empty, then this is a let-definition.
            modCont of Tree.Define(Tree.DefineKind.Let(false), bindings) :: acc
          else
            modCont of tree :: acc
        declRule.keywordChoices.get(name) is Some(rule) then
          consume
          let tree = parseRule(0, rule, Keywords.all)
          modCont(tree :: acc)
    _ :: _ then modCont of term(0, None) :: acc
    Nil then acc reverse()
  
  fun modCont(acc: Stack[Tree]) = if yeetSpaces is
    do tracer.print of ">>>>>> modCont <<<<<<", source.line
    Token.Identifier(";;", _) :: _ then
      consume
      acc mod()
    _ :: _ then modCont of parseRule(0, declRule, Keywords.all) :: acc
    Nil then acc reverse()
  
  let tree = tracer.trace of
    "module <<< "
    result => "module >>> " + result Tree.summary()
    () => mod(Nil)
  
  if yeetSpaces is
    token :: _ then
      let message = "expect EOF instead of " + token
      tracer.print of message, source.line
      tree Tree.Error(message)
    Nil then tree
