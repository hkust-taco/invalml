import "../Predef.mls"
import "../Option.mls"
import "../Stack.mls"
import "../BetterMap.mls"
import "../TreeTracer.mls"
import "../Iter.mls"
import "../apps/Lexer.mls"
import "./parsing/Token.mls"
import "./parsing/TokenHelpers.mls"
import "./parsing/Keyword.mls"
import "./parsing/Precedence.mls"
import "./parsing/Tree.mls"
import "./parsing/ParseRule.mls"

open Predef
open Option
open Stack
open BetterMap
open TreeTracer { TreeTracer }
open Token { LiteralKind, BracketKind }
open Precedence { Keywords, TypeKeywords, opPrec }
open Keyword { Keyword }
open ParseRule { ParseRule, Choice, rule }

type Opt[A] = Some[A] | None

module Parser with ...

val tracer = new TreeTracer

val syntaxKinds = new Map()

fun getRuleByKind(kind: Str) = syntaxKinds.get(kind) Option.unsafe.get()

fun defineKind(name: Str, ...choices) =
  syntaxKinds.insert of name, rule(name, ...choices)

defineKind of
  "let-bindings"
  Choice.term of ...
  (lhs, rhsBindings) => if rhsBindings is [rhs, bindings] then
    Tree.Infix(Keywords._equal, lhs, rhs) :: bindings
  "left-hand side"
  Choice.keyword of ...
  Keywords._equal
  "equal sign"
  Choice.term of ...
  (rhs, tail) => [rhs, tail]
  "right-hand side"
  Choice.end of Nil
  Choice.keyword of ...
  Keywords._and
  "separator"
  Choice.reference of ...
  "let-bindings"
  (tail, _) => tail
  "let-bindings tail"
  Choice.end of ()

fun letBinding(hasInClause: Bool) =
  let intro = "let binding: "
  Choice.keyword of
    Keywords._let
    intro + "keyword"
    Choice.Optional of
      rule of
        intro + "keyword"
        Choice.keyword of
          Keywords._rec
          intro + "`rec` keyword"
          Choice.end of ()
      rule of
        intro + "body"
        Choice.reference of
          "let-bindings"
          (bindings, body) => Tree.LetIn(bindings, body)
          "let-bindings"
          ...if hasInClause then tuple of
            Choice.keyword of
              Keywords._in
              intro + "`in` keyword"
              Choice.term of
                (body, _) => Some(body)
                intro + "body"
                Choice.end of ()
            Choice.end of None
          else
            tuple of Choice.end of None

let letExpression = letBinding(true)
let letDefinition = letBinding(false)

fun ifThenElse() =
  let intro = "if-then-else: "
  Choice.keyword of ...
  Keywords._if
  intro + "`if` keyword"
  Choice.term of ...
  (tst, conAlt) => if conAlt is [con, alt] then
    Tree.Ternary(Keywords._if, tst, con, alt)
  intro + "condition"
  Choice.keyword of ...
  Keywords._then
  intro + "`then` keyword"
  Choice.term of ...
  (con, optAlt) => [con, optAlt]
  intro + "consequent"
  Choice.end of None
  Choice.keyword of ...
  Keywords._else
  intro + "`else` keyword"
  Choice.term of ...
  (alt, _) => Some(alt)
  intro + "alternative"
  Choice.end of None

fun funTerm() =
  let intro = "function expression: "
  Choice.keyword of ...
  Keywords._fun
  intro + "keyword"
  Choice.term of ...
  (params, body) => Tree.Lambda(params :: Nil, body)
  intro + "parameters"
  Choice.keyword of ...
  Keywords._thinArrow
  intro + "arrow"
  Choice.term of ...
  (body, _) => body
  intro + "body"
  Choice.end of None

defineKind of
  "simple-matching"
  Choice.term of ...
  (lhs, rhsTail) => if rhsTail is [rhs, tail] then
    Tree.Infix(Keywords._thinArrow, lhs, rhs) :: tail
  "pattern"
  Choice.keyword of ...
  Keywords._thinArrow
  "arrow"
  Choice.term of ...
  (rhs, tail) => [rhs, tail]
  "rhs"
  Choice.end of Nil
  Choice.keyword of ...
  Keywords._bar
  "separator"
  Choice.reference of ...
  "simple-matching"
  (tail, _) => tail
  "simple-matching tail"
  Choice.end of ()

defineKind of
  "pattern-list"
  Choice.term of ...
  (head, tail) => head :: tail
  "pattern"
  Choice.reference of ...
  "pattern-list"
  (tail, _) => tail
  "pattern list tail"
  Choice.end of ()

defineKind of
  "multiple-matching"
  Choice.reference of ...
  "pattern-list"
  Tree.infix of Keywords._thinArrow
  "the list of pattern"
  Choice.keyword of ...
  Keywords._thinArrow
  "the arrow symbol"
  Choice.term of ...
  (rhs, _) => rhs
  "the right-hand side of the arrow"
  Choice.end of Nil
  Choice.keyword of ...
  Keywords._bar
  "separator"
  Choice.reference of ...
  "multiple-matching"
  (tail, _) => tail
  "multiple-matching tail"
  Choice.end of ()

fun matchTerm() =
  let intro = "`match` expression: "
  Choice.keyword of ...
  Keywords._match
  intro + "keyword"
  Choice.term of ...
  (scrutinee, branches) => Tree.Match(scrutinee, branches)
  intro + "scrutinee"
  Choice.keyword of ...
  Keywords._with
  intro + "with"
  Choice.Optional of
    rule of
      intro + "body"
      Choice.keyword of
        Keywords._bar
        intro + "leading bar"
        Choice.end of ()
    getRuleByKind("simple-matching")

fun functionTerm() =
  let intro = "`function` definition: "
  let body = Choice.Optional of
    rule of
      intro + "body"
      Choice.keyword of
        Keywords._bar
        intro + "leading bar"
        Choice.end of ()
    getRuleByKind("simple-matching")
  Choice.keyword of ...
  Keywords._function
  intro + "`function` keyword"
  body Choice.map(branches => Tree.Match(Tree.empty, branches))

let whileTerm = Choice.keyword of
  Keywords._while
  "while condition"
  Choice.term of ...
  Tree.While
  "while body"
  Choice.keyword of ...
  Keywords._do
  "while body"
  Choice.term of ...
  (body, _) => body
  "while end"
  Choice.keyword of ...
  Keywords._done
  "while end"
  Choice.end of ()

fun forTerm =
  let intro = "for: "
  let innerPart = Choice.term of
    (end, body) => [end, body]
    intro + "`do` keyword"
    Choice.keyword of
      Keywords._do
      intro + "body expression"
      Choice.term of
        (body, _) => body
        intro + "`done` keyword"
        Choice.keyword of
          Keywords._done
          "the end"
          Choice.end of ()
  Choice.keyword of
    Keywords._for
    intro + "left-hand side"
    Choice.term of
      (head, startEndBody) => if startEndBody is
        [start, end, body] then
          Tree.For(head, start, end, body)
      intro + "head"
      Choice.keyword of
        Keywords._equal
        intro + "start expression"
        Choice.term of
          (start, endBody) => if endBody is [end, body] then
            [start, end, body]
          intro + "`to` or `downto` keyword"
          Choice.keyword of
            Keywords._to
            "end expression"
            innerPart
          Choice.keyword of
            Keywords._downto
            "end expression"
            innerPart

fun makeInfixChoice(keyword: Keyword, rhsKind: Str, compose: (Tree, Tree) -> Tree) =
  Choice.keyword of ...
  keyword
  "operator `" + keyword.name + "`"
  Choice.reference of ...
  rhsKind
  (rhs, _) => lhs => compose(lhs, rhs)
  "operator `" + keyword.name + "` right-hand side"
  Choice.end of ()

val termInfixRule = rule of
  "infix rules for expressions"
  // Tuple (separated by commas)
  makeInfixChoice of Keywords._comma, "term", (lhs, rhs) => if rhs is
    Tree.Tuple(tail) then Tree.Tuple(lhs :: tail)
    else Tree.Tuple(lhs :: rhs :: Nil)
  // Sequence (separated by semicolons)
  makeInfixChoice of Keywords._semicolon, "term", (lhs, rhs) => if rhs is
    Tree.Sequence(tail) then Tree.Sequence(lhs :: tail)
    else Tree.Sequence(lhs :: rhs :: Nil)
  // Type ascription: <expr> ":" <typexpr>
  Choice.keyword of
    Keywords._colon
    "type ascription"
    Choice.typeExpr of
      (rhs, _) => lhs => Tree.Infix(Keywords._colon, lhs, rhs)
      "right-hand side type"
      Choice.end of ()
  // Application: <expr> <expr>
  Choice.Ref of
    "term"
    (argument, _) => callee => Tree.App(callee, argument)
    Some(Keywords.appPrec)
    None
    Choice.end of ()

fun makeBracketRule(opening, closing, contentKind, wrapContent) =
  // Pass the error message of closing bracket to the content.
  Choice.keyword of ...
  opening
  contentKind + ": bracket content"
  Choice.reference of ...
  contentKind
  (tree: Tree, end: Tree) => if end is
    Tree.Error(Tree.Empty, msg) then wrapContent(tree) Tree.Error(msg)
    Tree.Empty                  then wrapContent(tree)
  contentKind + ": close bracket"
  Choice.keyword of ...
  closing
  contentKind + ": the end of bracket"
  Choice.end of Tree.empty

// Prefix rules and infix rules for expressions.
val termRule = rule of
  "prefix rules for expressions"
  letExpression
  funTerm()
  matchTerm()
  functionTerm()
  ifThenElse()
  whileTerm
  forTerm
  // Choices for brackets
  makeBracketRule of
    Keywords._leftRound
    Keywords._rightRound
    "term"
    (tree) => if tree is Tree.Empty then Tree.Tuple(Nil) else tree
  makeBracketRule of
    Keywords._leftSquare
    Keywords._rightSquare
    "term"
    (tree) => Tree.Bracketed of Token.Square, if tree is
      Tree.Empty then Tree.Sequence(Nil)
      else tree
  makeBracketRule of
    Keywords._leftCurly
    Keywords._rightCurly
    "term"
    id
  makeBracketRule of
    Keywords._begin
    Keywords._end
    "term"
    (tree) => if tree is Tree.Empty then Tree.Sequence(Nil) else tree
  // We put the infix rules here for the railroad diagrams.
  Choice.Ref of
    "term"
    (lhs, compose) => compose(lhs)
    None
    None
    termInfixRule

fun recordTypeChoice =
  let intro = "record type: "
  Choice.keyword of ...
  Keywords._leftCurly
  intro + "left brace"
  Choice.reference of ...
  "label-decls"
  (content, _) => if content is
    Nil then Tree.Bracketed(Token.Curly, Tree.Sequence(Nil))
    else Tree.Bracketed(Token.Curly, Tree.Sequence(content))
  intro + "label-decl"
  Choice.keyword of ...
  Keywords._rightCurly
  intro + "right brace"
  Choice.end of Tree.empty

val typeInfixRule = rule of
  "infix rules for types"
  // Tuple (separated by commas)
  makeInfixChoice of TypeKeywords._comma, "type", (lhs, rhs) => if rhs is
    Tree.Tuple(tail) then Tree.Tuple(lhs :: tail)
    else Tree.Tuple(lhs :: rhs :: Nil)
  makeInfixChoice of TypeKeywords._arrow, "type", (lhs, rhs) =>
    Tree.Infix(TypeKeywords._arrow, lhs, rhs)
  makeInfixChoice of TypeKeywords._asterisk, "type", (lhs, rhs) =>
    Tree.Infix(TypeKeywords._asterisk, lhs, rhs)
  makeInfixChoice of TypeKeywords._of, "type", (lhs, rhs) =>
    Tree.Infix(TypeKeywords._of, lhs, rhs)

// Prefix rules and infix rules for types.
val typeRule = rule of
  "rules for types"
  // Choices for brackets
  makeBracketRule of TypeKeywords._leftRound, TypeKeywords._rightRound, "type", id
  Choice.Ref of
    "type"
    (lhs, compose) => compose(lhs)
    None
    None
    typeInfixRule

fun typeDefinition() =
  let intro = "type definition"
  Choice.keyword of ...
  Keywords._type
  intro + "type defs"
  Choice.reference of ...
  "typedefs"
  (typedefs, _) => Tree.Define(Tree.DefineKind.Type, typedefs)
  intro + "end"
  Choice.end of ()

fun variantsRule =
  let intro = "variant "
  Choice.typeExpr of ...
  (lhs, rhsMore) => if rhsMore is
    Some(rhs) then Tree.Infix(Keywords._bar, lhs, rhs)
    else lhs
  intro + "item"
  Choice.end of None
  Choice.keyword of ...
  Keywords._bar
  intro + "bar"
  Choice.reference of ...
  "variants"
  (more, _) => Some(more)
  intro + "end"
  Choice.end of ()

defineKind of "variants", variantsRule

fun typedefRule =
  let intro = "typedef "
  Choice.typeExpr of ...
  (lhs, rhsMore) => if rhsMore is [rhs, more] then [lhs, rhs] :: more
  intro + "name"
  Choice.keyword of ...
  Keywords._equal
  intro + "equal sign"
  Choice.reference of ...
  "typedef-rhs"
  (rhs, more) => [rhs, more]
  intro + "body"
  Choice.end of Nil
  Choice.keyword of ...
  Keywords._and
  intro + "and"
  Choice.reference of ...
  "typedefs"
  (more, _) => more
  intro + "end"
  Choice.end of ()

defineKind of "typedefs", typedefRule
  
defineKind of
  "typedef-rhs"
  Choice.reference of
    "variants"
    (rhs, _) => rhs
    "variants"
    Choice.end of Nil
  recordTypeChoice

fun labelDecl =
  let intro = "label-decl: "
  Choice.typeExpr of ...
  Tree.infix of TypeKeywords._colon
  intro + "name"
  Choice.keyword of ...
  TypeKeywords._colon
  intro + "colon"
  Choice.typeExpr of ...
  (rhs, _) => rhs
  intro + "body"
  Choice.end of ()

defineKind of "label-decl", labelDecl

fun labelDecls =
  let intro = "label-decls: "
  Choice.reference of ...
  "label-decl"
  Cons
  intro + "label-decl"
  Choice.end of Nil
  Choice.keyword of ...
  Keywords._semicolon
  intro + "semicolon"
  Choice.reference of ...
  "label-decls"
  (more, _) => more
  intro + "end"
  Choice.end of ()

defineKind of "label-decls", labelDecls

fun exceptionDefinition() =
  let intro = "exception definition: "
  Choice.keyword of ...
  Keywords._exception
  intro + "keyword"
  Choice.typeExpr of ...
  (name, body) => Tree.Define(Tree.DefineKind.Exception, [name, body] :: Nil)
  intro + "name"
  Choice.end of Tree.empty
  Choice.keyword of ...
  Keywords._equal
  intro + "equal sign"
  Choice.typeExpr of ...
  (body, _) => body
  intro + "body"
  Choice.end of ()

val declRule = rule of
  "prefix rules for module items"
  letDefinition
  typeDefinition()
  exceptionDefinition()

fun parse(tokens) =
  let
    current = tokens
    counter = 0
  
  fun yeetSpaces =
    while current is Token.Space :: tail do
      tracer.print of "skipped a space at " + counter
      set
        current = tail
        counter = counter + 1
    current
    
  fun consume =
    if current is head :: tail then
      tracer.print of "consumed `" + Token.summary(head) + "` at " + counter
      set current = tail
      set counter = counter + 1
    else
      tracer.print of "consumed: EOF"
  
  // Useful when consuming matched brackets.
  fun require(result: Tree, expected) = if yeetSpaces is
    actual :: _ and
      expected Token.same(actual) then
        consume
        result
      else result Tree.Error of mkStr of
        "Expected token "
        expected Token.summary()
        ", but found "
        actual Token.summary() 
    Nil then result Tree.Error of mkStr of
      "Expected token "
      expected Token.summary()
      ", but found end of input"
  
  fun parseKind(kind: Str, prec: Int): Tree = if
    kind is "type" then typeExpr(prec, TypeKeywords.all)
    kind is "term" then term(prec, Keywords.all)
    // * other kinds are rule-only and does not have operator-based parsing.
    syntaxKinds.get(kind) is Some(rule) then
      parseRule(prec, rule, Keywords.all)
    else
      throw Error("Unknown syntax kind: \"" + kind + "\"")
  
  fun parseRule(prec: Int, rule: ParseRule, allKeywords) = tracer.trace of
    "parsing rule \"" + rule.name + "\" with precedence " + prec
    result => "parsed rule \"" + rule.name + "\": " + result Tree.summary()
    () => ...
    if yeetSpaces is
      Token.Identifier(name, _) :: _ and
        do tracer.print of "found an identifier \"" + name + "\"", source.line
        allKeywords.get(name) is Some(keyword) and
          do tracer.print of keyword.toString(), source.line
          do tracer.print of "keyword choices: ", rule.keywordChoices
            Iter.mapping of case [k, v] then "`" + k + "`"
            Iter.joined(", ")
          rule.keywordChoices.get(name) is
            Some(rest) then
              tracer.print of "found a rule starting with `" + name + "`", source.line
              tracer.print of "the rest of the rule: " + rest.display, source.line
              consume
              parseRule(0, rest, allKeywords)
            None and
              do tracer.print of "no rule starting with `" + name + "` was found", source.line
              do tracer.print of "the left prec of `" + name + "` is " + keyword.leftPrec, source.line
              rule.exprChoice is Some([kind, process, outerPrec, innerPrec, rest]) then
                // TODO: use `outerPrec` and `innerPrec`
                tracer.print of "found an expression choice", source.line
                let acc = parseKind(kind, prec)
                let tree = parseRule(prec, rest, allKeywords)
                process(acc, tree)
              do tracer.print of "no exprChoice or the prec is less than " + prec, source.line
              rule.endChoice is Some(value) then
                tracer.print of "found end choice", source.line
                value
              else
                consume
                Tree.error("unexpected keyword " + keyword.name)
        do tracer.print of "\"" + name + "\" is not a keyword", source.line
      other :: _ and
        do tracer.print of "the current rule is " + rule.display
        rule.exprChoice is Some([kind, process, outerPrec, innerPrec, rest]) and
          // TODO: use `outerPrec` and `innerPrec`
          do tracer.print of "parse \"" + kind + "\" kind from " + TokenHelpers.preview(current), source.line
          let acc = parseKind(kind, prec)
          acc Tree.nonEmptyError() then
            tracer.print of "the rest rule: " + rest.display, source.line
            let tree = parseRule(prec, rest, allKeywords)
            tracer.print of "acc: " + acc Tree.summary(), source.line
            tracer.print of "tree: " + tree Tree.summary(), source.line
            tracer.print of "tree AST is: " + tree, source.line
            process(acc, tree)
          do tracer.print of "fallback to end choice", source.line
        do tracer.print of "no expression choice", source.line
        rule.endChoice is Some(value) then
          tracer.print of "found end choice", source.line
          value
        do tracer.print of "no end choice", source.line
        else
          consume
          Tree.error("unexpected token " + other)
      Nil and rule.endChoice is
        Some(value) then value
        None then
          tracer.print of "no end choice but found the end of input", source.line
          Tree.error("unexpected end of input")
  
  fun term(prec: Int) = tracer.trace of
    "term <<< " + prec + " " + TokenHelpers.preview(current)
    result => "term >>> " + result Tree.summary()
    () => ...
    if yeetSpaces is
      Token.Identifier(name, symbolic) :: _ and Keywords.all.get(name) is
        Some(keyword) and termRule.keywordChoices.get(name) is
          Some(rule) and
            keyword.leftPrecOrMin > prec then
              consume
              let acc = parseRule(keyword.rightPrecOrMax, rule, Keywords.all)
              termCont(acc, prec)
            else
              tracer.print of "the left precedence is less" + name, source.line
              Tree.empty
          None then
            tracer.print("no rule starting with " + name, source.line)
            Tree.empty
        None then
          consume
          termCont(Tree.Ident(name, symbolic), prec)
      Token.Literal(kind, literal) :: _ then
        consume
        termCont(Tree.Literal(kind, literal), prec)
      token :: _ then Tree.error("unrecognized token: " + token)
      Nil then Tree.error("unexpected end of input")
  
  fun termCont(acc: Tree, prec: Int) = if yeetSpaces is
    do tracer.print(">>> termCont " + prec + " " + acc Tree.summary() + " <<<", source.line)
    // Look up the infix rules.
    Token.Identifier(name, _) :: _ and Keywords.all.get(name) is Some(keyword) and
      do tracer.print of "found a keyword: " + name, source.line
      // Note: we can also get the infix rules from `termRule.exprChoice` but
      // that just adds another pattern matching.
      termInfixRule.keywordChoices.get(name) is Some(rule) and
        do tracer.print of "the keyword is found in infix rules" + name, source.line
        keyword.leftPrecOrMin > prec and rule.exprChoice is
          Some([kind, process, outerPrec, innerPrec, rest]) then
            // TODO: use `outerPrec` and `innerPrec`
            consume
            let rhs = parseKind(kind, keyword.rightPrecOrMin)
            let acc' = process(rhs, ())(acc)
            termCont(acc', prec)
          None then acc
      do tracer.print of "keyword `" + name + "` does not have infix rules", source.line
    Token.Identifier(name, true) :: _ and Keywords.all.get(name) is None and
      do tracer.print of "found an operator \"" + name + "\"", source.line
      opPrec(name) is [leftPrec, rightPrec] and
        do tracer.print of "leftPrec = " + leftPrec + "; rightPrec = " + rightPrec, source.line
        leftPrec > prec then
          consume
          let op = Tree.Ident(name, true)
          let rhs = term(rightPrec)
          termCont(Tree.App(op, acc :: rhs :: Nil), prec)
        else
          acc
    token :: _ and termInfixRule.exprChoice is
      Some([kind, process, outerPrec, innerPrec, rest]) and
        do tracer.print of "found an exprChoice with outerPrec = " + outerPrec, source.line
        let outerPrec' = outerPrec Option.getOrElse(Keywords.maxOperatorPrec)
        outerPrec' > prec and
          parseKind(kind, innerPrec Option.getOrElse(outerPrec')) is
            Tree.Empty then
              do tracer.print of "nothing was parsed", source.line
              acc
            rhs then
              do tracer.print of "parsed " + rhs Tree.summary(), source.line
              termCont(process(rhs, ())(acc), prec)
        do tracer.print of "the outer precedence is less than " + prec, source.line
        else acc
      None then
        tracer.print of "cannot consume " + token, source.line
        acc
    Nil then acc
  
  fun typeExpr(prec: Int): Tree = tracer.trace of
    "typeExpr <<< " + prec + " " + TokenHelpers.preview(current)
    result => "typeExpr >>> " + result Tree.summary()
    () => ...
    if yeetSpaces is
      // * Type expressions that begin with a single bar are allowed.
      Token.Identifier("|", _) :: _ then
        consume
        typeExpr(prec)
      Token.TypeVariable(name) :: _ then
        consume
        // What's the corresponding tree of type variables?
        typeExprCont(Tree.Ident("'" + name), prec)
      Token.Identifier(name, symbolic) :: _ and TypeKeywords.all.get(name) is
        Some(keyword) and typeRule.keywordChoices.get(name) is
          Some(rule) and
            keyword.leftPrecOrMin > prec then
              consume
              let acc = parseRule(keyword.rightPrecOrMax, rule, TypeKeywords.all)
              typeExprCont(acc, prec)
            else
              tracer.print of "the left precedence is less" + name, source.line
              Tree.empty
          None then
            tracer.print("no rule starting with " + name, source.line)
            Tree.empty
        None and
          symbolic then
            consume
            Tree.error("unexpected symbolic identifier: " + name)
          else
            consume
            typeExprCont(Tree.Ident(name), prec)
      token :: _ then Tree.error("unrecognized token: " + token)
      else Tree.error("unexpected end of input")
  
  fun typeExprCont(acc: Tree, prec: Int) =
    tracer.print of ">>> typeExprCont " + prec + " " + acc Tree.summary() + " <<<", source.line
    if yeetSpaces is
      do tracer.print of "check keyword " + TokenHelpers.preview(current), source.line
      Token.Identifier(name, _) :: _ and TypeKeywords.all.get(name) is Some(keyword) and
        typeInfixRule.keywordChoices.get(name) is Some(rule) and
          do tracer.print of "the keyword is found in infix rules" + name, source.line
          keyword.leftPrecOrMin > prec and rule.exprChoice is
            Some([kind, process, outerPrec, innerPrec, rest]) then
              // TODO: use `outerPrec` and `innerPrec`
              consume
              let rhs = parseKind(kind, keyword.rightPrecOrMin)
              let acc' = process(rhs)(acc)
              typeExprCont(acc', prec)
            None then acc
          do tracer.print of "keyword `" + name + "` does not have infix rules", source.line
      // Token.Identifier(name, _) :: _ and TypeKeywords.all.get(name) is
      //   Some(keyword) and
      //     do tracer.print of "found a keyword " + name, source.line
      //     keyword.leftPrecOrMin > prec then
      //       consume
      //       let rhs = typeExpr(keyword.rightPrecOrMax)
      //       typeExprCont(Tree.Infix(keyword, acc, rhs), prec)
      //     else
      //       acc
      // * the case of type application
      do tracer.print of "not a keyword", source.line
      Token.Identifier(name, false) :: _ and
        TypeKeywords.appPrec > prec then
          do tracer.print of "found an application", source.line
          if typeExpr(TypeKeywords.appPrec) is
            Tree.Empty then acc
            Tree.Error then acc
            rhs then typeExprCont(Tree.App(rhs, acc :: Nil), prec)
      token :: _ then
        tracer.print of "cannot consume " + token, source.line
        acc
      Nil then acc
  
  fun mod(acc: Stack[Tree]) = if yeetSpaces is
    do tracer.print of ">>>>>> mod <<<<<<", source.line
    Token.Identifier(";;", _) :: _ then
      consume
      mod
    Token.Identifier(name, _) :: _ and
      Keywords.all.get(name) is Some(keyword) and
        termRule.keywordChoices.get(name) is Some(rule) then
          let tree = term(0)
          if tree is Tree.LetIn(bindings, Tree.Empty) then
            // If the body is empty, then this is a let-definition.
            modCont of Tree.Define(Tree.DefineKind.Let(false), bindings) :: acc
          else
            modCont of tree :: acc
        declRule.keywordChoices.get(name) is Some(rule) then
          consume
          let tree = parseRule(0, rule, Keywords.all)
          modCont(tree :: acc)
    _ :: _ then modCont of term(0, None) :: acc
    Nil then acc reverse()
  
  fun modCont(acc: Stack[Tree]) = if yeetSpaces is
    do tracer.print of ">>>>>> modCont <<<<<<", source.line
    Token.Identifier(";;", _) :: _ then
      consume
      acc mod()
    _ :: _ then modCont of parseRule(0, declRule, Keywords.all) :: acc
    Nil then acc reverse()
  
  let tree = tracer.trace of
    "module <<< "
    result => "module >>> " + result Tree.summary()
    () => mod(Nil)
  
  if yeetSpaces is
    token :: _ then
      let message = "expect EOF instead of " + token
      tracer.print of message, source.line
      tree Tree.Error(message)
    Nil then tree
