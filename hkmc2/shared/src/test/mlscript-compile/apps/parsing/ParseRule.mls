import "../../BetterMap.mls"
import "../../Iter.mls"
import "../../Option.mls"
import "../../Stack.mls"
import "./Token.mls"
import "./Keyword.mls"
import "./Tree.mls"

open BetterMap { Map, toMap }
open Option { Some, None }
open Stack

module ParseRule with ...

//  ____                     ____        _
// |  _ \ __ _ _ __ ___  ___|  _ \ _   _| | ___
// | |_) / _` | '__/ __|/ _ \ |_) | | | | |/ _ \
// |  __/ (_| | |  \__ \  __/  _ <| |_| | |  __/
// |_|   \__,_|_|  |___/\___|_| \_\\__,_|_|\___|
//
// =============================================

class ParseRule(val name: Str, val choices: Stack[Choice]) with
  
  // Append a rule to the end of all choices in this rule.
  fun andThen(rest: ParseRule) = ParseRule of
    name
    choices
      Iter.fromStack()
      Iter.mapping of case
        Choice.Keyword(keyword, rest') then [Choice.Keyword(keyword, rest'.andThen(rest))]
        Choice.Expr(process, rest') then [Choice.Expr(process, rest'.andThen(rest))]
        Choice.End then rest.choices Iter.fromStack()
        Choice.Optional(rule, rest') then [Choice.Optional(process, rule, rest'.andThen(rest))]
        Choice.Lazy(get, make) then
          let get' = () => get() andThen(rest)
          let make' = getChoice => make(() => getChoice andThen(rest))
          [Choice.Lazy(get', make')]
      Iter.flattening()
      Iter.toStack()
  
  // Collect the first end choice in this rule.
  fun endChoice = choices
    Iter.fromStack()
    Iter.firstDefined of choice =>
      if choice Choice.forced() is
        Choice.End(value) then Some(value)
        Choice.Optional(_, rest) then rest.endChoice
        else None
  
  // Manual memoization for keyword choices.
  let _keywordChoices = None
  
  // Collect all keyword choices in this rule.
  fun keywordChoices = if _keywordChoices is
    None then
      let computed = toMap of choices
        Iter.fromStack()
        Iter.mapping of choice => if choice Choice.forced() is
          Choice.Keyword(keyword, rest) then [[keyword.name, rest]]
          Choice.Optional(rule, rest) then rule.keywordChoices
            Iter.mapping of case [keyword, rule] then
              [keyword, rule.andThen(rest)]
            Iter.appended of rest.keywordChoices
            Iter.toArray()
          else []
        Iter.flattening()
        Iter.toArray()
      set _keywordChoices = Some(computed)
      computed
    Some(cache) then cache
  
  fun exprChoice = choices
    Iter.fromStack()
    Iter.firstDefined of choice => if choice Choice.forced() is
      Choice.Expr(process, rest) then Some([process, rest])
      Choice.Optional(rule, rest) and
        rule.exprChoice is Some([process, rest']) then
          Some([process, rest'.andThen(rest)])
        else rest.exprChoice
      else None
  
  // Display parse rules as a tree in a BNF-like format.
  fun display =
    object Knot
    fun displayChoice(choice) = if choice is
      Choice.Keyword(keyword, rest) and
        let prefix = "`" + keyword.name + "` "
        go(rest) is
          [name, [line]] then [prefix + line]
          [name, [head, ..tail']] then [prefix + head, ..tail']
      Choice.Expr(_, rest) and
        let prefix = "<expression> "
        go(rest) is
          [name, [line]] then [prefix + line]
          [name, lines] then [prefix, ..lines.map((line, _, _) => "  " + line)]
      Choice.Optional(rule, rest) then
        let prefix = "[" + (if go(rule) is
          [name, [line]] then line
          [name, lines] then lines.map((line, _, _) => "  " + line)) + "] "
        if go(rest) is
          [name, [line]] then [prefix + line]
          [name, lines] then [prefix, ..lines.map((line, _, _) => "  " + line)]
      Choice.End then [""]
      Choice.Lazy(get, make) and
        get() is Knot then ["<rec>"]
        else displayChoice(make(() => Knot))
      other then ["<unknown>" + JSON.stringify(other)]
    fun go(rule) =
      let
        choices = rule.choices
        lines = []
      while choices is head :: tail do
        lines.push of displayChoice(head)
        set choices = tail
      [rule.name, lines.flat()]
    if go(this) is [name, lines] then
      "<" + name + "> ::= " + if lines is
        [line] then line
        [head, ..tail] then head + "\n" + tail.join("\n")

// Shorthands for constructing parse rules.
fun rule(name, ...choices) = ParseRule(name, choices Iter.toStack())

module Choice with
  class Keyword(keyword: Keyword, rest: ParseRule)
  class Expr(process: Tree -> Tree, rest: ParseRule)
  class Type(process: Tree -> Tree, rest: ParseRule)
  class Terminal(process: (Token, Tree) -> Tree, token: Token, rest: ParseRule)
  class End(value: Tree)
  class Optional(rule: ParseRule, rest: ParseRule)
  class Lazy(get: () -> Choice, make: (() -> Choice) -> Choice)
  
  fun forced(choice) = if choice is Lazy(get) then get() else choice
  // Shorthands for constructing rule choices.
  fun keyword(keyword, name, ...choices) = Keyword(keyword, rule(name, ...choices))
  fun expr(process, name, ...choices) = Expr(process, rule(name, ...choices))
  fun terminal(process, token, name, ...choices) = Terminal(process, token, rule(name, ...choices))
  fun token(token, name, ...choices) = terminal((_, tree) => tree, token, name, ...choices)
  fun end(value) = End(value)
  fun lazy(makeChoice) =
    let cache = None
    fun getChoice() =
      if cache is Some(choice) then choice else ...
      set cache = makeChoice(getChoice)
      cache
    Lazy(getChoice, makeChoice)
