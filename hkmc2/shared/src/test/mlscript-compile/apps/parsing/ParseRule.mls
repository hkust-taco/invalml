import "../../BetterMap.mls"
import "../../Iter.mls"
import "../../Option.mls"
import "../../Stack.mls"
import "../../Predef.mls"
import "./Keyword.mls"
import "./Token.mls"
import "./Tree.mls"

open BetterMap { Map, toMap }
open Option { Some, None }
open Predef { assert, tuple }
open Stack

type Opt[A] = Some[A] | None

module ParseRule with ...

data class Lazy[out A](init: () -> A) with
  mut val cached: Opt[A] = None
  fun reset() = set cached = None
  fun get() = if cached is
    Some(v) then v
    else
      let v = init()
      set cached = Some(v)
      v

//  ____                     ____        _
// |  _ \ __ _ _ __ ___  ___|  _ \ _   _| | ___
// | |_) / _` | '__/ __|/ _ \ |_) | | | | |/ _ \
// |  __/ (_| | |  \__ \  __/  _ <| |_| | |  __/
// |_|   \__,_|_|  |___/\___|_| \_\\__,_|_|\___|
//
// =============================================

data class ParseRule[A](name: Str, choices: Stack[Choice[A]]) with
  
  fun map[B](op: A -> B) =
    ParseRule of
      name
      choices
        Iter.fromStack()
        Iter.mapping of choice => choice Choice.map(op)
        Iter.toStack()
  
  fun andThen[B, C](rest: ParseRule[B], process: (A, B) -> C) =
    fun go(rule: ParseRule) = ParseRule of
      rule.name
      rule.choices
        Iter.fromStack()
        Iter.mapping of case
          Choice.Keyword(keyword, rest') then tuple of
            Choice.Keyword(keyword, go(rest'))
          Choice.Ref(isType, process, outerPrec, innerPrec, rest') then
            let process' = (lhs, rhs) => if
              rhs is [rhs, innerResult] then
                [process(lhs, rhs), innerResult]
              do assert(false, "illgeal result from inner")
            tuple of
              Choice.Ref(isType, process', outerPrec, innerPrec, go(rest'))
          Choice.End(value) then
            rest.choices
              Iter.fromStack()
              Iter.mapping of choice => choice Choice.map(result => [value, result])
          Choice.Siding(rule, optional, rest', process) then
            let process' = (initRes, restRes) => if
              restRes is [restRes', innerRes] then [process(initRes, restRes'), innerRes]
              do assert(false, "illegal result from inner")
            [Choice.Siding(rule, optional, go(rest'), process')]
        Iter.flattening()
        Iter.toStack()
    go(this).map of res => process(res.0, res.1)
  
  let _endChoice = Lazy of () => choices
    Iter.fromStack()
    Iter.firstDefined of case
      Choice.End(value) then Some(value)
      Choice.Siding(init, optional, rest, process) and
        optional then
           // It's actually ambiguous here.
          rest.endChoice.map of restRes =>
            process(None, restRes)
        init.endChoice is Some(initRes) and
          rest.endChoice is Some(restRes) then
            process(Some(initRes), restRes)
      else None
  
  // Collect the first end choice in this rule.
  fun endChoice = _endChoice.get()
  
  let _keywordChoices = Lazy of () => choices
    Iter.fromStack()
    Iter.mapping of case
      Choice.Keyword(keyword, rest) then [[keyword.name, rest]]
      Choice.Siding(init, optional, rest, process) then init.keywordChoices
        Iter.mapping of case [keyword, rule] then
          [keyword, rule.map(Some).andThen(rest, process)]
        Iter.appended of
          if optional then rest.keywordChoices
            Iter.mapping of case [keyword, rule] then
              [keyword, rule.map(res => process(None, res))]
          else []
        Iter.toArray()
      else []
    Iter.flattening()
    Iter.toArray()
    toMap()
  
  // Collect all keyword choices in this rule.
  fun keywordChoices = _keywordChoices.get()
  
  let _exprChoice = Lazy of () => choices
    Iter.fromStack()
    Iter.firstDefined of case
      Choice.Ref(kind, process, outerPrec, innerPrec, rest) then
        Some([kind, process, outerPrec, innerPrec, rest])
      Choice.Siding(init, optional, rest, process) and
        init.exprChoice is
          Some([k, process', op, ip, rest']) then
            let process''(exprRes, pairRes) = if pairRes is [restRes', restRes] then
              process(process'(exprRes, restRes'), restRes)
            let rest'' = rest'.andThen(rest, tuple)
            Some of [k, process'', op, ip, rest'']
        optional and rest.exprChoice is
          Some([k, p, op, ip, rest']) then Some of tuple of
            k, (exprRes, restRes) => process(None, p(exprRes, restRes)), op, ip, rest'
        else None
      else None
  
  fun exprChoice = _exprChoice.get()
  
  fun extendChoices(newChoices: Stack[Choice]) =
    set choices = choices ::: newChoices
    _endChoice.reset()
    _keywordChoices.reset()
    _exprChoice.reset()
  
  // Display parse rules as a tree in a BNF-like format.
  fun display =
    /// Display a single `Choice`.
    fun displayChoice(choice: Choice) = if choice is
      Choice.Keyword(keyword, rest) then
        "\"" + keyword.name + "\"" + tail(rest).1
      Choice.Ref(kind, _, _, _, rest) then
        "<" + kind + ">" + tail(rest).1
      Choice.Siding(init, opt, rest, _) then
        let init' = go(init, false).1
        (if opt then "[" + init' + "]" else "(" + init' + ")") + tail(rest).1
      Choice.End then ""
      other then "<unknown:" + other + ">"
    
    // Display the remaining list of choices.
    fun tail(rest) = if rest is ParseRule(_, choices) and
      choices is Choice.End :: Nil then ["", ""]
      go(rest, false) is [name, line] and
        choices is _ :: _ :: _ and
          choices Iter.fromStack() Iter.some(c => c is Choice.End) then
            [name, " [" + line + "]"]
          else [name, " (" + line + ")"]
        else [name, " " + line]
    
    fun go(rule, top) =
      let lines = rule.choices
        Iter.fromStack()
        Iter.filtering of case
          Choice.End then false
          else true
        Iter.mapping of displayChoice
        Iter.toArray()
      tuple of
        rule.name
        if
          lines is [] then "Îµ"
          lines is [line] then line
          top then "\n  | " + lines.join("\n  | ")
          else lines.join(" | ")
    
    if go(this, true) is [name, line] then "<" + name + "> ::= " + line

// Shorthands for constructing parse rules.
// Automatically adds an end choice to the rule if no choices are provided.
fun rule(name, ...choices) = ParseRule of
  name
  if choices.length == 0 then
    Choice.end(()) :: Nil
  else
    choices Iter.toStack()

module Choice with
  abstract class Choice[A]
  
  data class Keyword[A](keyword: Keyword, rest: ParseRule[A]) extends Choice[A]
  
  data class Ref[A, B](
      kind: Str,
      process: (Tree, B) -> A,
      outerPrec: Opt[Int],
      innerPrec: Opt[Int],
      rest: ParseRule[B]
  ) extends Choice[A]
  
  data class End[A](value: A) extends Choice[A]
  
  // * An alternative route that branches off from the main railroad and
  // * eventually connects back to the main railroad. For example, `foo`, `bar`,
  // * and `baz` are choices represented by `init`. If `optional` is set to
  // * `true`, an additional empty choice is added to `rule`, making it possible
  // * to skip the entire `rule`.
  // *                     _______ foo ______
  // *                    /                  \
  // *                   /-------- bar -------\
  // *                  /                      \
  // * ----- start ----+---------- baz ---------+--- end ---------
  data class Siding[A, B, C](
      init: ParseRule[B],
      optional: Bool,
      rest: ParseRule[C],
      process: (Opt[B], C) -> A
  ) extends Choice[A]
  
  let ensureChoices(xs, name) = xs
    Iter.zippingWithIndex()
    Iter.each of case [item, index] then
      assert(item is Choice, name + ": element [" + index + "] is not Choice")
  
  // Shorthands for constructing rule choices.
  fun keyword(keyword)(...choices) =
    ensureChoices(choices, "Choice.keyword")
    Keyword(keyword, rule("`" + keyword.name + "` keyword", ...choices))
  
  fun reference(kind)(process, name, ...choices) =
    assert(kind is Str, "Choice.reference: kind is not a string")
    assert(typeof(process) === "function", "Choice.reference: process is not a function")
    assert(name is Str, "Choice.reference: name is not a string")
    ensureChoices(choices, "Choice.reference")
    Ref(kind, process, None, None, rule(name, ...choices))
  
  fun term(process, name, ...choices) =
    assert(typeof(process) === "function", "Choice.term: process is not a function")
    assert(name is Str, "Choice.term: name is not a string")
    ensureChoices(choices, "Choice.term")
    Ref("term", process, None, None, rule(name, ...choices))
  
  fun termWithPrec(process, name, outerPrec, innerPrec, ...choices) =
    assert(typeof(process) === "function", "Choice.termWithPrec: process is not a function")
    assert(name is Str, "Choice.termWithPrec: name is not a string")
    ensureChoices(choices, "Choice.termWithPrec")
    Ref("term", process, outerPrec, innerPrec, rule(name, ...choices))
  
  fun typeExpr(process, name, ...choices) =
    assert(typeof(process) === "function", "Choice.typeExpr: process is not a function")
    assert(name is Str, "Choice.typeExpr: name is not a string")
    ensureChoices(choices, "Choice.typeExpr")
    Ref("type", process, None, None, rule(name, ...choices))
  
  fun optional(init, rest) =
    assert(init is ParseRule, "Choice.optional: init is not ParseRule")
    assert(rest is ParseRule, "Choice.optional: rest is not ParseRule")
    Siding(init, true, rest, tuple)
  
  fun siding(init, rest) =
    assert(init is ParseRule, "Choice.siding: init is not ParseRule")
    assert(rest is ParseRule, "Choice.siding: rest is not ParseRule")
    Siding of init, false, rest, (initRes, restRes) =>
      if initRes is Some(initRes) then [initRes, restRes]
  
  fun end(value) = End(value)
  
  fun map[A, B](choice: Choice[A], op: A -> B): Choice[B] = if choice is
    Keyword(keyword, rest) then Keyword(keyword, rest.map(op))
    Ref(kind, process, outerPrec, innerPrec, rest) then
      Ref(kind, (x, y) => op(process(x, y)), outerPrec, innerPrec, rest)
    Siding(init, optional, rest, process) then
      Siding(init, optional, rest, (x, y) => op(process(x, y)))
    End(value) then End(op(value))
