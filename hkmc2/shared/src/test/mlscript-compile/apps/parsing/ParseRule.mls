import "../../BetterMap.mls"
import "../../Iter.mls"
import "../../Option.mls"
import "../../Stack.mls"
import "./Token.mls"
import "./Keyword.mls"
import "./Tree.mls"

open BetterMap { Map, toMap }
open Option { Some, None }
open Stack

type Opt[A] = Some[A] | None

module ParseRule with ...

//  ____                     ____        _
// |  _ \ __ _ _ __ ___  ___|  _ \ _   _| | ___
// | |_) / _` | '__/ __|/ _ \ |_) | | | | |/ _ \
// |  __/ (_| | |  \__ \  __/  _ <| |_| | |  __/
// |_|   \__,_|_|  |___/\___|_| \_\\__,_|_|\___|
//
// =============================================

class ParseRule(val name: Str, val choices: Stack[Choice]) with
  
  fun map(op: Tree -> Tree) =
    ParseRule of
      name
      choices
        Iter.fromStack()
        Iter.mapping of choice => choice Choice.map(op)
        Iter.toStack()
  
  // Append a rule to the end of all choices in this rule.
  fun andThen(rest: ParseRule) = ParseRule of
    name
    choices
      Iter.fromStack()
      Iter.mapping of case
        Choice.Keyword(keyword, rest') then [Choice.Keyword(keyword, rest'.andThen(rest))]
        Choice.Ref(isType, process, outerPrec, innerPrec, rest') then
          [Choice.Ref(isType, process, outerPrec, innerPrec, rest'.andThen(rest))]
        Choice.End then rest.choices Iter.fromStack()
        Choice.Optional(rule, rest') then [Choice.Optional(process, rule, rest'.andThen(rest))]
        Choice.Lazy(get, make) then
          let get' = () => get() andThen(rest)
          let make' = getChoice => make(() => getChoice andThen(rest))
          [Choice.Lazy(get', make')]
      Iter.flattening()
      Iter.toStack()
  
  let _endChoice = None
  
  let _computeEndChoice = () => choices
    Iter.fromStack()
    Iter.firstDefined of choice =>
      if choice Choice.forced() is
        Choice.End(value) then Some(value)
        Choice.Optional(_, rest) then rest.endChoice
        else None
  
  // Collect the first end choice in this rule.
  fun endChoice = if _endChoice is
    None then
      let computed = _computeEndChoice()
      set _endChoice = Some(computed)
      computed
    Some(cache) then cache
  
  // Manual memoization for keyword choices.
  let _keywordChoices = None
  
  let _computeKeywordsChoices = () =>
    toMap of choices
      Iter.fromStack()
      Iter.mapping of choice => if choice Choice.forced() is
        Choice.Keyword(keyword, rest) then [[keyword.name, rest]]
        Choice.Optional(rule, rest) then rule.keywordChoices
          Iter.mapping of case [keyword, rule] then
            [keyword, rule.andThen(rest)]
          Iter.appended of rest.keywordChoices
          Iter.toArray()
        else []
      Iter.flattening()
      Iter.toArray()
  
  // Collect all keyword choices in this rule.
  fun keywordChoices = if _keywordChoices is
    None then
      let computed = _computeKeywordsChoices()
      set _keywordChoices = Some(computed)
      computed
    Some(cache) then cache
  
  let _exprChoice = None
  
  let _computeExprChoice = () => choices
    Iter.fromStack()
    Iter.firstDefined of choice => if choice Choice.forced() is
      Choice.Ref(isType, process, outerPrec, innerPrec, rest) then
        Some([isType, process, outerPrec, innerPrec, rest])
      Choice.Optional(rule, rest) and
        rule.exprChoice is Some([kind, process, outerPrec, innerPrec, rest']) then
          Some([kind, process, outerPrec, innerPrec rest'.andThen(rest)])
        else rest.exprChoice
      else None
  
  fun exprChoice = if _exprChoice is
    None then
      let computed = _computeExprChoice()
      set _exprChoice = Some(computed)
      computed
    Some(cache) then cache
  
  // Display parse rules as a tree in a BNF-like format.
  fun display =
    object Knot
    fun displayChoice(choice) = if choice is
      Choice.Keyword(keyword, rest) and
        let prefix = "`" + keyword.name + "` "
        go(rest) is
          [name, [line]] then [prefix + line]
          [name, [head, ..tail']] then [prefix + head, ..tail']
      Choice.Ident(_, rest) and
        let prefix = "<ident> "
        go(rest) is
          [name, [line]] then [prefix + line]
          [name, [head, ..tail']] then [prefix + head, ..tail']
      Choice.Ref(kind, _, _, _, rest) and
        let prefix = "<" + kind + ">"
        go(rest) is
          [name, [line]] then [prefix + line]
          [name, lines] then [prefix, ..lines.map((line, _, _) => "  " + line)]
      Choice.Optional(rule, rest) then
        let prefix = "[" + (if go(rule) is
          [name, [line]] then line
          [name, lines] then lines.map((line, _, _) => "  " + line)) + "] "
        if go(rest) is
          [name, [line]] then [prefix + line]
          [name, lines] then [prefix, ..lines.map((line, _, _) => "  " + line)]
      Choice.End then [""]
      Choice.Lazy(get, make) and
        get() is Knot then ["<rec>"]
        else displayChoice(make(() => Knot))
      other then ["<unknown>" + JSON.stringify(other)]
    fun go(rule) =
      let
        choices = rule.choices
        lines = []
      while choices is head :: tail do
        lines.push of displayChoice(head)
        set choices = tail
      [rule.name, lines.flat()]
    if go(this) is [name, lines] then
      "<" + name + "> ::= " + if lines is
        [line] then line
        [head, ..tail] then head + "\n" + tail.join("\n")

// Shorthands for constructing parse rules.
// Automatically adds an end choice to the rule if no choices are provided.
fun rule(name, ...choices) = ParseRule of
  name
  if choices.length == 0 then
    Choice.end(()) :: Nil
  else
    choices Iter.toStack()

module Choice with
  class Keyword(keyword: Keyword, rest: ParseRule)
  class Ident(process: Token.Identifier -> Tree, rest: ParseRule)
  class Ref(kind: Str, process: Tree -> Tree, outerPrec: Opt[Int], innerPrec: Opt[Int], rest: ParseRule)
  class End(value: Tree)
  class Optional(rule: ParseRule, rest: ParseRule)
  class Lazy(get: () -> Choice, make: (() -> Choice) -> Choice)
  
  fun rest(choice) = if choice is
    Lazy(get, _) then get() rest()
    Keyword(_, rest) then Some(rest)
    Ident(_, rest) then Some(rest)
    Ref(_, _, _, _, rest) then Some(rest)
    Optional(_, rest) then Some(rest)
    End then None
  
  fun forced(choice) = if choice is Lazy(get, _) then get() else choice
  // Shorthands for constructing rule choices.
  fun keyword(keyword, ...choices) =
    Keyword(keyword, rule("`" + keyword.name + "` keyword", ...choices))
  fun reference(kind, process, name, ...choices) =
    Ref(kind, process, None, None, rule(name, ...choices))
  fun term(process, name, ...choices) =
    Ref("term", process, None, None, rule(name, ...choices))
  fun termWithPrec(process, name, outerPrec, innerPrec, ...choices) =
    Ref("term", process, outerPrec, innerPrec, rule(name, ...choices))
  fun typeExpr(process, name, ...choices) =
    Ref("type", process, None, None, rule(name, ...choices))
  fun end(value) = End(value)
  fun lazy(makeChoice) =
    let cache = None
    fun getChoice() =
      if cache is Some(choice) then choice else ...
      set cache = makeChoice(getChoice)
      cache
    Lazy(getChoice, makeChoice)
  
  fun map(choice: Choice, op: Tree -> Tree) = if choice is
    Keyword(keyword, rest) then Keyword(keyword, rest.map(op))
    Ident(process, rest) then
      Ident((tok, tree) => op(process(tok, tree)), rest.map(op))
    Ref(kind, process, outerPrec, innerPrec, rest) then
      Ref(kind, (x, y) => op(process(x, y)), outerPrec, innerPrec, rest)
    Optional(rule, rest) then Optional(rule.map(op), rest.map(op))
    End(value) then End(op(value))
