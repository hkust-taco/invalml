import "../Parser.mls"
import "./ParseRule.mls"
import "../../Predef.mls"
import "../../Stack.mls"
import "../../Option.mls"
import "../../TreeTracer.mls"
import "../../XML.mls"
import "path"
import "../../../vendors/railroad/railroad.mjs"

open Predef
open Stack
open Option
open Parser { prefixRules }
open ParseRule { ParseRule, Choice }
open TreeTracer
open XML { html, tag, elem, style }

object RecursiveKnot

class LinkOpts(val href: Str)

module ParseRuleVisualizer with ...

val rr = railroad

// Check if the given path exists.
fun ensurePath(pathString) =
  if fs.statSync(pathString).isDirectory() is false do
    throw new Error("The output directory does not exist.")
  pathString

// `process.cwd()` is different in `hkmc2AllTests / test` and
// `~hkmc2DiffTests / Test / run`. This is a workaround to make the path.
fun findProjectRoot =
  let base = process.cwd()
  let fragments = base.split(path.sep)
  if fragments.at(-1) is "shared" and fragments.at(-2) is "hkmc2" then
    base
  else
    base + path.sep + "hkmc2" + path.sep + "shared"

fun outputPath = ensurePath of path.resolve of
  findProjectRoot, "src", "test", "mlscript", "apps", "output"

fun libraryPath = ensurePath of path.resolve of
  findProjectRoot, "src", "test", "vendors", "railroad"

val CSS_CONTENT = fs.readFileSync of path.join(libraryPath, "railroad.css"), "utf-8"

fun toHTML(...elements) = html(["lang", "en"]) of
  elem("head") of
    tag("meta") of ["charset", "UTF-8"]
    tag("meta") of
      ["name", "viewport"]
      ["content", "width=device-width, initial-scale=1.0"]
    elem("title") of "Parse Rules"
  elem("body", style of
    ["margin", "0"]
    ["padding", "1em"]
  ) of
    elem("div", style of
      ["display", "flex"]
      ["flex-direction", "column"]
      ["gap", "1em"]
    ) of
      ...elements
    elem("style") of
      "body{margin:0;font-family:system-ui,sans-serif}"
      CSS_CONTENT

fun save(fileName, ...diagrams) = fs.writeFileSync of
  path.join of outputPath, fileName
  toHTML of ...diagrams.flatMap of case
    [caption, svg] then elem("figure", style(["text-align", "center"])) of
      svg
      elem("figcaption", ["id", caption]) of caption
    svg then svg
  "utf-8"

let tracer = new TreeTracer()

fun render(rule: ParseRule) =
  let helperRules = []
  let renderCache = new globalThis.Map()
  fun sequence(lhs, rhsOpt) =
    if rhsOpt is
      Some(rhs) then rr.Sequence(lhs, rhs)
      None then lhs
  fun diagram(choicesOpt) =
    rr.Diagram of if choicesOpt is Some(choices) then choices else []
  fun renderChoice(choice, currentRule) = if choice is
    Choice.End then
      tracer.print of "found Choice.End"
      None
    Choice.Keyword(keyword, rest) then
      tracer.print of "found Choice.Keyword"
      Some of rr.Terminal(keyword.name) sequence(renderRule(rest, currentRule))
    Choice.Optional(rule, rest) then
      tracer.print of "found Choice.Optional"
      Some of if renderRule(rule, currentRule) is
        let latterPart = renderRule(rest, currentRule)
        Some(optionalPart) then rr.Optional(optionalPart) sequence(latterPart)
        None then latterPart
    Choice.Expr(_, _, rest) then
      tracer.print of "found Choice.Expr"
      Some of rr.NonTerminal("expr") sequence(renderRule(rest, currentRule))
    Choice.Lazy(get, make) and
      renderCache.has(choice) then
        tracer.print of "found Choice.Lazy in cache"
        let ruleName = renderCache.get(choice)
        Some of rr.NonTerminal(ruleName, LinkOpts("#" + ruleName))
      currentRule is
        Some(ruleName) then
          tracer.print of "found Choice.Lazy in recursion"
          let rule = get()
          if rule is RecursiveKnot then
            tracer.print of "found RecursiveKnot"
            Some of rr.NonTerminal(ruleName, LinkOpts("#" + ruleName))
          else
            tracer.print of "expect RecursiveKnot, found " + String(rule)
            ???
        None then
          tracer.print of "found Choice.Lazy in top-level"
          let proxyRule = make(() => RecursiveKnot)
          let ruleName = "rule$" + helperRules.length.toString()
          helperRules.push of tuple of
            ruleName, diagram of renderChoice(proxyRule, Some(ruleName))
          renderCache.set(choice, ruleName)
          Some of rr.NonTerminal(ruleName, LinkOpts("#" + ruleName))
    do console.log("unexpected choice: " + choice)
  fun renderRule(rule: ParseRule, currentRule) = tracer.trace of
    "renderRule <<< "
    result => "renderRule >>> "
    () => ...
    let
      rest = rule.choices
      optional = false
      nodes = []
    while rest is head :: tail do
      if renderChoice(head, currentRule) is
        Some(node) do nodes.push of node
        None do set optional = true
      set rest = tail
    tracer.print of "nodes: ", nodes.length.toString()
    if
      nodes.length is 0 then None
      let choice = rr.Choice(0, ...nodes)
      optional is true then Some(rr.Optional(choice))
      else Some(choice)
  [["Prefix Rules", diagram of renderRule(rule, None)], ...helperRules]
