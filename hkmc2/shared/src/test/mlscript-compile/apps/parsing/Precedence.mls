import "../../Option.mls"
import "../../BetterMap.mls"
import "./Keyword.mls"

open Option { Some, None }
open BetterMap
open Keyword { Keyword, INT_MIN, INT_MAX }

//  ____                        _
// |  _ \ _ __ ___  ___ ___  __| | ___ _ __   ___ ___
// | |_) | '__/ _ \/ __/ _ \/ _` |/ _ \ '_ \ / __/ _ \
// |  __/| | |  __/ (_|  __/ (_| |  __/ | | | (_|  __/
// |_|   |_|  \___|\___\___|\__,_|\___|_| |_|\___\___|
//
// ===================================================

module Precedence with ...

module Keywords with
  val all = new Map()
  fun keyword(name, leftPrec, rightPrec) =
    let result = Keyword(name, leftPrec, rightPrec)
    all.insert(name, result)
    result
  let prec = 0 
  fun currPrec = Some(prec)
  fun nextPrec =
    set prec = prec + 1
    Some(prec)
  let basePrec = currPrec // the lowest precedence
  val _terminator = keyword(";;", basePrec, basePrec)
  val _class = keyword("class", None, basePrec)
  val _begin = keyword("begin", None, basePrec)
  val _end = keyword("end", basePrec, None)
  let semiPrec = nextPrec
  let commaPrec = nextPrec
  val _semicolon = keyword(";", semiPrec, basePrec)
  val _comma = keyword(",", commaPrec, semiPrec)
  let eqPrec = nextPrec
  let ascPrec = nextPrec
  val _equal = keyword("=", eqPrec, eqPrec)
  val _and = keyword("and", None, currPrec)
  val _bar = keyword of "|", None, currPrec
  val _thinArrow = keyword of "->", nextPrec, eqPrec
  val _colon = keyword(":", ascPrec, eqPrec)
  val _match = keyword("match", nextPrec, currPrec)
  val _with = keyword("with", None, currPrec)
  val _case = keyword("case", None, currPrec)
  let thenPrec = nextPrec
  val _if = keyword("if", nextPrec, thenPrec)
  val _then = keyword("then", thenPrec, thenPrec)
  val _do = keyword("do", thenPrec, thenPrec)
  val _else = keyword("else", thenPrec, thenPrec)
  val _let = keyword("let", eqPrec, semiPrec)
  val _in = keyword("in", thenPrec, thenPrec)
  val _true = keyword("true", None, None)
  val _false = keyword("false", None, None)
  // val _fatArrow = keyword of "=>", nextPrec, eqPrec
  val _as = keyword("as", nextPrec, currPrec)
  val _fun = keyword("fun", currPrec, _thinArrow.leftPrec)
  val _function = keyword("function", currPrec, None)
  val _type = keyword("type", currPrec, None)
  val _exception = keyword("exception", currPrec, None)
  val _rec = keyword("rec", currPrec, eqPrec)
  val maxPrec = prec

fun makePrecMap(...ops) =
  let
    m = new Map
    i = 0
  while i < ops.length do
    ops.at(i).split(" ").forEach of (op, _, _) =>
      if op.length > 0 do
        m.insert of op, i + Keywords.maxPrec
    set i += 1
  m

let precMap = makePrecMap of
  ","
  "@"
  ":"
  "|"
  "&"
  "="
  "/ \\"
  "^"
  "!"
  "< >"
  "+ -"
  "* %"
  "~"
  "" // perfix operators
  "" // applications
  "."

val appPrec = if precMap.get(".") is Some(prec) then prec - 1
val prefixPrec = appPrec - 1

fun orMaxPrec(precOpt) = if precOpt is
  Some(prec) then prec
  None then INT_MAX

fun charPrec(op) = if precMap.get(op) is Some(prec) then prec else INT_MAX

pattern Letter = "a" ..= "z" | "A" ..= "Z"

fun hasLetter(s) = [..s].some((ch, _, _) => ch is Letter)

pattern FloatOperator = "+." | "-." | "*." | "/."

pattern RightAssociative = "@" | "/" | "," | ":"

fun opPrec(opStr) = if
  opStr is FloatOperator then [charPrec(opStr.at(0)), charPrec(opStr.at(0))]
  opStr hasLetter() then [Keywords.maxPrec, Keywords.maxPrec]
  let leftPrec = charPrec of opStr.at(0)
  let rightOp = opStr.at(-1)
  let rightPrec = charPrec of rightOp
  rightOp is RightAssociative then [leftPrec, rightPrec - 1]
  else [leftPrec, rightPrec]

module TypeKeywords with
  // TODO: BEGIN deduplicate with Keywords (maybe use class extension?)
  val all = new Map()
  fun keyword(name, leftPrec, rightPrec) =
    let result = Keyword(name, leftPrec, rightPrec)
    all.insert(name, result)
    result
  let prec = 0
  fun currPrec = Some(prec)
  fun nextPrec =
    set prec = prec + 1
    Some(prec)
  // TODO: END deduplicate with Keywords (maybe use class extension?)
  
  // * These keywords basically only serve as stop signs.
  val _type = keyword("type", None, None)
  val _exception = keyword("exception", None, None)
  val _let = keyword("let", None, None)
  val _and = keyword("and", None, None)
  
  // * The semicolon is right associative.
  let semiPrec = currPrec
  val _semicolon = keyword(";", nextPrec, semiPrec)
  
  val _comma = keyword(",", nextPrec, currPrec) // * Only used for separating type parameters
  val _bar = keyword("|", nextPrec, currPrec)
  val _as = keyword("", nextPrec, currPrec)
  let arrowPrec = currPrec
  val _arrow = keyword("->", nextPrec, arrowPrec)
  val _of = keyword("of", nextPrec, currPrec)
  val _asterisk = keyword("*", nextPrec, currPrec)
  val _sharp = keyword("#", nextPrec, currPrec)
  val _colon = keyword(":", nextPrec, currPrec)
  val appPrec = nextPrec Option.unsafe.get()
  val _period = keyword(".", nextPrec, currPrec)
