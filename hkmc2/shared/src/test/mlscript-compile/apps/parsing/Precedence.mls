import "../../Option.mls"
import "../../BetterMap.mls"
import "./Keyword.mls"

open Option { Some, None }
open BetterMap
open Keyword { Keyword, INT_MIN, INT_MAX }

//  ____                        _
// |  _ \ _ __ ___  ___ ___  __| | ___ _ __   ___ ___
// | |_) | '__/ _ \/ __/ _ \/ _` |/ _ \ '_ \ / __/ _ \
// |  __/| | |  __/ (_|  __/ (_| |  __/ | | | (_|  __/
// |_|   |_|  \___|\___\___|\__,_|\___|_| |_|\___\___|
//
// ===================================================

module Precedence with ...

module Keywords with
  let prec = 0 
  fun currPrec = Some(prec)
  fun nextPrec =
    set prec = prec + 1
    Some(prec)
  let basePrec = currPrec // the lowest precedence
  val _class = Keyword("class", None, basePrec)
  val _begin = Keyword("begin", None, basePrec)
  val _end = Keyword("end", basePrec, None)
  let semiPrec = nextPrec
  let commaPrec = nextPrec
  val _semicolon = Keyword(";", semiPrec, basePrec)
  val _comma = Keyword(",", commaPrec, semiPrec)
  let eqPrec = nextPrec
  let ascPrec = nextPrec
  val _equal = Keyword("=", eqPrec, eqPrec)
  val _bar = Keyword("|", None, currPrec)
  val _and = Keyword("and", None, currPrec)
  val _colon = Keyword(":", ascPrec, eqPrec)
  val _match = Keyword("match", nextPrec, currPrec)
  val _with = Keyword("with", None, currPrec)
  val _case = Keyword("case", None, currPrec)
  let thenPrec = nextPrec
  val _if = Keyword("if", nextPrec, thenPrec)
  val _then = Keyword("then", thenPrec, thenPrec)
  val _do = Keyword("do", thenPrec, thenPrec)
  val _else = Keyword("else", thenPrec, thenPrec)
  val _let = Keyword("let", eqPrec, semiPrec)
  val _in = Keyword("in", thenPrec, thenPrec)
  val _true = Keyword("true", None, None)
  val _false = Keyword("false", None, None)
  // val _fatArrow = Keyword of "=>", nextPrec, eqPrec
  val _as = Keyword("as", nextPrec, currPrec)
  val _thinArrow = Keyword of "->", nextPrec, eqPrec
  val _fun = Keyword("fun", currPrec, None)
  val _function = Keyword("function", currPrec, None)
  val _type = Keyword("type", currPrec, None)
  val _rec = Keyword("rec", currPrec, eqPrec)
  val maxPrec = prec

fun makePrecMap(...ops) =
  let
    m = new Map
    i = 0
  while i < ops.length do
    ops.at(i).split(" ").forEach of (op, _, _) =>
      if op.length > 0 do
        m.insert of op, i + Keywords.maxPrec
    set i += 1
  m

let precMap = makePrecMap of
  ","
  "@"
  ":"
  "|"
  "&"
  "="
  "/ \\"
  "^"
  "!"
  "< >"
  "+ -"
  "* %"
  "~"
  "" // perfix operators
  "" // applications
  "."

val appPrec = if precMap.get(".") is Some(prec) then prec - 1
val prefixPrec = appPrec - 1

fun orMaxPrec(precOpt) = if precOpt is
  Some(prec) then prec
  None then INT_MAX

fun charPrec(op) = if precMap.get(op) is Some(prec) then prec else INT_MAX

pattern Letter = "a" ..= "z" | "A" ..= "Z"

fun hasLetter(s) = [..s].some((ch, _, _) => ch is Letter)

pattern FloatOperator = "+." | "-." | "*." | "/."

pattern RightAssociative = "@" | "/" | "," | ":"

fun opPrec(opStr) = if
  opStr is FloatOperator then [charPrec(opStr.at(0)), charPrec(opStr.at(0))]
  opStr hasLetter() then [Keywords.maxPrec, Keywords.maxPrec]
  let leftPrec = charPrec of opStr.at(0)
  let rightOp = opStr.at(-1)
  let rightPrec = charPrec of rightOp
  rightOp is RightAssociative then [leftPrec, rightPrec - 1]
  else [leftPrec, rightPrec]
