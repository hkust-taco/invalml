import "../../Predef.mls"
import "../../Option.mls"
import "../../Stack.mls"
import "../../BetterMap.mls"
import "./Token.mls"
import "./Keyword.mls"
import "./Precedence.mls"
import "./Tree.mls"
import "./ParseRule.mls"

open Predef
open Option
open Stack
open BetterMap
open Precedence { Keywords, opPrec }
open ParseRule { Choice, rule }

open Choice { keyword, reference, typeExpr }

type Opt[A] = Some[A] | None

module Rules with ...

val syntaxKinds = new Map()

val extendedKinds = new Set()

fun getRuleByKind(kind: Str) = syntaxKinds.get(kind) Option.unsafe.get()

fun define(name: Str)(...choices) =
  syntaxKinds.insert of name, rule(name, ...choices)

define("let-bindings") of
  Choice.term of ...
  (lhs, rhsBindings) => if rhsBindings is [rhs, bindings] then
    Tree.Infix(Keywords._equal, lhs, rhs) :: bindings
  "left-hand side"
  keyword(Keywords._equal) of ...
  Choice.term of ...
  (rhs, tail) => [rhs, tail]
  "right-hand side"
  Choice.end of Nil
  keyword(Keywords._and) of ...
  reference("let-bindings") of
    process: (tail, _) => tail
    name: "let-bindings tail"

fun makeLetBindings(hasInClause: Bool) =
  let intro = "let binding: "
  keyword(Keywords._let) of
    Choice.map of
      Choice.optional of
        rule of
          intro + "keyword"
          keyword(Keywords._rec)()
        rule of
          intro + "body"
          reference("let-bindings") of
            process: (bindings, body) => Tree.LetIn(bindings, body)
            name: "let-bindings"
            choices:
              if hasInClause then tuple of
                keyword(Keywords._in) of
                  Choice.term of
                    (body, _) => Some(body)
                    intro + "body"
                Choice.end of None
              else
                tuple of Choice.end of None
      case [_, res] then res

let letExpression = makeLetBindings(true)

let funTerm =
  keyword(Keywords._fun) of ...
  Choice.term of ...
  (params, body) => Tree.Lambda(params :: Nil, body)
  "function parameters"
  keyword(Keywords._thinArrow) of ...
  Choice.term of ...
  (body, _) => body
  "function body"
  Choice.end of None

define("simple-matching") of
  Choice.term of ...
  (lhs, rhsTail) =>
    if rhsTail is [rhs, tail] then
      Tree.Infix(Keywords._thinArrow, lhs, rhs) :: tail
  "pattern"
  keyword(Keywords._thinArrow) of ...
  Choice.term of ...
  (rhs, tail) => [rhs, tail]
  "rhs"
  Choice.end of Nil
  keyword(Keywords._bar) of ...
  reference("simple-matching") of
    process: (tail, _) => tail
    name: "simple-matching tail"

define("pattern-list") of
  Choice.term of ...
  (head, tail) => head :: tail
  "pattern"
  reference("pattern-list") of
    process: (tail, _) => tail
    name: "pattern list tail"

define("multiple-matching") of reference("pattern-list") of
  process: Tree.infix of Keywords._thinArrow
  name: "the list of patterns"
  choices: tuple of
    keyword(Keywords._thinArrow) of ...
    Choice.term of ...
    (rhs, _) => rhs
    "the right-hand side of the arrow"
    Choice.end of Nil
    keyword(Keywords._bar) of ...
    reference("multiple-matching") of
      process: (tail, _) => tail
      name: "multiple-matching tail"

fun makeInfixChoice(kw: Keyword.Keyword, rhsKind: Str, compose: (Tree, Tree) -> Tree) =
  keyword(kw) of ...
  reference(rhsKind) of
    process: (rhs, _) => lhs => compose(lhs, rhs)
    name: "operator `" + kw.name + "` right-hand side"

val termInfixRule = rule of
  "infix rules for expressions"
  // Tuple (separated by commas)
  makeInfixChoice of Keywords._comma, "term", (lhs, rhs) => if rhs is
    Tree.Tuple(tail) then Tree.Tuple(lhs :: tail)
    else Tree.Tuple(lhs :: rhs :: Nil)
  // Sequence (separated by semicolons)
  makeInfixChoice of Keywords._semicolon, "term", (lhs, rhs) => if rhs is
    Tree.Sequence(tail) then Tree.Sequence(lhs :: tail)
    else Tree.Sequence(lhs :: rhs :: Nil)
  // Assignment: <expr> <- <expr>
  makeInfixChoice of Keywords._leftArrow, "term", (lhs, rhs) =>
    Tree.Infix(Keywords._leftArrow, lhs, rhs)
  // Comparison: <expr> == <expr>
  makeInfixChoice of Keywords._equalequal, "term", (lhs, rhs) =>
    Tree.Infix(Keywords._equalequal, lhs, rhs)
  // Comparison: <expr> * <expr>
  makeInfixChoice of Keywords._asterisk, "term", (lhs, rhs) =>
    Tree.App(Tree.Ident("*", true), lhs :: rhs :: Nil)
  // Selection: <expr> "." <identifier>
  // Access: <expr> "." "(" <expr> ")"
  keyword(Keywords._period) of
    keyword(Keywords._leftRound) of
      Choice.term of ...
      (argument, _) => lhs => Tree.Infix(Keywords._period, lhs, Tree.Bracketed(Token.Round, argument))
      "application argument"
      keyword(Keywords._rightRound)()
    reference("term") of
      process: (rhs, _) => lhs => Tree.Infix(Keywords._period, lhs, rhs)
      name: "operator `.` right-hand side"
  // Type ascription: <expr> : <type>
  keyword(Keywords._colon) of
    typeExpr of
      (rhs, _) => lhs => Tree.Infix(Keywords._colon, lhs, rhs)
      "right-hand side type"
  // Application: <expr> <expr>
  Choice.termWithPrec of
    (argument, _) => callee => Tree.App(callee, argument)
    "application argument"
    Some(Keywords.appPrec)
    None

fun makeBracketRule(opening, closing, contentKind, wrapContent) =
  // Pass the error message of closing bracket to the content.
  keyword(opening) of reference(contentKind) of
    process: (tree: Tree, end: Tree) => if end is
      Tree.Error(Tree.Empty, msg) then wrapContent(tree) Tree.Error(msg)
      Tree.Empty                  then wrapContent(tree)
    name: contentKind + " in bracket"
    choices: tuple of keyword(closing) of Choice.end of Tree.empty

// Prefix rules and infix rules for expressions.
val termRule = rule of
  "prefix rules for expressions"
  letExpression
  funTerm
  // `match`-`with` term
  keyword(Keywords._match) of
    Choice.term of ...
    Tree.Match
    "pattern matching scrutinee"
    keyword(Keywords._with) of ...
    Choice.map of
      Choice.optional of
        rule of
          "pattern matching case body"
          keyword(Keywords._bar)()
        getRuleByKind("simple-matching")
      case [_, res] then res
  // `function` term
  Choice.map of
    keyword(Keywords._function) of 
      Choice.optional of
        rule of
          "function body"
          keyword(Keywords._bar)()
        getRuleByKind("simple-matching")
    case [_, branches] then
      Tree.Match(Tree.empty, branches)
  // `if`-`then`-`else` term
  keyword(Keywords._if) of
    Choice.term of ...
    (tst, conAlt) => if conAlt is [con, alt] then
      Tree.Ternary(Keywords._if, tst, con, alt)
    "if-then-else condition"
    keyword(Keywords._then) of ...
    Choice.term of ...
    (con, optAlt) => [con, optAlt]
    "if-then-else consequent"
    Choice.end of None
    keyword(Keywords._else) of ...
    Choice.term of ...
    (alt, _) => Some(alt)
    "if-then-else alternative"
    Choice.end of None
  // `while` term
  keyword(Keywords._while) of
    Choice.term of ...
    Tree.While
    "while body"
    keyword(Keywords._do) of ...
    Choice.term of ...
    (body, _) => body
    "while end"
    keyword(Keywords._done)()
  // `for` term
  keyword(Keywords._for) of
    Choice.term of ...
    (head, startEndBody) => Tree.For(head, ...startEndBody)
    "`for` head"
    keyword(Keywords._equal) of ...
    Choice.term of ...
    (start, endBody) => [start, ...endBody]
    "`for` `to` or `downto` keyword"
    Choice.map of...
    Choice.siding of
      rule of
        "iteration keyword"
        keyword(Keywords._to)()
        keyword(Keywords._downto)()
      rule of
        "the iteration keyword"
        Choice.term of ...
        (end, body) => [end, body]
        "`for` `do` keyword"
        keyword(Keywords._do) of ...
        Choice.term of ...
        (body, _) => body
        "`for` `done` keyword"
        keyword(Keywords._done)()
    case [_, res] then res
  // Choices for brackets
  makeBracketRule of
    Keywords._leftRound
    Keywords._rightRound
    "term"
    (tree) => if tree is Tree.Empty then Tree.Tuple(Nil) else tree
  makeBracketRule of
    Keywords._leftSquare
    Keywords._rightSquare
    "term"
    (tree) => Tree.Bracketed of Token.Square, if tree is
      Tree.Empty then Tree.Sequence(Nil)
      else tree
  makeBracketRule of
    Keywords._leftCurly
    Keywords._rightCurly
    "term"
    id
  makeBracketRule of
    Keywords._begin
    Keywords._end
    "term"
    (tree) => if tree is Tree.Empty then Tree.Sequence(Nil) else tree
  // We put the infix rules here for the railroad diagrams.
  Choice.Ref of
    "term"
    (lhs, compose) => compose(lhs)
    None
    None
    termInfixRule

val typeInfixRule = rule of
  "infix rules for types"
  // <type> "->" <type>
  makeInfixChoice of Keywords._thinArrow, "type", (lhs, rhs) =>
    Tree.Infix(Keywords._thinArrow, lhs, rhs)
  // <type> "*" <type>
  makeInfixChoice of Keywords._asterisk, "type", (lhs, rhs) =>
    Tree.Infix(Keywords._asterisk, lhs, rhs)
  // Application: <type> <type>
  Choice.Ref of
    "type"
    (callee, _) => argument => Tree.App(callee, argument)
    Some(Keywords.appPrec)
    None
    rule("end of type infix rules")

// Prefix rules and infix rules for types.
val typeRule = rule of
  "rules for types"
  // "(" <type> { "," <type> } ")" [ <ident> ]
  keyword(Keywords._leftRound) of
    reference("type") of                                                // : Tree
      process: (headArg, tailArgsCtor) => if tailArgsCtor is
        [tailArgs, ctor] then Tree.App(ctor, Tree.Tuple(headArg :: tailArgs))
        Some(ctor) then Tree.App(ctor, headArg)
        None then headArg
      name: "the first type in the parentheses"
      choices: tuple of
        reference("type-arguments-tail") of                          // : [List[Tree], Tree.Ident]
          process: (args, ident) => [args, ident]
          name: "the remaining type arguments"
          choices: tuple of keyword(Keywords._rightRound) of                                        // : Tree.Ident  
            reference("ident") of                                      // Tree.Ident
              process: (ident, _) => Some(ident)
              name: "the type constructor's name"
        keyword(Keywords._rightRound) of                                  // : Option[Tree.Ident]
          // either an identifier or nothing
          Choice.end of None
          reference("ident") of
            process: (ident, _) => Some(ident)
            name: "the type constructor's name"
  // Infix rules
  reference("type") of
    process: (lhs, compose) => compose(lhs)
    choices: typeInfixRule

define("type-arguments-tail") of keyword(Keywords._comma) of
  reference("type") of
    process: Cons
    name: "the first type argument"
    choices: tuple of
      Choice.end of Nil                                                   // : Nil
      reference("type-arguments-tail") of                                          // : List[Tree]
        process: (tail, _) => tail
        name: "more type arguments"
  
define("constr-decl") of reference("ident") of
  process: (ctor, argOpt) => if argOpt is
    Some(arg) then Tree.Infix(Keywords._of, ctor, arg)
    None then ctor
  name: "the variant constructor's name"
  choices: tuple of
    Choice.end of None
    keyword(Keywords._of) of reference("type") of
      process: (argument, _) => Some(argument)
      name: "the variant constructor's argument"

define("variants") of reference("constr-decl") of
  process: (lhs, rhsOpt) => if rhsOpt is
    Some(rhs) then Tree.Infix(Keywords._bar, lhs, rhs)
    else lhs
  name: "variants item"
  choices: tuple of
    Choice.end of None
    keyword(Keywords._bar) of reference("variants") of
      process: (more, _) => Some(more)
      name: "variants end"

define("typedefs") of reference("typedef-lhs") of
  process: (lhs, rhsMore) => if rhsMore is [rhs, more] then rhs(lhs) :: more
  name: "typedef name"
  choices: tuple of reference("typedef-rhs") of
    name: "typedef body"
    choices: tuple of
      Choice.end of Nil
      keyword(Keywords._and) of reference("typedefs") of
        process: (more, _) => more
        name: "typedef end"

define("typedef-rhs") of
  keyword(Keywords._equal) of
    reference("variants") of
      process: (rhs, _) => lhs => Tree.Infix(Keywords._equal, lhs, rhs)
      name: "typedef-rhs: variants"
    Choice.map of
      keyword(Keywords._leftCurly) of
        reference("label-decls") of
          process: (content, _) => if content is
            Nil then Tree.Bracketed(Token.Curly, Tree.Sequence(Nil))
            else Tree.Bracketed(Token.Curly, Tree.Sequence(content))
          name: "label-decl"
          choices: tuple of keyword(Keywords._rightCurly) of
            Choice.end of Tree.empty
      rhs => lhs => Tree.Infix(Keywords._equal, lhs, rhs) 
  keyword(Keywords._equalequal) of
    reference("type") of
      process: (rhs, _) => lhs => Tree.Infix(Keywords._equalequal, lhs, rhs)
      name: "type alias body"

define("label-decl") of
  typeExpr of
    Tree.infix of Keywords._colon
    "label-decl name"
    keyword(Keywords._colon) of
      typeExpr of
        (rhs, _) => rhs
        "label-decl body"

define("label-decls") of
  reference("label-decl") of
    process: Cons
    name: "the first label-decl"
    choices: tuple of
      Choice.end of Nil // : List[]
      keyword(Keywords._semicolon) of reference("label-decls") of
        process: (more, _) => more
        name: "more label-decls"

define("constr-decls") of
  reference("constr-decl") of
    process: Cons
    name: "the first constructor declaration"
    choices: tuple of
      Choice.end of Nil
      keyword(Keywords._bar) of reference("constr-decls") of
        process: (tail, _) => tail
        name: "more constructor declarations"

define("typedef-lhs") of reference("type-params") of
  process: (params, ident) => if params is
    Nil then ident
    else Tree.App(ident, Tree.Tuple(params))
  name: "the type parameters"
  choices: tuple of reference("ident") of
    process: (ident, _) => ident
    name: "the type identifier"

define("type-params") of
  reference("typevar") of
    process: (head, _) => head :: Nil
    name: "the only type parameter"
  keyword(Keywords._leftRound) of
    reference("typevar") of
      process: Cons
      name: "the first type parameter"
      choices: tuple of reference("type-params-tail") of
        process: (tail, _) => tail
        name: "more type parameters"
        choices: tuple of keyword(Keywords._rightRound)()
  Choice.end of Nil

define("type-params-tail") of
  Choice.end of Nil
  keyword(Keywords._comma) of
    reference("typevar") of
      process: Cons
      name: "the first type parameter"
      choices: tuple of reference("type-params-tail") of
        process: (tail, _) => tail
        name: "more type parameters"
        Choice.end of ()

val declRule = rule of
  "prefix rules for module items"
  makeLetBindings(false) // let definition
  keyword(Keywords._type) of
    reference("typedefs") of
      process: (typedefs, _) => Tree.Define(Tree.DefineKind.Type, typedefs)
      name: "more typedefs"
  keyword(Keywords._exception) of
    reference("constr-decls") of
      process: (decls, _) => Tree.Define(Tree.DefineKind.Exception, decls)
      name: "constructor declarations"
  keyword(Keywords._hash) of
    reference("ident") of
      process: (ident, body) => Tree.Define(Tree.DefineKind.Directive, [ident, body] :: Nil)
      name: "directive name"
    reference("term") of
      process: (body, _) => body
      name: "directive body"

syntaxKinds.insert of "term", termRule
syntaxKinds.insert of "type", typeRule
syntaxKinds.insert of "decl", declRule
