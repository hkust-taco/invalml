import "../../MutMap.mls"
import "../../Predef.mls"

open Predef
module Examples with...

val examples = MutMap.empty

examples |> MutMap.insert of
  "ExampleInResponse.mls"
  name: "Example in Response"
  source: """
// * This file contains examples in the author response. A few typos therein are corrected.


// Some utility functions:

fun wield: [R] -> (Region[out R]) ->{R} ()
fun freeze: [R, E extends ~R, T] -> (Region[out R], () ->{~R & E} T) ->{R | E} T
// ^ Fixed a typo in the author response (`{~R | E}` should have been `{~R & E}`)

fun (;) seq(_, res) = res
fun rand: () -> Bool
fun print: Any -> ()


// ### Example 1


// Passing the same region for both arguments fundamentally does not work approaches like Rust and Capability Calculus.
fun foo1(r1, r2) =
  freeze(r1, () => print("ok"))
  wield(r2)

// InvalML allows r1 and r2 to alias as long as ‹body› does not use r2; for instance:
region r in
  foo1(r, r)

// Capability Calculus and related systems would require r2 to be distinct from r1.

// Note – this also works:
region r in
  region s in
    foo1(r, s)

// Here is a slightly less trivial examples that still type checks seamlessly in InvalML:
region r0 in
  
  fun foo1(r1, r2) =
    freeze(r1, () => wield(r0))
    wield(r2)
  
  region r in
    foo1(r, r)
  
  region r in
    region s in
      foo1(r, s)


// On the other hand, given
fun foo2(r1, r2) =
  freeze(r1, () => wield(r2))
  wield(r2)

// we rightfully reject
// region r in
//   foo2(r, r)

// but still accept
region r in
  region s in
    foo2(r, s)


// ### Example 2


fun foo3: [outer, R extends outer] -> Region[out R] ->{outer} ()
fun foo3(r1) =
  region r2 in
    freeze(r2, () =>
      wield(r1)
    )
// ^ Fixed typos in the author response (it used the paper's syntax instead of the implementation's syntax)

// In fact, this formally equivalent signature also works:
fun foo3': [outer] -> Region[out outer] ->{outer} ()
fun foo3'(r1) = foo3(r1)


// ### Example 3


fun foo4(r1, r2, f) =
  let exec = freeze(r1, () => freeze(r2, () => f(r1, r2)))
  let r = exec()
  !r + 1

region r in
  region s in
    foo4(r, s, (x, y) =>
      if rand() then print("Chose x"); () => x.ref 0
                else print("Chose y"); () => y.ref 1)


// ### Example 4


fun foo5(f) =
  region r in
    freeze(r, () => f(32))


fun freeze2: [R, E extends ~R, T] -> (Region[out R], () ->{~R & E} T) ->{R | E} T

fun foo6(f) =
  region r in
    freeze(r, () => f(32))

foo6
"""

examples |> MutMap.insert of
  "ExampleInThePaper.mls"
  name: "Example in the Paper"
  source: """
// * This file contains examples in the paper

class ArrayList[A, R]
class List[A]
class Iter[T, R]

fun mkArrayList : [R, T] -> (Region[out R]) ->{R} ArrayList[T, R]
fun add : [R, T] -> (ArrayList[T, R], T) ->{R} ()
fun clear : [R, T] -> ArrayList[T, R] ->{R} ()
fun foreach : [E, R, T] -> (Iter[T, R], T ->{E} ()) -> {R | E} ()
fun iter : [Res, R, E extends ~R, T] -> (ArrayList[T, R], [I] -> Iter[T, I] ->{I | E} Res) ->{E | R} Res
fun map: [T, S, E] -> (List[out T], T ->{E} S) ->{E} List[out S]

fun println: Any -> ()
fun (;) seq(_, res) = res

region r in // This is used to delimit the scope of mutation
  let xs = mkArrayList(r) // Creates a new mutable list in r egion r
  add(xs, "1"); add(xs, "2"); add(xs, "3");
  iter(xs, it => foreach(it , e => println(e)))

// region r in // This is used to delimit the scope of mutation
//   let xs = mkArrayList(r) // Creates a new mutable list in r egion r
//   add(xs, "1"); add(xs, "2"); add(xs, "3");
//   iter(xs, it => foreach(it , e => println (e); clear (xs)))

fun mapi: [A, B, E] -> (List[out A], (Int, A) ->{E} B) ->{E} List[out B]
fun mapi(xs, f) =
  region r in
    let index = r.ref 0 in map(xs, x => let res = f(!index, x) in index := !index + 1; res)


fun f: [R1, R2 extends ~R1] -> (Region[out R1], Region[out R2]) ->{R1 | R2} Int


// region r1 in
//   let g = (r => region r2 in f(r, r2)) in (region r3 in g(r3))


region r1 in
  fun g: [outer, R extends outer] -> Region[out R] ->{R} Int
  fun g(r) = region r2 in f(r, r2)
  region r3 in g(r3)


region r in
  let a1 = mkArrayList(r) in add(a1, 12); add(a1, 34);
  iter of a1, it1 =>
    region s in
      let a2 = mkArrayList(s)
      foreach of it1, v1 => add(a2 , v1)
      iter of a2, it2 => foreach of it2 , v2 => println(v2)
      clear(a2)


// region r in
//   let a = mkArrayList(r) in add(a, 12); add(a, 34);
//   iter of a, it =>
//     foreach of it, v => println(v); clear(a)
"""

examples |> MutMap.insert of
  "MergeSort.mls"
  name: "Merge Sort"
  source: """
// * This file includes the implementation for merge sorting,
// * executed sequentially or in parallel.
// * Adapted from https://doi.org/10.5281/zenodo.8425443


// *** infrastructures


declare class Array[T, R]


class Pair[T, S] with
  constructor
    Pr(fst: T, snd: S)


fun
  mkArray: [T, R] -> Region[out R] ->{R} Array[T, out R]
  push: [T, R] -> (Array[in T, out R], T) ->{R} ()
  unshift: [T, R] -> (Array[in T, out R], T) ->{R} ()
  map: [T, S, R, E extends ~R] -> (Array[out T, out R], T ->{E} S) ->{E | R} Array[S, out R]
  foreach: [T, R, E extends ~R] -> (Array[out T, out R], T ->{E} ()) ->{E | R} ()
  len: [R] -> Array[in Nothing out Any, out R] ->{R} Int
  at: [T, R] -> (Array[out T, out R], Int) ->{R} T
  slice: [T, R] -> (Array[out T, out R], Int) ->{R} Array[out T, out R]
  concat: [T, R1, R2, R3] -> (Region[out R3], Array[in T, out R1], Array[out T, out R2]) ->{R1 | R2 | R3} Array[T, out R3]


// Matching on js array is not supported yet.
// This helper function is equivalent to `if xs is Cons(x, xs) then fh(x, xs) else fn(xs)`
fun matchOne(xs, fn, fh) =
  if len(xs) is 0 then fn(xs)
  else fh(at(xs, 0), slice(xs, 1))

// Matching on js array is not supported yet.
// This helper function is equivalent to
// `if xs is Cons(x, Cons(y, ys)) then f2(x, y, ys) else if xs is Cons(x, xs) then f1(x, xs) else fn(xs)`
// fun matchTwo: [T, R, E1, E2, E3, S] -> (Array[out T, out R], Array[out T, out R] ->{E1} S, T ->{E2} S, (T, T, Array[out T, out R]) ->{E3} S) ->{E1 | E2 | E3 | R} S
fun matchTwo(xs, fn, f1, f2) =
  if len(xs) is 0 then fn(xs)
  else if len(xs) is 1 then f1(at(xs, 0))
  else f2(at(xs, 0), at(xs, 1), slice(xs, 2))

fun (;) seq(_, res) = res

fun println: Any -> ()
fun forkJoin: [T, S, P, E1, E2 extends ~E1, E3] ->
  (() ->{E1} T, () ->{E2} S, (T, S) ->{E3} P) ->{E1 | E2 | E3} P


// *** pmsort implementation

// Split the given array into two sub-arrays.
// Region r1 and r2 indicate where the two sub-arrays should be stored.
fun split(xs, r1, r2) =
  fun rs(xs, ys, zs) =
    matchTwo of xs, _ => Pr(ys, zs), x => push(ys, x); Pr(ys, zs), (x1, x2, r) => push(ys, x1); push(zs, x2); rs(r, ys, zs)
  rs(xs, mkArray(r1), mkArray(r2))


// Merge arr1 and arr2. The result is stored in region r.
// fun merge: [T, R1, R2, R] -> (Array[out T, out R1], Array[out T, out R2], Region[R]) ->{R1 | R2 | R} Array[T, out R]
fun merge(arr1, arr2, r) =
  fun recm(xs, ys, acc) =
    matchOne of xs, _ => concat(r, acc, ys), (x, rx) =>
      matchOne of ys, _ => concat(r, acc, xs), (y, ry) =>
        if x < y then push(acc, x); recm(rx, ys, acc)
        else push(acc, y); recm(xs, ry, acc)
  recm(arr1, arr2, mkArray(r))


// Merge sort in single thread.
fun smsort(xs, r) =
  matchTwo of xs, _ => mkArray(r), x => let res = mkArray(r) in push(res, x); res, (_, _, _) =>
    let p = split(xs, r, r) in
      if p is Pr(fst, snd) then merge(smsort(fst, r), smsort(snd, r), r)


// Wrong version! Sub-arrays cannot be stored in the same region!
// fun pmsort: [R1, R2] -> (Array[out Int, out R1], Region[R2]) ->{R1 | R2} Array[Int, out R2]
// fun pmsort(xs, r) =
//   matchTwo of xs, _ => mkArray(r), x => let res = mkArray(r) in push(res, x); res, (_, _, _) =>
//     let p = split(xs, r, r) in
//       if p is Pr(fst, snd) then
//         forkJoin(_ => pmsort(fst, r), pmsort(snd, r), (r1, r2) => merge(r1, r2, r))


// Merge sort in parallel.
fun pmsort: [R1, R2] -> (Array[out Int, out R1], Region[out R2]) ->{R1 | R2} Array[Int, out R2]
fun pmsort(xs, r) =
  matchTwo of xs, _ => mkArray(r), x => let res = mkArray(r) in push(res, x); res, (_, _, _) =>
    region r1 in
      region r2 in
        let p = split(xs, r1, r2) in
          if p is Pr(fst, snd) then
            forkJoin(() => pmsort(fst, r1), () => pmsort(snd, r2), (rx, ry) => merge(rx, ry, r))


// *** simple tests

region r in
  let arr = mkArray(r)
  push(arr, 10)
  push(arr, 23)
  push(arr, 13)
  push(arr, 4)
  smsort(arr, r)

region r in
  let arr = mkArray(r)
  push(arr, 10)
  push(arr, 23)
  push(arr, 13)
  push(arr, 4)
  pmsort(arr, r)
"""

examples |> MutMap.insert of
  "SimpleConstraintSolver.mls"
  name: "Simple Constraint Solver"
  source: """
// * In this file, we implement a simple constraint solver, originally presented in https://doi.org/10.1145/3410225

// *** infrastructures

fun not(b) = if b then false else true
fun (;) seq(_, res) = res
fun id(x) = x

fun println: Any -> ()
fun (~) concat: (Str, Str) -> Str
fun toString: Any -> Str
fun (===) streq: (Str, Str) -> Bool
fun error() = error()

class PairOf[out A, out B] with
  constructor
    Pair(fst: A, snd: B)

class Option[out A] with
  constructor
    None()
    Some(value: A)

class List[out A] with
  constructor
    Nil()
    Cons(head: A, tail: List[A])

fun fold(x, xs, f) = if xs is
  Nil() then x
  Cons(y, ys) then fold(f(x, y), ys, f)

fun map(xs, f) = if xs is
  Nil() then Nil()
  Cons(x, xs) then Cons(f(x), map(xs, f))

fun each(xs, f) = if xs is
  Nil() then ()
  Cons(x, xs) then f(x); each(xs, f)

fun find(xs, f) = if xs is
  Nil() then None()
  Cons(x, xs) then
    if f(x) then Some(x)
    else find(xs, f)

class ArrayList[T, out R]
class Iter[T, out R]
class HashMap[K, V, out R]
class MapIter[T, out R]

fun empty: [A, R] -> Region[out R] ->{R} ArrayList[A, out R]
fun clear: [A, R] -> (ArrayList[A, out R]) ->{R} ()
fun push: [A, R] -> (ArrayList[A, R], A) ->{R} ()
fun len: [A, R] -> (ArrayList[A, R]) ->{R} Int
fun iter: [Res, R, E extends ~R, T] -> (ArrayList[T, R], [S] -> Iter[T, S] ->{S | E} Res) ->{E | R} Res
fun next: [T, S] -> Iter[T, S] ->{S} Option[T]
fun whileDo: [R] -> (() ->{R} Bool) ->{R} ()
fun foreach: [E, R, T] -> (Iter[T, R], T ->{E} ()) ->{R | E} ()
fun max(x, y) = if x < y then y else x


fun mkHashMap: [R, K, V] -> (Region[out R], K -> Str) ->{R} HashMap[K, V, R]
fun getOrUpdate: [R, K, V, E] -> (HashMap[K, V, R], K, () ->{E} V) ->{E | R} V
fun hasOrUpdate: [R, K, V, E] -> (HashMap[K, V, R], K, () ->{E} V) ->{E | R} ()
fun iterMap: [Res, R, E extends ~R, K, V] -> (HashMap[K, V, R], [S] -> MapIter[V, S] ->{S | E} Res) ->{E | R} Res
fun nextVal: [T, S] -> MapIter[T, S] ->{S} Option[T]
fun hasKey: [K, V, R] -> (HashMap[K, V, R], K) ->{R} Bool
fun add: [K, V, R] -> (HashMap[K, V, R], K, V) ->{R} ()
fun values: [E, R, T] -> (MapIter[T, R], T ->{E} ()) ->{R | E} ()

// *** simple constraint solver


// Unif contains a type variable's id, lower bounds, and upper bounds.
class Type[out R] with
  constructor
    IntType()
    FunctionType(lhs: Type[R], rhs: Type[R])
    RecordType(fields: List[PairOf[Str, Type[R]]])
    TypeVariable(id: Str, level: Int, lowerBounds: ArrayList[Type[R], R], upperBounds: ArrayList[Type[R], R])
    

fun isSimpl(ty) = if ty is
  FunctionType(_, _) then false
  else true


fun ty2Str(ty) = if ty is
  IntType() then "Int"
  FunctionType(lhs, rhs) then
    let ls = if isSimpl(lhs) then ty2Str(lhs) else "(" ~ ty2Str(lhs) ~ ")"
    ls ~ " -> " ~ ty2Str(rhs)
  RecordType(fields) then "{ " ~ fold("", fields, (s, p) => if p is Pair(n, t) then s ~ n ~ ": " ~ ty2Str(t) ~ ", ") ~ "}"
  TypeVariable(name, level, _, _) then name ~ "_" ~ toString(level)

// fun levelOf: [R] -> Type[R] -> Int
fun levelOf(ty) = if ty is
  IntType() then 0
  FunctionType(lhs, rhs) then max(levelOf(lhs), levelOf(rhs))
  RecordType(fields) then fold(0, fields, (r, p) => if p is Pair(_, t) then max(r, levelOf(t)))
  TypeVariable(_, level, _, _) then level

fun report(lhs, rhs) =
  println("Cannot constrain " ~ ty2Str(lhs) ~ " <: " ~ ty2Str(rhs) ~ "!")


fun extrude: [outer, R extends outer] -> (Type[R], Bool, Int, (Str, Int) ->{R} Type[R], HashMap[PairOf[Type[R], PairOf[Int, Bool]], Type[R], R]) ->{R} Type[R]
fun extrude(ty, pol, lvl, freshVar, cache) = getOrUpdate of cache, Pair(ty, Pair(lvl, pol)), () =>
  if levelOf(ty) <= lvl then ty
  else if ty is
    IntType() then ty
    FunctionType(lhs, rhs) then
      FunctionType(extrude(lhs, not(pol), lvl, freshVar, cache), extrude(rhs, pol, lvl, freshVar, cache))
    RecordType(fields) then
      RecordType(map(fields, p => if p is Pair(name, ty) then Pair(name, extrude(ty, pol, lvl, freshVar, cache))))
    TypeVariable(name, level, lb, ub) then
      let nc = freshVar(name ~ "'" ~ (if pol then "+" else "-"), lvl)
      if pol then
        push(ub, nc)
        let nlb = if nc is
          TypeVariable(_, _, lb, _) then lb
          else error() // impossible
        region r in
          let nbd = empty(r)
          iter of lb, it => foreach(it, b => push(nbd, b))
          iter of nbd, it => foreach(it, b => push(nlb, extrude(b, pol, lvl, freshVar, cache)))
      else
        push(lb, nc)
        let nub = if nc is
          TypeVariable(_, _, _, ub) then ub
          else error() // impossible
        region r in
          let nbd = empty(r)
          iter of ub, it => foreach(it, b => push(nbd, b))
          iter of nbd, it => foreach(it, b => push(nub, extrude(b, pol, lvl, freshVar, cache)))
      nc

// fun solve: [outer, R extends outer] -> (List[PairOf[Type[R], Type[R]]], (Str, Int) ->{R} Type[R], HashMap[PairOf[Type[R], Type[R]], Any, R], () ->{R} HashMap[PairOf[Type[R], PairOf[Int, Bool]], Type[R], R]) ->{R} ()
fun solve(constraints, freshVar, cache, genExtrCache) = if constraints is
  Nil() then ()
  Cons(c, cs) then if c is
    Pair(lhs, rhs) then hasOrUpdate of cache, c, () =>
      if lhs is
        IntType() then if rhs is
          IntType() then solve(cs, freshVar, cache, genExtrCache)
          TypeVariable(name, level, lb, ub) then
            push(lb, lhs)
            region r in
              let ncs = r.ref cs
              iter(ub, it => foreach(it, b => ncs := Cons(Pair(lhs, b), !ncs); ()))
              solve(!ncs, freshVar, cache, genExtrCache)
          else report(lhs, rhs)
        FunctionType(arg, res) then if rhs is
          FunctionType(arg', res') then
            solve(Cons(Pair(arg', arg), Cons(Pair(res, res'), cs)), freshVar, cache, genExtrCache)
          TypeVariable(name, level, lb, ub) then
            if levelOf(lhs) <= level then
              push(lb, lhs)
              region r in
                let ncs = r.ref cs
                iter(ub, it => foreach(it, b => ncs := Cons(Pair(lhs, b), !ncs); ()))
                solve(!ncs, freshVar, cache, genExtrCache)
            else
              let lhs' = extrude(lhs, true, level, freshVar, genExtrCache())
              solve(Cons(Pair(lhs', rhs), cs), freshVar, cache, genExtrCache)
          else report(lhs, rhs)
        RecordType(flds) then if rhs is
          RecordType(flds') then each(flds', p' =>
            if p' is Pair(n', t') then
              if find(flds, p => if p is Pair(n, t) then n === n') is
                Some(p) then if p is Pair(n, t) then solve(Cons(Pair(t, t'), cs), freshVar, cache, genExtrCache)
                None() then println("Missing field " ~ n' ~ " in " ~ ty2Str(lhs))
            )
          TypeVariable(name, level, lb, ub) then
            if levelOf(lhs) <= level then
              push(lb, lhs)
              region r in
                let ncs = r.ref cs
                iter(ub, it => foreach(it, b => ncs := Cons(Pair(lhs, b), !ncs); ()))
                solve(!ncs, freshVar, cache, genExtrCache)
            else
              let lhs' = extrude(lhs, true, level, freshVar, genExtrCache())
              solve(Cons(Pair(lhs', rhs), cs), freshVar, cache, genExtrCache)
          else report(lhs, rhs)
        TypeVariable(name, level, lb, ub) then
          if levelOf(rhs) <= level then
            push(ub, rhs)
            region r in
              let ncs = r.ref cs
              iter(lb, it => foreach(it, b => ncs := Cons(Pair(b, rhs), !ncs); ()))
              solve(!ncs, freshVar, cache, genExtrCache)
          else
            let rhs' = extrude(rhs, false, level, freshVar, genExtrCache())
            solve(Cons(Pair(lhs, rhs'), cs), freshVar, cache, genExtrCache)


fun freshVar(r, ctx, name, lvl) =
  if (not of hasKey(ctx, name)) then
    add(ctx, name, 1)
    TypeVariable(name, lvl, empty(r), empty(r))
  else
    region r2 in
      let i = r2.ref 0
      let res = r2.ref None()
      whileDo of () =>
        let nn = name ~ toString(!i)
        if (not of hasKey(ctx, nn)) then
          res := Some(TypeVariable(nn, lvl, empty(r), empty(r)))
          add(ctx, nn, 1)
          false
        else
          i := !i + 1
          true
      if !res is
        Some(v) then v
        else error()


fun genHash(r) =
  mkHashMap(r, p => if p is Pair(x, y) then ty2Str(x) ~ " <: " ~ ty2Str(y))

fun genExtrHash(r) =
  () => mkHashMap(r, t => if t is Pair(ty, p) then if p is Pair(lvl, pol) then ty2Str(ty) ~ (if pol then "+_" else "-_") ~ toString(lvl))

fun printBounds(tv) = if tv is
  TypeVariable(name, level, lb, ub) then
    iter of lb, it =>
      foreach of it, b => println("  " ~ ty2Str(b) ~ " <: " ~ ty2Str(tv))
    iter of ub, it =>
      foreach of it, b => println("  " ~ ty2Str(tv) ~ " <: " ~ ty2Str(b))
  else ()

// fun printRes: [outer, R extends outer] -> (Type[R], Type[R]) ->{R} ()
fun printRes(lhs, rhs) =
  println(ty2Str(lhs) ~ " <: " ~ ty2Str(rhs))
  region r in
    let tvs = mkHashMap(r, s => s)
    // fun go: [outer, R extends outer, S extends outer] -> (Type[R], HashMap[Str, Type[R], S]) ->{R | S} ()
    fun go(t, tvs) = if t is
        IntType() then ()
        FunctionType(lhs, rhs) then go(lhs, tvs); go(rhs, tvs)
        RecordType(fields) then each(fields, p => if p is Pair(_, t) then go(t, tvs))
        TypeVariable(name, level, lb, ub) then
          getOrUpdate of tvs, name ~ toString(level), () =>
            region r2 in
              let tmp = empty(r2)
              iter of lb, it => foreach(it, ty => push(tmp, ty))
              iter of ub, it => foreach(it, ty => push(tmp, ty))
            t
          ()
    go(lhs, tvs); go(rhs, tvs)
    println("where: ")
    iterMap of tvs, it =>
      values of it, printBounds

// *** error example

// if we call the `solve` function during the iteration, the `solve` function
// can only handle the cases where no allocation is required (i.e., no type variables)
// fun TODO() = TODO()
// fun wrongSolve(constraints, freshVar, cache, genExtrCache) = if constraints is
//   Nil() then ()
//   Cons(c, cs) then if c is
//     Pair(lhs, rhs) then hasOrUpdate of cache, c, () =>
//       if lhs is
//         IntType() then TODO()
//         FunctionType(arg, res) then TODO()
//         RecordType(flds) then TODO()
//         TypeVariable(name, level, lb, ub) then
//           if levelOf(rhs) <= level then
//             push(ub, rhs)
//             iter(lb, it => foreach(it, b => solve(Cons(Pair(b, rhs), Nil()), freshVar, cache, genExtrCache)))
//             solve(cs, freshVar, cache, genExtrCache)
//           else
//             let rhs' = extrude(rhs, false, level, freshVar, genExtrCache())
//             solve(Cons(Pair(lhs, rhs'), cs), freshVar, cache, genExtrCache)


// The error' version of `solve` function can only be used for constraints without type variables
// wrongSolve(Cons(Pair(IntType, IntType), Nil()))

// Calling the `wrongSolve` function to solve constraints involving type variables will lead to type errors
// region r in
//   let ctx = mkHashMap(r, s => s)
//   let a = freshVar(r, ctx, "a", 1)
//   let b = freshVar(r, ctx, "a", 1)
//   let lhs = a
//   let rhs = b
//   wrongSolve(Cons(Pair(lhs, rhs), Nil()), (n, l) => freshVar(r, ctx, n, l), genHash(r), genExtrHash(r))
//   printRes(lhs, rhs)

// *** examples

region r in
  let ctx = mkHashMap(r, s => s)
  let lhs = FunctionType(IntType(), IntType())
  let rhs = IntType()
  solve(Cons(Pair(lhs, rhs), Nil()), (n, l) => freshVar(r, ctx, n, l), genHash(r), genExtrHash(r))

region r in
  let ctx = mkHashMap(r, s => s)
  let lhs = FunctionType(IntType(), IntType())
  let a = freshVar(r, ctx, "a", 1)
  let rhs = FunctionType(a, a)
  solve(Cons(Pair(lhs, rhs), Nil()), (n, l) => freshVar(r, ctx, n, l), genHash(r), genExtrHash(r))
  printRes(lhs, rhs)


region r in
  let ctx = mkHashMap(r, s => s)
  let lhs = RecordType(Cons(Pair("a", IntType()), Cons(Pair("b", FunctionType(IntType(), IntType())), Nil())))
  let a = freshVar(r, ctx, "a", 1)
  let b = freshVar(r, ctx, "b", 1)
  let rhs = RecordType(Cons(Pair("a", a), Cons(Pair("b", b), Nil())))
  solve(Cons(Pair(lhs, rhs), Nil()), (n, l) => freshVar(r, ctx, n, l), genHash(r), genExtrHash(r))
  printRes(lhs, rhs)


region r in
  let ctx = mkHashMap(r, s => s)
  let a = freshVar(r, ctx, "a", 1)
  let b = freshVar(r, ctx, "b", 1)
  let lhs = a
  let rhs = b
  solve(Cons(Pair(lhs, rhs), Cons(Pair(rhs, lhs), Nil())), (n, l) => freshVar(r, ctx, n, l), genHash(r), genExtrHash(r))
  printRes(lhs, rhs)
  printRes(rhs, lhs)


region r in
  let ctx = mkHashMap(r, s => s)
  let lhs = RecordType(Cons(Pair("a", IntType()), Cons(Pair("b", FunctionType(IntType(), IntType())), Nil())))
  let b = freshVar(r, ctx, "b", 1)
  let rhs = RecordType(Cons(Pair("b", b), Nil()))
  solve(Cons(Pair(lhs, rhs), Nil()), (n, l) => freshVar(r, ctx, n, l), genHash(r), genExtrHash(r))
  printRes(lhs, rhs)


region r in
  let ctx = mkHashMap(r, s => s)
  let a = freshVar(r, ctx, "a", 1)
  let b = freshVar(r, ctx, "b", 1)
  let lhs = FunctionType(IntType(), a)
  let rhs = FunctionType(IntType(), b)
  if a is
    TypeVariable(_, _, _, ub) then push(ub, lhs)
    else error() // impossible
  if b is
    TypeVariable(_, _, lb, _) then push(lb, rhs)
    else error() // impossible
  solve(Cons(Pair(a, b), Nil()), (n, l) => freshVar(r, ctx, n, l), genHash(r), genExtrHash(r))
  printRes(a, b)


region r in
  let ctx = mkHashMap(r, s => s)
  let a = freshVar(r, ctx, "a", 1)
  let lhs = a
  let rhs = FunctionType(IntType(), IntType())
  if a is
    TypeVariable(_, _, lb, ub) then push(lb, IntType())
    else error() // impossible
  solve(Cons(Pair(lhs, rhs), Nil()), (n, l) => freshVar(r, ctx, n, l), genHash(r), genExtrHash(r))


region r in
  let ctx = mkHashMap(r, s => s)
  let a = freshVar(r, ctx, "a", 1)
  let b = freshVar(r, ctx, "b", 2)
  let lhs = FunctionType(IntType(), a)
  let rhs = FunctionType(IntType(), b)
  solve(Cons(Pair(lhs, rhs), Nil()), (n, l) => freshVar(r, ctx, n, l), genHash(r), genExtrHash(r))
  printRes(lhs, rhs)


region r in
  let ctx = mkHashMap(r, s => s)
  let a = freshVar(r, ctx, "a", 1)
  let b = freshVar(r, ctx, "a", 1)
  let lhs = a
  let rhs = b
  solve(Cons(Pair(lhs, rhs), Nil()), (n, l) => freshVar(r, ctx, n, l), genHash(r), genExtrHash(r))
  printRes(lhs, rhs)


region r in
  let ctx = mkHashMap(r, s => s)
  let a = freshVar(r, ctx, "a", 1)
  let b = freshVar(r, ctx, "b", 2)
  let lhs = a
  let rhs = FunctionType(b, FunctionType(b, b))
  solve(Cons(Pair(lhs, rhs), Nil()), (n, l) => freshVar(r, ctx, n, l), genHash(r), genExtrHash(r))
  printRes(lhs, rhs)
"""


examples |> MutMap.insert of
  "GUI.mls"
  name: "GUI"
  source: """
// * This file includes the type checking implementation for the GUI example
// * adapted from https://doi.org/10.5281/zenodo.7990289

class Block
class IO
class Label
class Button

// * So far, our system does not support impure programs.
// * We explicitly insert this handle function at **the top level** to allow primitive effects like IO and Block
fun doPrimitiveEffects: [Res, E] -> (() ->{E | IO | Block} Res) ->{E} Res

fun sleep: (Int) ->{Block} ()

fun mkLabel: (Str) ->{IO} Label
fun mkButton: (Str) ->{IO} Button

fun setText: (Str, Label) ->{IO} ()

// The callback function should not block the execution
// so `E` has an upper bound `~Block`
fun addActionListener: [T, E extends ~Block] -> (() ->{E} (), Button) ->{E | T} ()



// examples

doPrimitiveEffects of () =>
  sleep(42)

doPrimitiveEffects of () =>
  mkLabel("Hello, World!")

doPrimitiveEffects of () =>
  let label = mkLabel("Hello, World!")
  sleep(42)
  setText("Goodbye, World!", label)

// ok! `setText` will not block the execution
doPrimitiveEffects of () =>
  let label = mkLabel("label")
  let button = mkButton("button")
  addActionListener(() => setText("clicked!", label), button)



// error! `sleep` will block the execution and the compiler reject the following program
// doPrimitiveEffects of () =>
//   let label = mkLabel("label")
//   let button = mkButton("button")
//   addActionListener(() => sleep(1), button)
"""


examples |> MutMap.insert of
  "Interpreter.mls"
  name: "Interpreter"
  source: """
// * This file includes the implementation for an interpreter and a compiler for a small toy programming language.
// * Adapted from https://doi.org/10.5281/zenodo.7990289


class List[T] with
  constructor
    Nil
    Cons(x: T, xs: List[out T])


fun concat: [T] -> (List[out T], List[out T]) -> List[out T]
fun (;) seq(_, res) = res
fun error: Nothing


// * Arithmetical Expression
class AExp with
  constructor
    Cst(v: Int)
    Plus(lhs: AExp, rhs: AExp)
    Minus(lhs: AExp, rhs: AExp)
    Times(lhs: AExp, rhs: AExp)
    IfThenElse(cond: BExp, cons: AExp, alts: AExp)


// * Boolean Expression
class BExp with
  constructor
    True
    False
    Not(v: BExp)
    Conj(lhs: BExp, rhs: BExp)
    Disj(lhs: BExp, rhs: BExp)
    Eq(lhs: AExp, rhs: AExp)
    Neq(lhs: AExp, rhs: AExp)


// * Evaliation functions

fun evalBExp: BExp -> Bool

fun evalAExp(e) = if e is
  Cst(v) then v
  Plus(e1, e2) then evalAExp(e1) + evalAExp(e2)
  Minus(e1, e2) then evalAExp(e1) - evalAExp(e2)
  Times(e1, e2) then evalAExp(e1) * evalAExp(e2)
  IfThenElse(cond, e1, e2) then
    if evalBExp(cond) then evalAExp(e1) else evalAExp(e2)


fun evalBExp(e) = if e is
  True then true
  False then false
  Not(e) then evalBExp(e) is false
  Conj(e1, e2) then evalBExp(e1) && evalBExp(e2)
  Disj(e1, e2) then evalBExp(e1) || evalBExp(e2)
  Eq(e1, e2) then evalAExp(e1) == evalAExp(e2)
  Neq(e1, e2) then evalAExp(e1) != evalAExp(e2)


// * Examples

evalAExp(Cst(42))
evalAExp(Plus(Cst(42), Cst(21)))
evalAExp(Minus(Cst(42), Cst(21)))
evalAExp(IfThenElse(True, Cst(1), Cst(2)))
evalAExp(IfThenElse(Neq(Cst(1), Cst(2)), Cst(42), Cst(21)))

evalBExp(True)
evalBExp(Not(True))
evalBExp(Conj(True, False))
evalBExp(Disj(True, False))
evalBExp(Neq(Cst(1), Cst(2)))


// * Instruction
class Inst with
  constructor
    Push(v: Int)
    Add
    Sub
    Mul
    Neg
    And
    Or
    Cmp
    Branch(cons: List[out Inst], alts: List[out Inst])


// * Compilation functions

fun compileBExp: BExp -> List[out Inst]

fun compileAExp(e) = if e is
  Cst(v) then Cons(Push(v), Nil)
  Plus(e1, e2) then
    let is1 = compileAExp(e1) in
      let is2 = compileAExp(e2) in
        concat(concat(is2, is1), Cons(Add, Nil))
  Minus(e1, e2) then
    let is1 = compileAExp(e1) in
      let is2 = compileAExp(e2) in
        concat(concat(is2, is1), Cons(Sub, Nil))
  Times(e1, e2) then
    let is1 = compileAExp(e1) in
      let is2 = compileAExp(e2) in
        concat(concat(is2, is1), Cons(Mul, Nil))
  IfThenElse(e1, e2, e3) then
    let is1 = compileBExp(e1) in
      let is2 = compileAExp(e2) in
        let is3 = compileAExp(e3) in
          concat(is1, Cons(Branch(is2, is3), Nil))
  

fun compileBExp(e) = if e is
  True then Cons(Push(1), Nil)
  False then Cons(Push(0), Nil)
  Not(e) then concat(compileBExp(e), Cons(Neg, Nil))
  Conj(e1, e2) then
    let is1 = compileBExp(e1) in
      let is2 = compileBExp(e2) in
        concat(concat(is2, is1), Cons(And, Nil))
  Disj(e1, e2) then
    let is1 = compileBExp(e1) in
      let is2 = compileBExp(e2) in
        concat(concat(is2, is1), Cons(Or, Nil))
  Eq(e1, e2) then
    let is1 = compileAExp(e1) in
      let is2 = compileAExp(e2) in
        concat(concat(is2, is1), Cons(Cmp, Nil))
  Neq(e1, e2) then
    let is1 = compileAExp(e1) in
      let is2 = compileAExp(e2) in
        concat(concat(is2, is1), Cons(Neg, Cons(Cmp, Nil)))


// * Examples

compileAExp(Cst(42))
compileAExp(Plus(Cst(42), Cst(21)))
compileAExp(Minus(Cst(42), Cst(21)))
compileAExp(IfThenElse(True, Cst(1), Cst(2)))
compileAExp(IfThenElse(Neq(Cst(1), Cst(2)), Cst(42), Cst(21)))
compileBExp(True)
compileBExp(Not(True))
compileBExp(Conj(True, False))
compileBExp(Disj(True, False))
compileBExp(Neq(Cst(1), Cst(2)))


// So far, we have not supported nested patterns.
// This helper function is for the following pattern matching:
// `if lst is Cons(x, Cons(y, ys)) then f(x, y, ys) else g()`
fun matchTwo(lst, f, g) = if lst is
  Nil then g()
  Cons(x, xs) then
    if xs is
      Nil then g()
      Cons(y, ys) then f(x, y, ys)


// * Instruction evaluation

fun evalInst(insts, stack) = if insts is
  Nil then
    if stack is
      Cons(x, xs) then
        if xs is
          Nil then x
          Cons(_, _) then error
      Nil then error
  Cons(inst, rest) then if inst is
    Push(i) then evalInst(rest, Cons(i, stack))
    Add then matchTwo(stack, (x, y, r) => evalInst(rest, Cons(x + y, r)), () => error)
    Sub then matchTwo(stack, (x, y, r) => evalInst(rest, Cons(x - y, r)), () => error)
    Mul then matchTwo(stack, (x, y, r) => evalInst(rest, Cons(x * y, r)), () => error)
    Neg then if stack is
      Nil then error
      Cons(x, xs) then evalInst(rest, Cons(if x == 0 then 1 else 0, xs))
    And then
      matchTwo(stack, (x, y, r) => evalInst(rest, Cons(if x != 0 && y != 0 then 1 else 0, r)), () => error)
    Or then
      matchTwo(stack, (x, y, r) => evalInst(rest, Cons(if x != 0 || y != 0 then 1 else 0, r)), () => error)
    Cmp then
      matchTwo(stack, (x, y, r) => evalInst(rest, Cons(if x == y then 1 else 0, r)), () => error)
    Branch(is1, is2) then if stack is
      Nil then error
      Cons(x, xs) then
        if x != 0 then evalInst(is1, xs)
        else evalInst(is2, xs)


// * Examples

evalInst(compileAExp(Cst(42)), Nil)
evalInst(compileAExp(Plus(Cst(42), Cst(21))), Nil)
evalInst(compileAExp(Minus(Cst(42), Cst(21))), Nil)
evalInst(compileAExp(IfThenElse(True, Cst(1), Cst(2))), Nil)
evalInst(compileAExp(IfThenElse(Neq(Cst(1), Cst(2)), Cst(42), Cst(21))), Nil)
evalInst(compileAExp(IfThenElse(Eq(Cst(1), Cst(2)), Cst(42), Times(Cst(21), Cst(82)))), Nil)
"""

examples |> MutMap.insert of
  "Exception.mls"
  name: "Exception"
  source: """
// * This files includes the exception handling extension of InvalML.

class Exc[T, R]

fun (;) seq(_, res) = res

fun raise: [T, P] -> (Exc[T, P], T) ->{P} Nothing
fun hdle: [Res, E, T] -> ([P] -> (Exc[T, P]) ->{E | P} Res, T ->{E} Res) ->{E} Res
fun print: Str -> Unit


hdle(e => raise(e, "oops!"), msg => print(msg))

// Error! The payload type is incorrect.
// hdle(e => raise(e, 42), msg => print(msg))


fun div(x, y) =
  hdle(e => if y is 0 then raise(e, "div-by-zero!") else x / y, msg => print(msg); 0)


hdle(e1 => hdle(e2 => raise(e1, "oops!"), msg => print(msg)), msg => print(msg))
hdle(e1 => hdle(e2 => raise(e2, "oops!"), msg => print(msg)), msg => print(msg))
hdle(e1 => hdle(e2 => raise(e1, "oops!"), msg => raise(e1, msg)), msg => print(msg))


// Error! The exception handler cannot be leaked.
// let h = hdle(e => e, msg => print(msg))
// raise(h, "leaked!")
"""

examples |> MutMap.insert of
  "StackMM.mls"
  name: "Stack-Based Memory Management"
  source: """
// * This files includes the stack-based memory management extension of InvalML.

class Stack[S, R]
class StackRef[T, R]

fun (;) seq(_, res) = res

fun allocStack: [E, Res] -> ([S, R] -> Stack[S, R] ->{S | R | E} Res) ->{E} Res
fun alloc: [S, R, A] -> (Stack[S, R], A) ->{S} StackRef[A, R]
fun read: [R, A] -> StackRef[A, R] ->{R} A
fun write: [R, A] -> (StackRef[A, R], A) ->{R} ()
fun push: [Res, S, R, E extends ~S] -> (Stack[S, R], [U] -> Stack[U, R] -> {U | R | E} Res) ->{E | R | S} Res


allocStack of s =>
  let r1 = alloc(s, 42)
  let r2 = alloc(s, 0)
  write(r1, 1)
  read(r2)


allocStack of s1 =>
  let r1 = alloc(s1, 42)
  let r2 = alloc(s1, 0)
  write(r1, 1)
  read(r2)
  push of s1, s2 =>
    let r3 = alloc(s2, 0) in read(r3)


// Error! After pusing `s1`, one can not allocate references on it.
// allocStack of s1 =>
//   let r1 = alloc(s1, 42)
//   let r2 = alloc(s1, 0)
//   write(r1, 1)
//   read(r2)
//   push of s1, s2 =>
//     let r3 = alloc(s1, 0) in read(r3)
"""

examples |> MutMap.insert of
  "Staging.mls"
  name: "Scope-Safe Metaprogramming"
  source: """
// * This files includes the metaprogramming extension of InvalML.

// Type `CodeBase[T, R, S]`:
//   T: type of quoted expression
//   R: union of free variables' skolems
//   S: can be either top or bot. `CodeBase[T, R, bot]` is equivalent to `Var[T, R]`; `CodeBase[T, R, top]` is equivalent to `Code[T, R]`.

fun power: [C] -> CodeBase[out Num, out C, out Any] -> Int -> CodeBase[out Num, out C, out Any]
fun power(x) = case
  0 then `1.0
  n then x `*. power(x)(n - 1)
power

fun id: [A] -> A -> A
fun id(x) = x


run(x `=> id(x) `* x)


fun assertNotZero: [C] -> CodeBase[out Num, out C, out Any] -> CodeBase[out Num, out C, out Any]
fun assertNotZero(x) =
  `if (x `== `0.0) then `error else x
let checkedDiv = x `=> y `=> x `/. (assertNotZero(y))
run(checkedDiv)



fun show: [T] -> CodeBase[out T, out Any, out Any] -> Str = s => "debug"

fun inc(dbg) =
  x `=> let c = x `+ `1 in let t = dbg(c) in c

inc(c => log(show(c)))

fun body_naive: [T, C] -> (CodeBase[out Int, out T, out Any], CodeBase[out Int, out C, out Any]) -> Int -> CodeBase[out Int, out T | C, out Any]
fun body_naive(x, y) = case
  0 then x
  1 then y
  n then body_naive(y, x `+ y)(n - 1)
fun gib_naive(n) =
  (x, y) `=> body_naive(x, y)(n)
let gn5 = run(gib_naive(5))


// Wrong version! There is an unexpected extrusion in `bind`, making `bind` unusable.
// fun bind(rhs, k) = `let x = rhs `in k(x)
// fun body: [G] -> (CodeBase[out Int, out G, out Any], CodeBase[out Int, out G, out Any]) -> Int -> CodeBase[out Int, out G, out Any]
// fun body(x, y) = case
//   0 then x
//   1 then y
//   n then bind of x `+ y, (z => body(y, z)(n - 1))


fun bind: [G] -> (CodeBase[out Int, out G, out Any], [C] -> CodeBase[out Int, out C, out Any] -> CodeBase[out Int, out C | G, out Any]) -> CodeBase[out Int, out G, out Any]
fun bind(rhs, k) = `let x = rhs `in k(x)

fun body: [G] -> (CodeBase[out Int, out G, out Any], CodeBase[out Int, out G, out Any]) -> Int -> CodeBase[out Int, out G, out Any]
fun body(x, y) = case
  0 then x
  1 then y
  n then bind of x `+ y, (z => body(y, z)(n - 1))

fun gib(n) = (x, y) `=> body(x, y)(n)
let g5 = run(gib(5))
g5
"""

examples |> MutMap.insert of
  "DynamicProgramming.mls"
  name: "Dynamic Programming"
  source: """
// * In this file, we implement a select function to select some interviewees from the candidate list within a limited budget,
// * such that the sum of the selected interviewees' estimation scores is highest,
// * which is a classical Knapsack problem.

// *** infrastructures

class Option[A] with
  constructor
    Some(x: A)
    None


class ArrayList[T, out R]
class Iter[T, out R]
class Array2D[T, out R]

class Interviewee with
  constructor
    Itv(score: Int, salary: Int)

fun (;) seq(_, res) = res
fun toString: Any -> Str
fun concat: (Str, Str) -> Str
fun println: Str -> ()

fun
  empty:   [A, R] -> Region[out R] ->{R} ArrayList[A, out R]
  push:    [A, R] -> (ArrayList[A, out R], A) ->{R} ()
  iter: [Res, R, E extends ~R, T] ->
    (ArrayList[T, out R], [S] -> Iter[T, S] ->{S | E} Res) ->{E | R} Res
  revIter: [outer, Res, R, E extends ~R, T] ->
    (ArrayList[T, out R], [S extends ~outer] -> Iter[T, S] ->{S | E} Res) ->{E | R} Res
  next: [T, S] -> Iter[T, S] ->{S} Option[T]
  len:  [A, R] -> (ArrayList[A, out R]) ->{R} Int
  whileDo: [R] -> (() ->{R} Bool) ->{R} ()
  init:    [A, R] -> (Region[out R], Int, Int, A) ->{R} Array2D[A, R]
  update: [A, R] -> (Array2D[A, out R], Int, Int, A) ->{R} ()
  get: [A, R] -> (Array2D[A, out R], Int, Int) ->{R} A
  max: (Int, Int) -> Int


// *** implementation

fun format(it) =
  if it is Itv(score, salary) then
    concat("interviewee, score: ", concat(toString(score), concat("salary", toString(salary))))


fun printAll(arr) =
  iter of arr, it =>
    whileDo of () =>
      if next(it) is
        Some(x) then println(format(x)); true
        None then false


// fun select: [outer, R1 extends outer, R2 extends ~R1] -> (ArrayList[Interviewee, R1], Int, ArrayList[Interviewee, R2]) ->{R1 | R2} Int
fun select(interviewees, budget, results) =
  region r in
    let size = len(interviewees), let i = r.ref 1
    let dp = init(r, size + 1, budget + 1, 0)
    iter of interviewees, it => whileDo of () =>
      if next(it) is
        Some(itv) then if itv is Itv(score, salary) then
          let j = r.ref 0
          whileDo of () =>
            if !j < salary then update(dp, !i, !j, get(dp, !i - 1, !j))
            else
              let p = get(dp, !i - 1, !j - salary), let np = get(dp, !i - 1, !j)
              update(dp, !i, !j, max of np, p + score)
            j := !j + 1; !j <= budget
          i := !i + 1
          true
        None then false
    i := size
    let rest = r.ref budget
    revIter of interviewees, it =>
      whileDo of () =>
        if next(it) is
          Some(itv) then if itv is Itv(score, salary) then
            if get(dp, !i, !rest) == get(dp, !i - 1, !rest - salary) + score
                do push(results, itv); rest := !rest - salary
            i := !i - 1
            true
          None then false
    get(dp, size, budget)

// *** wrong version
// fun wrongSelect(interviewees, budget, results) =
//   region r in
//     let size = len(interviewees), let i = r.ref 1
//     let dp = init(r, size + 1, budget + 1, 0)
//     iter of interviewees, it =>
//       whileDo of () =>
//         if next(it) is
//           Some(itv) then if itv is Itv(score, salary) then
//             let j = r.ref 0
//             whileDo of () =>
//               if !j < salary then update(dp, !i, !j, get(dp, !i - 1, !j))
//               else
//                 let p = get(dp, !i - 1, !j - salary), let np = get(dp, !i - 1, !j)
//                 update(dp, !i, !j, max of np, p + score)
//               j := !j + 1; !j <= budget
//             i := !i + 1
//             true
//           None then false
//     i := size
//     let rest = r.ref budget
//     revIter of interviewees, it =>
//       whileDo of () =>
//         if next(it) is
//           Some(itv) then if itv is Itv(score, salary) then
//             if get(dp, !i, !rest) == get(dp, !i - 1, !rest - salary) + score
//                 do push(interviewees, itv); rest := !rest - salary
//             i := !i - 1
//             true
//           None then false
//     get(dp, size, budget)

// region r in
//   let interviewees = empty(r)
//   push(interviewees, Itv(20, 3000))
//   push(interviewees, Itv(50, 1000))
//   push(interviewees, Itv(30, 1000))
//   region r2 in
//     let results = empty(r2)
//     let m = wrongSelect(interviewees, 4000, results)
//     printAll(results)
//     m

// *** example
region r in
  let interviewees = empty(r)
  push(interviewees, Itv(40, 10))
  push(interviewees, Itv(60, 20))
  push(interviewees, Itv(120, 30))
  push(interviewees, Itv(70, 20))
  println("all interviewees:")
  printAll(interviewees)
  region r2 in
    let results = empty(r2)
    let m = select(interviewees, 60, results)
    println("candidates:")
    printAll(results)
    m
"""
