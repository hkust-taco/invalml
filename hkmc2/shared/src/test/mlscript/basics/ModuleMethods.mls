module M
module MM[T]



// Parameters

:e
fun f(m: M)
//│ ╔══[ERROR] Unexpected moduleful reference.
//│ ║  l.9: 	fun f(m: M)
//│ ║       	         ^
//│ ╙── Non-module parameter must have a non-module type.

fun f(m)

:e
f(M)
//│ ╔══[ERROR] Unexpected moduleful reference.
//│ ║  l.18: 	f(M)
//│ ║        	  ^
//│ ╙── Module argument passed to a non-module parameter.

f(42)

:e
fun f(module m)
//│ ╔══[ERROR] Module parameter must have explicit type.
//│ ║  l.27: 	fun f(module m)
//│ ╙──      	             ^

fun f(module m: M)

f(42)

f(M)

:e
fun f[T](module m: T)
//│ ╔══[ERROR] Expected a module, found non-moduleful reference.
//│ ║  l.39: 	fun f[T](module m: T)
//│ ║        	                   ^
//│ ╙── Module parameter must have a module type.

fun f[T](module m: MM[T])

f[Int](42)


f[Int](MM[Int])



// Results

fun assertM(module m: M)
fun assertNonM(m)
fun assertMM[T](module m: MM[T])
fun assertNonMM[T](m)

:e
fun f() = M
//│ ╔══[ERROR] Unexpected moduleful reference.
//│ ║  l.62: 	fun f() = M
//│ ║        	          ^
//│ ╙── Function must be marked as returning a 'module' in order to return a module.

:e
fun f(): M = M
//│ ╔══[ERROR] Unexpected moduleful reference.
//│ ║  l.69: 	fun f(): M = M
//│ ║        	         ^
//│ ╙── Function must be marked as returning a 'module' in order to have a module return type.
//│ ╔══[ERROR] Unexpected moduleful reference.
//│ ║  l.69: 	fun f(): M = M
//│ ║        	             ^
//│ ╙── Function must be marked as returning a 'module' in order to return a module.

fun f(): module M = M

:e
assertNonM(f())
//│ ╔══[ERROR] Unexpected moduleful application.
//│ ║  l.82: 	assertNonM(f())
//│ ║        	           ^^^
//│ ╙── Module argument passed to a non-module parameter.

assertM(f())

:e
fun f4[T](): module T = M
//│ ╔══[ERROR] Expected a module, found non-moduleful reference.
//│ ║  l.91: 	fun f4[T](): module T = M
//│ ║        	                    ^
//│ ╙── Function marked as returning a 'module' must have a module return type.

fun f[T](): module MM[T] = MM[T]

:e
assertNonM(f[Int]())
//│ ╔══[ERROR] Unexpected moduleful application.
//│ ║  l.100: 	assertNonM(f[Int]())
//│ ║         	           ^^^^^^^^
//│ ╙── Module argument passed to a non-module parameter.

assertM(f[Int]())


:todo
:e
fun f3() = return M
//│ ╔══[ERROR] Unexpected moduleful reference.
//│ ║  l.111: 	fun f3() = return M
//│ ╙──       	                  ^

:todo
:e
fun f3() = (() => M)()
//│ ╔══[ERROR] Unexpected moduleful reference.
//│ ║  l.118: 	fun f3() = (() => M)()
//│ ╙──       	                  ^

// * [test:T4]
:todo
:e
:effectHandlers
fun f3() = (() => return M)()
//│ ╔══[ERROR] Unexpected moduleful reference.
//│ ║  l.127: 	fun f3() = (() => return M)()
//│ ╙──       	                         ^



// Parameters Modulefulness

:e
fun f(module m: M) = m
//│ ╔══[ERROR] Unexpected moduleful reference.
//│ ║  l.137: 	fun f(module m: M) = m
//│ ║         	                     ^
//│ ╙── Function must be marked as returning a 'module' in order to return a module.

fun f(module m: M): module M = m



// Val Bindings

:e
val v = M
//│ ╔══[ERROR] Unexpected moduleful reference.
//│ ║  l.150: 	val v = M
//│ ║         	        ^
//│ ╙── Value must be marked as returning a 'module' in order to return a module.

val v: module M = M



// *Module* Methods

module N with
  fun foo(): module M = M
  fun bar(module m: M): module M = foo()

N.bar(M)

// Methods / Fields

:e
class C with
  fun foo: module M = M
  val bar: module M = M
//│ ╔══[ERROR] Function returning modules should not be a class member.
//│ ║  l.172: 	  fun foo: module M = M
//│ ╙──       	                  ^^^^^
//│ ╔══[ERROR] Value returning modules should not be a class member.
//│ ║  l.173: 	  val bar: module M = M
//│ ╙──       	                  ^^^^^
