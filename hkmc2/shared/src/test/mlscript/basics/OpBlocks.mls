:js


2
  + 2
//│ = 4

2
  + 2
  + 2
//│ = 6

2
  + 1
  * 2
//│ = 6

2
  + 1
    * 2
//│ = 4

// * Note: indented newlines starting with an operator are always treated as continuations
// * of the previous line, without any implicit grouping of the indented parts,
// * explaining the result below.
// * I originally tried to make such indented operators implicitly group subexpressions,
// * but it turned out to be just too strange and confusing; the simple rule above seems better.
2
    + 1
  * 2
//│ = 4


2 + 2
//│ = 4

1 + 2
  * 3
//│ = 7

1 + 2
  * 2
  * 2
//│ = 9

1 + 2
  * 3 + 1
//│ = 8

2 *
  3 + 1
//│ = 8

2
  *
    3 + 1
//│ = 8

2
  *
  3 + 1
//│ = 7

// :pe
2
  *
3 + 1
//│ = 7

1 + 1
  *
2
//│ = 3

1 + 1
*
2
//│ = 4

// Parses as: 1 + (1 * 3) + 1
1 + 1
  *
3 + 1
//│ = 5

// :dp
1 + 2
  * 3
    + 1
//│ = 8

:pe
1 + 2
  * 2
    + 1
  * 3
//│ ╔══[PARSE ERROR] Unexpected indented block in this operator split inner position
//│ ║  l.95: 	    + 1
//│ ║        	^^^^^^^
//│ ║  l.96: 	  * 3
//│ ║        	^^
//│ ╟── Note: the operator split starts here
//│ ║  l.94: 	  * 2
//│ ╙──      	  ^
//│ = 12

:pe
1 + 2
  * 2 +
    1
  * 3
//│ ╔══[PARSE ERROR] Operator cannot be used inside this operator split
//│ ║  l.109: 	  * 2 +
//│ ║         	      ^
//│ ╟── as it has lower precedence than the splitting operator here
//│ ║  l.109: 	  * 2 +
//│ ╙──       	  ^
//│ = 19

:pe
1 + 2
  * 2
  * 3
    + 1
//│ ╔══[PARSE ERROR] Unexpected indented block in this operator split inner position
//│ ║  l.124: 	    + 1
//│ ║         	^^^^
//│ ╟── Note: the operator split starts here
//│ ║  l.122: 	  * 2
//│ ╙──       	  ^
//│ = 6

1 + 2 {* 3 {+ 1}}
//│ = 8

1 + 2
  * 3
  + 1
//│ = 8

:pe
1 + 2
  * 3 + 1
  * 3
//│ ╔══[PARSE ERROR] Operator cannot be used inside this operator split
//│ ║  l.143: 	  * 3 + 1
//│ ║         	      ^
//│ ╟── as it has lower precedence than the splitting operator here
//│ ║  l.143: 	  * 3 + 1
//│ ╙──       	  ^
//│ = 28

// :pe
1 + 2
  * 3
  * 3 + 1
//│ = 8

1 + 2
  + 3
  * 3 + 1
//│ = 19


:w
1 >
  1
  0
//│ ╔══[WARNING] Pure expression in statement position
//│ ║  l.167: 	  1
//│ ╙──       	  ^
//│ = true


let f = x => x * 2
//│ f = [function f]

2
  + 1
  |> f
//│ = 6

f
  of 1
//│ = 2

f
  |> id
  of 1
//│ = 2


fun f(x)(y) = x + y

f
  of 1
  of 2
//│ = 3

f
  |> id
  of 1
  of 2
//│ = 3


fun f(a)(b) = [a, b]
fun g(a, b) = [a, b]

f of
    g of
      1
      2
  of 3
//│ = [[1, 2], 3]

(f of
  g of
    1
    2
) of 3
//│ = [[1, 2], 3]


fun f(x) = x
  + 1

f(123)
//│ = 124


fun f(x) = x
  * 2
  + 1

f(123)
//│ = 247


:pt
fun f(x) = x
  + 1
  * 2
//│ Parsed tree:
//│ TermDef:
//│   k = Fun
//│   head = App:
//│     lhs = Ident of "f"
//│     rhs = Tup of Ls of 
//│       Ident of "x"
//│   rhs = S of OpSplit:
//│     lhs = Ident of "x"
//│     ops_rhss = Ls of 
//│       OpApp:
//│         lhs = SplitPoint
//│         op = Ident of "+"
//│         rhss = Ls of 
//│           IntLit of 1
//│       OpApp:
//│         lhs = SplitPoint
//│         op = Ident of "*"
//│         rhss = Ls of 
//│           IntLit of 2

f(123)
//│ = 248


:pt
fun f(x) = x
  + 1
    * 2
//│ Parsed tree:
//│ TermDef:
//│   k = Fun
//│   head = App:
//│     lhs = Ident of "f"
//│     rhs = Tup of Ls of 
//│       Ident of "x"
//│   rhs = S of OpApp:
//│     lhs = Ident of "x"
//│     op = Ident of "+"
//│     rhss = Ls of 
//│       OpApp:
//│         lhs = IntLit of 1
//│         op = Ident of "*"
//│         rhss = Ls of 
//│           IntLit of 2

f(123)
//│ = 125


fun f(x) = x { + 1, * 2 }

f(3)
//│ = 8


:pt
fun f(x) = if x
  == 0 then "a"
  > 1 then "b"
//│ Parsed tree:
//│ TermDef:
//│   k = Fun
//│   head = App:
//│     lhs = Ident of "f"
//│     rhs = Tup of Ls of 
//│       Ident of "x"
//│   rhs = S of IfLike:
//│     kw = keyword 'if'
//│     kwLoc = N
//│     split = OpSplit:
//│       lhs = Ident of "x"
//│       ops_rhss = Ls of 
//│         InfixApp:
//│           lhs = OpApp:
//│             lhs = SplitPoint
//│             op = Ident of "=="
//│             rhss = Ls of 
//│               IntLit of 0
//│           kw = keyword 'then'
//│           rhs = StrLit of "a"
//│         InfixApp:
//│           lhs = OpApp:
//│             lhs = SplitPoint
//│             op = Ident of ">"
//│             rhss = Ls of 
//│               IntLit of 1
//│           kw = keyword 'then'
//│           rhs = StrLit of "b"

f(0)
//│ = "a"

:re
f(1)
//│ ═══[RUNTIME ERROR] Error: match error

f(2)
//│ = "b"


fun f(x) = if x
  > 0 then "a"
  is 0 then "b"

f(0)
//│ = "b"

f(1)
//│ = "a"


// :pt
:todo // TODO: juxtaposition splits?
:e
fun f(x) = if x
  foo(A) then a
  bar(B) then b
//│ ╔══[ERROR] Unrecognized term split (juxtaposition).
//│ ║  l.359: 	fun f(x) = if x
//│ ║         	              ^
//│ ║  l.360: 	  foo(A) then a
//│ ╙──       	^^


if 0
  is 0 then "a"
//│ = "a"

if 0
  is 0 then "a"
  is 1 then "b"
//│ = "a"

x => if x
  is 0 then "a"
//│ = [function]

x => if x
  is 0 then "a"
  is 1 then "b"
//│ = [function]


fun f(x) = if x
  is 0 then "a"
  is 1 then "b"

f(0)
//│ = "a"

f(1)
//│ = "b"


:pt
id of id of 1
//│ Parsed tree:
//│ App:
//│   lhs = Ident of "id"
//│   rhs = Tup of Ls of 
//│     App:
//│       lhs = Ident of "id"
//│       rhs = Tup of Ls of 
//│         IntLit of 1
//│ = 1

// :dp
f of 1
//│ = "b"

