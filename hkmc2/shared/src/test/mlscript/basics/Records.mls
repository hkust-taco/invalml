:js


// * Note that this currently denotes unit, not an empty record...
// * (we could make them the same thing) 

{}

let r = {}
//│ r = ()


{1}
//│ = 1

:w
{1, 2}
//│ ╔══[WARNING] Pure expression in statement position
//│ ║  l.17: 	{1, 2}
//│ ╙──      	 ^
//│ = 2

{foo: 1}
//│ = {foo: 1}


let rcd = { foo: 1, bar: "..." }
//│ rcd = {foo: 1, bar: "..."}

[rcd.foo, rcd.bar]
//│ = [1, "..."]

typeof(rcd)
//│ = "object"


// * Should we allow this syntax?

let rcd = (foo: 1, bar: "...")
//│ rcd = {foo: 1, bar: "..."}

[rcd.foo, rcd.bar]
//│ = [1, "..."]

let rcd = (
  foo: 1
  bar: "..."
)
//│ rcd = {foo: 1, bar: "..."}

let rcd =
  foo: 1
  bar:
    "..."
//│ rcd = {foo: 1, bar: "..."}

[rcd.foo, rcd.bar]
//│ = [1, "..."]

print <|
  foo: 1
  bar:
    "..."
//│ > {foo: 1, bar: "..."}


// * But not this syntax...

:e
:fixme
let rcd =
  foo = 1
  bar =
    "..."
//│ ╔══[ERROR] Name not found: foo
//│ ║  l.72: 	  foo = 1
//│ ╙──      	  ^^^
//│ ╔══[ERROR] Name not found: bar
//│ ║  l.73: 	  bar =
//│ ╙──      	  ^^^
//│ /!!!\ Uncaught error: hkmc2.InternalError: Not in scope: rcd (class hkmc2.semantics.VarSymbol)


// * How about this syntax?

:todo
let rcd = new with
  foo = 1
  bar =
    "..."
//│ ╔══[ERROR] Name not found: foo
//│ ║  l.88: 	  foo = 1
//│ ╙──      	  ^^^
//│ ╔══[ERROR] Name not found: bar
//│ ║  l.89: 	  bar =
//│ ╙──      	  ^^^
//│ rcd = $anon


id of (x: 1)
//│ = {x: 1}

id of { x: 1 }
//│ = {x: 1}

id of ({ x: 1 })
//│ = {x: 1}


id of ({ x: 1, y: 2 })
//│ = {x: 1, y: 2}

id of (x: 1, y: 2)
//│ = {x: 1, y: 2}

id of { x: 1, y: 2 }
//│ = {x: 1, y: 2}



:silent
import "../../mlscript-compile/Iter.mls"
let graphics = new Set of tuple of
  "circle", "ellipse", "image", "line", "path"
  "polygon", "polyline", "rect", "text", "use"

fun showProps(x, y, props) = Object.entries(props)
  Iter.mapping of case
    ["x", x'] then "x: " + (x + x')
    ["y", y'] then "y: " + (y + y')
    [k, v] then k + ": " + v
  Iter.joined(", ")

fun output(i, s) = print of "  ".repeat(i) + s

fun t(kind, props) =
  if graphics.has(kind) then
    (args) => output of args.i, kind + " " + showProps(args.x, args.y, props)
  else
    (...children) => (args) =>
      output of args.i, kind + " " + showProps(args.x, args.y, props) + " with"
      children Iter.each of child => child of
        x: args.x + props.x
        y: args.y + props.y
        i: args.i + 1

let display = t("group", x: 20, y: 20) of
  t("circle", x: 30, y: 30, r: 42)
  t("rect", x: 40, y: 40, width: 80, height: 90)
  t("ellipse", x: 50, y: 50, rx: 40, ry: 60)
//│ display = [function]

display(x: 11, y: 22, i: 2)
//│ >     group x: 31, y: 42 with
//│ >       circle x: 61, y: 72, r: 42
//│ >       rect x: 71, y: 82, width: 80, height: 90
//│ >       ellipse x: 81, y: 92, rx: 40, ry: 60

let display = t("group", x: 0, y: 0) of
  t("circle", x: 10, y: 10, r: 42)
//│ display = [function]

display(x: 88, y: 99, i: 0)
//│ > group x: 88, y: 99 with
//│ >   circle x: 98, y: 109, r: 42

:todo
t("group")
//│ ╔══[ERROR] Expected 2 arguments, got 1
//│ ║  l.168: 	t("group")
//│ ╙──       	 ^^^^^^^^^
//│ ═══[RUNTIME ERROR] Error: Function 't' expected 2 arguments but got 1

:todo
t("group")
//│ ╔══[ERROR] Expected 2 arguments, got 1
//│ ║  l.175: 	t("group")
//│ ╙──       	 ^^^^^^^^^
//│ ═══[RUNTIME ERROR] Error: Function 't' expected 2 arguments but got 1

:todo
let empty = Object.create of null
//│ empty = [object]

t("group", empty)
//│ = [function]
