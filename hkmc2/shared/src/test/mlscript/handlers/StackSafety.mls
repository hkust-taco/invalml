:js

// sanity check
:expect 5050
fun sum(n) =
  if n == 0 then 0
  else
    n + sum(n - 1)
sum(100)
//│ = 5050

// preserve tail calls
// MUST see "return hi1(tmp)" in the output
:stackSafe 5
:effectHandlers
:expect 0
:sjs
fun hi(n) =
  if n == 0 then 0
  else hi(n - 1)
hi(0)
//│ JS (unsanitized):
//│ let hi, res, $_stack$_safe$_body$_;
//│ hi = function hi(n) {
//│   let scrut, tmp, stackDelayRes, Cont$func$hi$1;
//│   Cont$func$hi$1 = function Cont$func$hi$(pc1) {
//│     return new Cont$func$hi$.class(pc1);
//│   };
//│   Cont$func$hi$1.class = class Cont$func$hi$ extends runtime.FunctionContFrame.class {
//│     constructor(pc) {
//│       let tmp1;
//│       tmp1 = super(null);
//│       this.pc = pc;
//│     }
//│     resume(value$) {
//│       if (this.pc === 0) {
//│         stackDelayRes = value$;
//│       }
//│       contLoop: while (true) {
//│         if (this.pc === 0) {
//│           scrut = n == 0;
//│           if (scrut === true) {
//│             return 0
//│           } else {
//│             tmp = n - 1;
//│             this.pc = 2;
//│             continue contLoop;
//│           }
//│           this.pc = 1;
//│           continue contLoop;
//│         } else if (this.pc === 1) {
//│           break contLoop;
//│         } else if (this.pc === 2) {
//│           runtime.stackDepth = runtime.stackDepth + 1;
//│           return hi(tmp)
//│         }
//│         break;
//│       }
//│     }
//│     toString() { return "Cont$func$hi$(" + globalThis.Predef.render(this.pc) + ")"; }
//│   };
//│   stackDelayRes = runtime.checkDepth();
//│   if (stackDelayRes instanceof runtime.EffectSig.class) {
//│     stackDelayRes.contTrace.last.next = new Cont$func$hi$1.class(0);
//│     stackDelayRes.contTrace.last = stackDelayRes.contTrace.last.next;
//│     return stackDelayRes
//│   }
//│   scrut = n == 0;
//│   if (scrut === true) {
//│     return 0
//│   } else {
//│     tmp = n - 1;
//│     runtime.stackDepth = runtime.stackDepth + 1;
//│     return hi(tmp)
//│   }
//│ };
//│ $_stack$_safe$_body$_ = (undefined, function () {
//│   return hi(0)
//│ });
//│ res = runtime.runStackSafe(5, $_stack$_safe$_body$_);
//│ if (res instanceof runtime.EffectSig.class) {
//│   res = runtime.topLevelEffect(res, false);
//│ }
//│ res
//│ = 0

:sjs
:stackSafe 1000
:effectHandlers
:expect 50005000
fun sum(n) =
  if n == 0 then 0
  else
    n + sum(n - 1)
sum(10000)
//│ JS (unsanitized):
//│ let sum1, res1, $_stack$_safe$_body$_1;
//│ sum1 = function sum(n) {
//│   let scrut, tmp, tmp1, curDepth, stackDelayRes, Cont$func$sum$1;
//│   Cont$func$sum$1 = function Cont$func$sum$(pc1) {
//│     return new Cont$func$sum$.class(pc1);
//│   };
//│   Cont$func$sum$1.class = class Cont$func$sum$ extends runtime.FunctionContFrame.class {
//│     constructor(pc) {
//│       let tmp2;
//│       tmp2 = super(null);
//│       this.pc = pc;
//│     }
//│     resume(value$) {
//│       if (this.pc === 0) {
//│         stackDelayRes = value$;
//│       } else if (this.pc === 1) {
//│         tmp1 = value$;
//│       }
//│       contLoop: while (true) {
//│         if (this.pc === 0) {
//│           scrut = n == 0;
//│           if (scrut === true) {
//│             return 0
//│           } else {
//│             tmp = n - 1;
//│             this.pc = 3;
//│             continue contLoop;
//│           }
//│           this.pc = 2;
//│           continue contLoop;
//│         } else if (this.pc === 2) {
//│           break contLoop;
//│         } else if (this.pc === 3) {
//│           runtime.stackDepth = runtime.stackDepth + 1;
//│           tmp1 = sum1(tmp);
//│           if (tmp1 instanceof runtime.EffectSig.class) {
//│             this.pc = 1;
//│             tmp1.contTrace.last.next = this;
//│             tmp1.contTrace.last = this;
//│             return tmp1
//│           }
//│           this.pc = 1;
//│           continue contLoop;
//│         } else if (this.pc === 1) {
//│           tmp1 = runtime.resetDepth(tmp1, curDepth);
//│           return n + tmp1
//│         }
//│         break;
//│       }
//│     }
//│     toString() { return "Cont$func$sum$(" + globalThis.Predef.render(this.pc) + ")"; }
//│   };
//│   curDepth = runtime.stackDepth;
//│   stackDelayRes = runtime.checkDepth();
//│   if (stackDelayRes instanceof runtime.EffectSig.class) {
//│     stackDelayRes.contTrace.last.next = new Cont$func$sum$1.class(0);
//│     stackDelayRes.contTrace.last = stackDelayRes.contTrace.last.next;
//│     return stackDelayRes
//│   }
//│   scrut = n == 0;
//│   if (scrut === true) {
//│     return 0
//│   } else {
//│     tmp = n - 1;
//│     runtime.stackDepth = runtime.stackDepth + 1;
//│     tmp1 = sum1(tmp);
//│     if (tmp1 instanceof runtime.EffectSig.class) {
//│       tmp1.contTrace.last.next = new Cont$func$sum$1.class(1);
//│       tmp1.contTrace.last = tmp1.contTrace.last.next;
//│       return tmp1
//│     }
//│     tmp1 = runtime.resetDepth(tmp1, curDepth);
//│     return n + tmp1
//│   }
//│ };
//│ $_stack$_safe$_body$_1 = (undefined, function () {
//│   return sum1(10000)
//│ });
//│ res1 = runtime.runStackSafe(1000, $_stack$_safe$_body$_1);
//│ if (res1 instanceof runtime.EffectSig.class) {
//│   res1 = runtime.topLevelEffect(res1, false);
//│ }
//│ res1
//│ = 50005000

// stack-overflows without :stackSafe
:re
fun sum(n) =
  if n == 0 then 0
  else
    n + sum(n - 1)
sum(10000)
//│ ═══[RUNTIME ERROR] RangeError: Maximum call stack size exceeded

:effectHandlers
:stackSafe 100
mut val ctr = 0
fun dummy(x) = x
fun foo(f) = 
  if ctr > 10000 then 0
  else 
    set ctr += 1
    dummy(f(f))
foo(foo)
//│ = 0
//│ ctr = 10001

:stackSafe 1000
:effectHandlers
:expect 50005000
val foo =
  val f = n =>
    if n <= 0 then 0
    else n + f(n-1)
  f(10000)
foo
//│ = 50005000
//│ foo = 50005000

:stackSafe 0
:effectHandlers
:expect 50005000
val foo =
  val f = n =>
    if n <= 0 then 0
    else n + f(n-1)
  f(10000)
foo
//│ = 50005000
//│ foo = 50005000

:re
fun foo() =
  let f = ()
  set f = n =>
    if n <= 0 then 0
    else n + f(n-1)
  f(10000)
foo()
//│ ═══[RUNTIME ERROR] RangeError: Maximum call stack size exceeded

abstract class Eff with
  fun perform(a): ()

// functions and lambdas inside handlers
:effectHandlers
:stackSafe 100
:expect 50005000
fun foo(h) = h.perform
handle h = Eff with
  fun perform(resume) =
    let f = ()
    set f = n =>
      if n <= 0 then 0
      else n + f(n-1)
    resume(f(10000))
foo(h)
//│ = 50005000

// function call and defn inside handler
:effectHandlers
:stackSafe 100
:expect 50005000
handle h = Eff with
  fun perform(resume) =
    let f = ()
    set f = n =>
      if n <= 0 then 0
      else n + f(n-1)
    resume(f(10000))
in
  fun foo(h) = h.perform
  foo(h)
//│ = 50005000

:effectHandlers
:stackSafe 100
:expect 50005000
module A with
  val f = n =>
    if n <= 0 then 0
    else n + f(n-1)
  val x = f(10000)
A.x
//│ = 50005000

:re
:effectHandlers
fun foo(h) = h.perform(2)
handle h = Eff with
  fun perform(a)(resume) =
    let f = ()
    set f = n =>
      if n <= 0 then 0
      else n + f(n-1)
    resume(f(10000))
foo(h)
//│ ═══[RUNTIME ERROR] RangeError: Maximum call stack size exceeded

:effectHandlers
:stackSafe
:sjs
fun max(a, b) = if a < b then b else a
//│ JS (unsanitized):
//│ let max;
//│ max = function max(a, b) {
//│   let scrut;
//│   scrut = a < b;
//│   if (scrut === true) {
//│     return b
//│   } else {
//│     return a
//│   }
//│ };


:sjs
:stackSafe 42
fun hi(n) = n
hi(0)
//│ /!!!\ Option ':stackSafe' requires ':effectHandlers' to be set
//│ JS (unsanitized):
//│ let hi1; hi1 = function hi(n) { return n }; hi1(0)
//│ = 0

:stackSafe 42
hi(0)
//│ /!!!\ Option ':stackSafe' requires ':effectHandlers' to be set
//│ = 0


:stackSafe 1000
:effectHandlers
:expect 100010000
fun sum(n) =
  if n == 0 then 0
  else
    n + sum(n - 1)
fun bad() = sum(10000) + sum(10000)
bad()
//│ = 100010000


:effectHandlers
:stackSafe 100
:expect 0
let depth = 0
handle h = Object with
  fun whoops()(k) =
    if depth >= 50000 then 0
    else
      set depth += 1
      enterHandleBlock(this, () => whoops())
h.whoops()
//│ = 0
//│ depth = 50000
