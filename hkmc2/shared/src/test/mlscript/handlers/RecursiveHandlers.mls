:js
:effectHandlers


abstract class Effect[A] with
  fun perform(arg: A): A


handle h1 = Effect with
  fun perform(arg)(k) =
    print("performing " + arg)
    [k("ok")]
h1.perform("hi")
h1.perform("hello")
//│ > performing hi
//│ > performing hello
//│ = [["ok"]]

:e
h1
//│ ╔══[ERROR] Name not found: h1
//│ ║  l.20: 	h1
//│ ╙──      	^^

:e
h1.perform("oops")
//│ ╔══[ERROR] Name not found: h1
//│ ║  l.26: 	h1.perform("oops")
//│ ╙──      	^^

:re
handle h = Object with
  fun write(x)(k) =
    if x < 10 do write(10)
    [x, k(())]
h.write(1)
h.write(2)
//│ ═══[RUNTIME ERROR] Error: Unhandled effect Handler$h$

handle h = Object with
  fun write(x)(k) =
    if x < 10 do
      print(enterHandleBlock(this, () => write(10)))
    [x, k(())]
h.write(1)
h.write(2)
//│ > [10, ()]
//│ > [10, ()]
//│ = [1, [2, ()]]

handle h = Object with
  fun write(x)(k) = enterHandleBlock of this, () =>
    if x < 10 do write(10)
    [x, k(())]
h.write(1)
h.write(2)
//│ = [10, [1, [10, [2, ()]]]]

// deep handler
:todo
handle h2 = Effect with
  fun perform(arg)(k) =
    print("performing " + arg)
    k of if arg > 0
      then h2.perform(arg - 1) + " " + arg
      else "0"
[
  print("–––");
  h2.perform(2)
  print("–––");
  h2.perform(3)
]
//│ ╔══[ERROR] Name not found: h2
//│ ║  l.65: 	      then h2.perform(arg - 1) + " " + arg
//│ ╙──      	           ^^
//│ > –––
//│ > performing 2
//│ > –––
//│ > performing 3
//│ = [undefined, undefined]


// passing additional handlers to the handler body
let res =
  handle h = Effect with
    fun perform(arg)(k) =
      print("A " + arg)
      handle g = Effect with
        fun perform(arg1)(k1) =
          print("B " + arg + " " + arg1)
          ["‹", k1(arg), arg1, "›"]
      [k(g)]
  let g = h.perform("hi")
  g.perform("bye")
  g.perform("friend")
  set g = h.perform("hola")
  g.perform("adios")
  g.perform("amigos")
in res.toString()
//│ > A hi
//│ > B hi bye
//│ > B hi friend
//│ > A hola
//│ > B hola adios
//│ > B hola amigos
//│ = "‹,‹,‹,‹,hola,amigos,›,adios,›,friend,›,bye,›"


// This is equivalent to the above, with all calls to h.perform expanded
let res =
  print("A " + "hi")
  handle g = Effect with
    fun perform(arg1)(k1) =
      print("B " + "hi" + " " + arg1)
      ["‹", k1("hi"), arg1, "›"]
  [(() =>
    g.perform("bye")
    g.perform("friend")
    print("A " + "hola")
    handle g2 = Effect with
      fun perform(arg1)(k1) =
        print("B " + "hola" + " " + arg1)
        ["‹", k1("hola"), arg1, "›"]
    [(() =>
      g2.perform("adios")
      g2.perform("amigos")
    )()]
  )()]
in res.toString()
//│ > A hi
//│ > B hi bye
//│ > B hi friend
//│ > A hola
//│ > B hola adios
//│ > B hola amigos
//│ = "‹,‹,‹,‹,hola,amigos,›,adios,›,friend,›,bye,›"

:sjs
let str = ""
if true do
  handle h1 = Effect with
    fun perform(arg)(k) =
      set str += "A"
      k(arg)
      set str += "A"
  handle h2 = Effect with
    fun perform(arg)(k) =
      set str += str + "B"
      k(arg)
      set str += str + "B"
  h2.perform(())
  h1.perform(())
str
//│ JS (unsanitized):
//│ let str, scrut, tmp9, tmp10, handleBlock$7;
//│ str = "";
//│ scrut = true;
//│ if (scrut === true) {
//│   handleBlock$7 = function handleBlock$() {
//│     let h1, tmp11, handleBlock$8, Cont$handleBlock$h1$2, Handler$h1$2;
//│     Handler$h1$2 = class Handler$h1$1 extends Effect1 {
//│       constructor() {
//│         let tmp12;
//│         tmp12 = super();
//│       }
//│       perform(arg) {
//│         return runtime.mkEffect(this, (k) => {
//│           let tmp12, tmp13, tmp14, Cont$handler$h1$perform$2;
//│           Cont$handler$h1$perform$2 = function Cont$handler$h1$perform$(pc1) {
//│             return new Cont$handler$h1$perform$.class(pc1);
//│           };
//│           Cont$handler$h1$perform$2.class = class Cont$handler$h1$perform$1 extends runtime.FunctionContFrame.class {
//│             constructor(pc) {
//│               let tmp15;
//│               tmp15 = super(null);
//│               this.pc = pc;
//│             }
//│             resume(value$) {
//│               if (this.pc === 7) {
//│                 tmp13 = value$;
//│               }
//│               contLoop: while (true) {
//│                 if (this.pc === 8) {
//│                   tmp13 = runtime.safeCall(k(arg));
//│                   if (tmp13 instanceof runtime.EffectSig.class) {
//│                     this.pc = 7;
//│                     tmp13.contTrace.last.next = this;
//│                     tmp13.contTrace.last = this;
//│                     return tmp13
//│                   }
//│                   this.pc = 7;
//│                   continue contLoop;
//│                 } else if (this.pc === 7) {
//│                   tmp14 = str + "A";
//│                   str = tmp14;
//│                   return runtime.Unit
//│                 }
//│                 break;
//│               }
//│             }
//│             toString() { return "Cont$handler$h1$perform$(" + globalThis.Predef.render(this.pc) + ")"; }
//│           };
//│           tmp12 = str + "A";
//│           str = tmp12;
//│           tmp13 = runtime.safeCall(k(arg));
//│           if (tmp13 instanceof runtime.EffectSig.class) {
//│             tmp13.contTrace.last.next = new Cont$handler$h1$perform$2.class(7);
//│             tmp13.contTrace.last = tmp13.contTrace.last.next;
//│             return tmp13
//│           }
//│           tmp14 = str + "A";
//│           str = tmp14;
//│           return runtime.Unit
//│         })
//│       }
//│       toString() { return "Handler$h1$"; }
//│     };
//│     h1 = new Handler$h1$2();
//│     Cont$handleBlock$h1$2 = function Cont$handleBlock$h1$(pc1) {
//│       return new Cont$handleBlock$h1$.class(pc1);
//│     };
//│     Cont$handleBlock$h1$2.class = class Cont$handleBlock$h1$1 extends runtime.FunctionContFrame.class {
//│       constructor(pc) {
//│         let tmp12;
//│         tmp12 = super(null);
//│         this.pc = pc;
//│       }
//│       resume(value$) {
//│         if (this.pc === 6) {
//│           tmp11 = value$;
//│         }
//│         contLoop: while (true) {
//│           if (this.pc === 6) {
//│             return tmp11
//│           }
//│           break;
//│         }
//│       }
//│       toString() { return "Cont$handleBlock$h1$(" + globalThis.Predef.render(this.pc) + ")"; }
//│     };
//│     handleBlock$8 = function handleBlock$() {
//│       let h2, tmp12, res7, Cont$handleBlock$h2$2, Handler$h2$2;
//│       Handler$h2$2 = class Handler$h2$1 extends Effect1 {
//│         constructor() {
//│           let tmp13;
//│           tmp13 = super();
//│         }
//│         perform(arg) {
//│           return runtime.mkEffect(this, (k) => {
//│             let tmp13, tmp14, tmp15, tmp16, tmp17, Cont$handler$h2$perform$2;
//│             Cont$handler$h2$perform$2 = function Cont$handler$h2$perform$(pc1) {
//│               return new Cont$handler$h2$perform$.class(pc1);
//│             };
//│             Cont$handler$h2$perform$2.class = class Cont$handler$h2$perform$1 extends runtime.FunctionContFrame.class {
//│               constructor(pc) {
//│                 let tmp18;
//│                 tmp18 = super(null);
//│                 this.pc = pc;
//│               }
//│               resume(value$) {
//│                 if (this.pc === 4) {
//│                   tmp15 = value$;
//│                 }
//│                 contLoop: while (true) {
//│                   if (this.pc === 5) {
//│                     tmp15 = runtime.safeCall(k(arg));
//│                     if (tmp15 instanceof runtime.EffectSig.class) {
//│                       this.pc = 4;
//│                       tmp15.contTrace.last.next = this;
//│                       tmp15.contTrace.last = this;
//│                       return tmp15
//│                     }
//│                     this.pc = 4;
//│                     continue contLoop;
//│                   } else if (this.pc === 4) {
//│                     tmp16 = str + "B";
//│                     tmp17 = str + tmp16;
//│                     str = tmp17;
//│                     return runtime.Unit
//│                   }
//│                   break;
//│                 }
//│               }
//│               toString() { return "Cont$handler$h2$perform$(" + globalThis.Predef.render(this.pc) + ")"; }
//│             };
//│             tmp13 = str + "B";
//│             tmp14 = str + tmp13;
//│             str = tmp14;
//│             tmp15 = runtime.safeCall(k(arg));
//│             if (tmp15 instanceof runtime.EffectSig.class) {
//│               tmp15.contTrace.last.next = new Cont$handler$h2$perform$2.class(4);
//│               tmp15.contTrace.last = tmp15.contTrace.last.next;
//│               return tmp15
//│             }
//│             tmp16 = str + "B";
//│             tmp17 = str + tmp16;
//│             str = tmp17;
//│             return runtime.Unit
//│           })
//│         }
//│         toString() { return "Handler$h2$"; }
//│       };
//│       h2 = new Handler$h2$2();
//│       Cont$handleBlock$h2$2 = function Cont$handleBlock$h2$(pc1) {
//│         return new Cont$handleBlock$h2$.class(pc1);
//│       };
//│       Cont$handleBlock$h2$2.class = class Cont$handleBlock$h2$1 extends runtime.FunctionContFrame.class {
//│         constructor(pc) {
//│           let tmp13;
//│           tmp13 = super(null);
//│           this.pc = pc;
//│         }
//│         resume(value$) {
//│           if (this.pc === 0) {
//│             tmp12 = value$;
//│           } else if (this.pc === 1) {
//│             res7 = value$;
//│           }
//│           contLoop: while (true) {
//│             if (this.pc === 3) {
//│               tmp12 = runtime.safeCall(h2.perform(runtime.Unit));
//│               if (tmp12 instanceof runtime.EffectSig.class) {
//│                 this.pc = 0;
//│                 tmp12.contTrace.last.next = this;
//│                 tmp12.contTrace.last = this;
//│                 return tmp12
//│               }
//│               this.pc = 0;
//│               continue contLoop;
//│             } else if (this.pc === 0) {
//│               this.pc = 2;
//│               continue contLoop;
//│             } else if (this.pc === 2) {
//│               res7 = runtime.safeCall(h1.perform(runtime.Unit));
//│               if (res7 instanceof runtime.EffectSig.class) {
//│                 this.pc = 1;
//│                 res7.contTrace.last.next = this;
//│                 res7.contTrace.last = this;
//│                 return res7
//│               }
//│               this.pc = 1;
//│               continue contLoop;
//│             } else if (this.pc === 1) {
//│               return res7
//│             }
//│             break;
//│           }
//│         }
//│         toString() { return "Cont$handleBlock$h2$(" + globalThis.Predef.render(this.pc) + ")"; }
//│       };
//│       tmp12 = runtime.safeCall(h2.perform(runtime.Unit));
//│       if (tmp12 instanceof runtime.EffectSig.class) {
//│         tmp12.contTrace.last.next = Cont$handleBlock$h2$2(0);
//│         return runtime.handleBlockImpl(tmp12, h2)
//│       }
//│       res7 = runtime.safeCall(h1.perform(runtime.Unit));
//│       if (res7 instanceof runtime.EffectSig.class) {
//│         res7.contTrace.last.next = Cont$handleBlock$h2$2(1);
//│         return runtime.handleBlockImpl(res7, h2)
//│       }
//│       return res7
//│     };
//│     tmp11 = handleBlock$8();
//│     if (tmp11 instanceof runtime.EffectSig.class) {
//│       tmp11.contTrace.last.next = Cont$handleBlock$h1$2(6);
//│       return runtime.handleBlockImpl(tmp11, h1)
//│     }
//│     return tmp11
//│   };
//│   tmp9 = handleBlock$7();
//│   if (tmp9 instanceof runtime.EffectSig.class) {
//│     tmp9 = runtime.topLevelEffect(tmp9, false);
//│   }
//│   tmp10 = tmp9;
//│ } else {
//│   tmp10 = runtime.Unit;
//│ }
//│ str
//│ = "BABABA"
//│ str = "BABABA"
