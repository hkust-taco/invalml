:js
:effectHandlers


abstract class Effect with
  fun perform(arg: Str): Str


:sjs
class Lol(h) with
  print(h.perform("k"))
//│ JS (unsanitized):
//│ let Lol1;
//│ Lol1 = function Lol(h1) {
//│   return new Lol.class(h1);
//│ };
//│ Lol1.class = class Lol {
//│   constructor(h) {
//│     this.h = h;
//│     let tmp, res, Cont$ctor$Lol$EffectsInClasses$_mls_L10_6_41$1;
//│     const this$Lol = this;
//│     Cont$ctor$Lol$EffectsInClasses$_mls_L10_6_41$1 = function Cont$ctor$Lol$EffectsInClasses$_mls_L10_6_41$(pc1) {
//│       return new Cont$ctor$Lol$EffectsInClasses$_mls_L10_6_41$.class(pc1);
//│     };
//│     Cont$ctor$Lol$EffectsInClasses$_mls_L10_6_41$1.class = class Cont$ctor$Lol$EffectsInClasses$_mls_L10_6_41$ extends runtime.FunctionContFrame.class {
//│       constructor(pc) {
//│         let tmp1;
//│         tmp1 = super(null);
//│         this.pc = pc;
//│       }
//│       resume(value$) {
//│         if (this.pc === 0) {
//│           tmp = value$;
//│         } else if (this.pc === 1) {
//│           res = value$;
//│         }
//│         contLoop: while (true) {
//│           if (this.pc === 2) {
//│             return this$Lol
//│           } else if (this.pc === 3) {
//│             res = Predef.print(tmp);
//│             if (res instanceof runtime.EffectSig.class) {
//│               this.pc = 1;
//│               res.contTrace.last.next = this;
//│               res.contTrace.last = this;
//│               return res
//│             }
//│             this.pc = 1;
//│             continue contLoop;
//│           } else if (this.pc === 4) {
//│             tmp = runtime.safeCall(this$Lol.h.perform("k"));
//│             if (tmp instanceof runtime.EffectSig.class) {
//│               this.pc = 0;
//│               tmp.contTrace.last.next = this;
//│               tmp.contTrace.last = this;
//│               return tmp
//│             }
//│             this.pc = 0;
//│             continue contLoop;
//│           } else if (this.pc === 0) {
//│             this.pc = 3;
//│             continue contLoop;
//│           } else if (this.pc === 1) {
//│             this.pc = 2;
//│             continue contLoop;
//│           }
//│           break;
//│         }
//│       }
//│       toString() { return "Cont$ctor$Lol$EffectsInClasses$_mls_L10_6_41$(" + globalThis.Predef.render(this.pc) + ")"; }
//│     };
//│     tmp = runtime.safeCall(this.h.perform("k"));
//│     if (tmp instanceof runtime.EffectSig.class) {
//│       tmp.contTrace.last.next = new Cont$ctor$Lol$EffectsInClasses$_mls_L10_6_41$1.class(0);
//│       tmp.contTrace.last = tmp.contTrace.last.next;
//│       return tmp
//│     }
//│     res = Predef.print(tmp);
//│     if (res instanceof runtime.EffectSig.class) {
//│       res.contTrace.last.next = new Cont$ctor$Lol$EffectsInClasses$_mls_L10_6_41$1.class(1);
//│       res.contTrace.last = res.contTrace.last.next;
//│       return res
//│     }
//│     res
//│   }
//│   toString() { return "Lol(" + globalThis.Predef.render(this.h) + ")"; }
//│ };


// * This is a weird use of effect handlers where an effect is raised during the construction of a handler.
// * The most natural semantics (following what normal constructors currently do)
// *  is for the handler to not yet be constructed but to be constructed and executed normally after resumption.
// * See full discussion at: https://github.com/hkust-taco/mlscript/pull/268#discussion_r1938523085
:fixme
handle h = Effect with
  fun perform(arg)(k) =
    print(arg)
    k()
abstract class Eff with
  fun test()
  h.perform("x")
handle k = Eff with
  fun test()(k) = k()
k.test()
print("test")
//│ ═══[RUNTIME ERROR] TypeError: k.test is not a function


let oops = 
  handle h = Effect with
    fun perform(arg)(k) =
      print(arg)
      "b"
  Lol(h)
//│ > k
//│ oops = "b"

:expect "b"
oops
//│ = "b"

let oops = 
  handle h = Effect with
    fun perform(arg)(k) =
      print(arg)
      "b"
  new Lol(h)
//│ > k
//│ oops = "b"

:expect "b"
oops
//│ = "b"


let oops = 
  handle h = Effect with
    fun perform(arg)(k) =
      print(arg)
      k("b")
  Lol(h)
//│ > k
//│ > b
//│ oops = Lol(Handler$h$)

oops.h
//│ = Handler$h$

let obj = {}
//│ obj = ()

handle h = Effect with
  fun perform(arg)(k) =
    k()
    print(arg)
set obj.["s"] = h.perform("k")
//│ > k

fun f() = ()

module A with
  f()
  () // defeats tail call optimization

let obj = new Object with
  fun foo() = print("Hello")
  foo()
//│ > Hello
//│ obj = $anon
