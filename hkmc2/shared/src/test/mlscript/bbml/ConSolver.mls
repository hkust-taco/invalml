:bbml


fun (;) seq(_, res) = res
fun println: Any -> ()
fun (~) concat: (Str, Str) -> Str
fun (???) TODO() = TODO()


class PairOf[A, B] with
  constructor
    Pair(fst: A, snd: B)

class Stack[A] with
  constructor
    Nil
    Cons(head: A, tail: Stack[out A])

class Option[A] with
  constructor
    None
    Some(value: A)

class ArrayList[A, R]
class Iter[T, R]

fun
  
  // empty:   [A, R] -> Region[R] ->{R} ArrayList[out A, out R]  // TODO investigate: why does this break things?
  empty:   [A, R] -> Region[R] ->{R} ArrayList[A, out R]
  
  clear:   [A, R] -> (ArrayList[A, out R]) ->{R} ()
  push:    [A, R] -> (ArrayList[A, out R], A) ->{R} ()
  foreach: [E, R, T] -> (Iter[T, R], T ->{E} ()) ->{R | E} ()
  read: [T, S] -> Iter[T, S] ->{S} T
  iter: [outer, Res, R, E extends ~R, T] ->
    (ArrayList[T, out R], [S extends ~outer] -> Iter[T, S] ->{S | E} Res) ->{E | R} Res
  next: [T, S] -> Iter[T, S] ->{S} Option[T]
  whileDo: [R] -> (() ->{R} Bool) ->{R} ()

fun freeze: [R, E extends ~R, T] -> (Region[R], () ->{~R & E} T) ->{R | E} T


push
//│ Type: ['A, 'R] -> (ArrayList['A, out 'R], 'A) ->{'R} ()


class Type[R] with
  constructor
    IntType
    Unif(id: Int, lowerBounds: ArrayList[Type[R], out R], upperBounds: ArrayList[Type[R], out R])
    Fun(lhs: Type[R], rhs: Type[R])

let ty = Fun(IntType, IntType)

// fun pp(x) = if x is
//   Int then "Int"
//   Fun(l, r) then pp(l) ~ " -> " ~ pp(r)

// :fixme
fun pp = case
  IntType then "Int"
  Unif(id, lbs, ubs) then "α" ~ String(id)
  Fun(l, r) then pp(l) ~ " -> " ~ pp(r)

pp(ty)
//│ Type: Str


:e
fun matchP = case
  Pair(IntType, IntType) then ()
//│ ╔══[ERROR] Pattern Ident(IntType) is not supported yet.
//│ ║  l.72: 	  Pair(IntType, IntType) then ()
//│ ╙──      	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Pattern Ident(IntType) is not supported yet.
//│ ║  l.72: 	  Pair(IntType, IntType) then ()
//│ ╙──      	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Expect 3 cases, but 1 got.
//│ ║  l.72: 	  Pair(IntType, IntType) then ()
//│ ╙──      	                ^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Expect 3 cases, but 1 got.
//│ ║  l.72: 	  Pair(IntType, IntType) then ()
//│ ╙──      	       ^^^^^^^^^^^^^^^^^^^^^^^^^


fun error() = error()

fun solve = case
  Nil then ()
  Cons(c, cs) then if c is
    Pair(lhs, rhs) then
      if lhs is
        IntType then if rhs is
          IntType then ()
          Fun(_, _) | Unif(_, _, _) then error()
        Fun(l1, r1) then  if rhs is
          Fun(l2, r2) then
            solve(Cons(Pair(l2, l1), cs))
            solve(Cons(Pair(r1, r2), cs))
          IntType | Unif(_, _, _) then error()
        Unif(id, lbs, ubs) then
          clear(ubs)
          // iter(ubs, TODO())
          // Handle unification case here
          error() // Placeholder for unification logic



solve
//│ Type: ['Fun, 'Fun, 'eff, 'eff1, 'Unif] -> (Stack[out PairOf[out (Type[out 'Unif] ∧ Type[out 'Fun]) ∧ Type[?], out (((Type[?] ∧ Type[out 'Fun]) ∧ Type[?]) ∧ Type[?]) ∧ Type[?]]] ∧ Stack[?]) ->{('eff1 ∨ 'eff) ∨ 'Unif} ()
//│ Where:
//│   ⊥ <: 'Fun
//│   'Fun <: ⊤
//│   'Fun <: 'Fun
//│   ⊥ <: 'Fun
//│   'Fun <: ⊤
//│   'Fun <: 'Fun
//│   'Fun <: 'Unif
//│   'Fun <: 'Unif
//│   'Fun <: 'eff
//│   'Fun <: 'eff
//│   ⊥ <: 'eff
//│   'Fun <: 'eff1
//│   'Fun <: 'eff1
//│   'eff <: 'eff1
//│   ⊥ <: 'eff1
//│   'eff1 <: 'eff
//│   'Unif <: 'eff
//│   'Unif <: 'eff1


fun test: [R] -> (ArrayList[Int, R]) ->{R} Int
fun test(xs) =
  region r in
    iter of xs, it =>
      1

fun test: [outer, R extends outer] -> (Region[R]) ->{R} Int
fun test(xs) =
  region r in
    let ncs = r.ref 0
    freeze of xs, () =>
      ncs := 1

fun test: [outer, R extends outer] -> (ArrayList[Int, R]) ->{R} Int
fun test(xs) =
  region r in
    let ncs = r.ref 0
    iter of xs, it =>
      ncs := 1

// * Note the missing `outer` bound
// TODO: assume that bound implicitly?
:e
fun test: [R] -> (ArrayList[Int, R]) ->{R} Int
fun test(xs) =
  region r in
    let ncs = r.ref 0
    iter of xs, it =>
      ncs := 1
//│ ╔══[ERROR] Type error in function literal with expected type (Iter['T, S]) ->{S ∨ 'E} 'Res
//│ ║  l.160: 	    iter of xs, it =>
//│ ║         	                ^^^^^
//│ ║  l.161: 	      ncs := 1
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  'reg  <:  S ∨ 'E
//│ ╟── because: cannot constrain  'reg  <:  'E ∨ S
//│ ╟── because: cannot constrain  'reg1  <:  'E ∨ S
//│ ╟── because: cannot constrain  ¬'S1 ∧ 'reg1  <:  'E
//│ ╟── because: cannot constrain  ¬'S1 ∧ 'reg1  <:  ¬'R
//│ ╟── because: cannot constrain  'R ∧ 'reg1  <:  'S1
//│ ╟── because: cannot constrain  'R ∧ 'reg1  <:  ⊥
//│ ╟── because: cannot constrain  'R  <:  ¬'reg1
//│ ╟── because: cannot constrain  R1  <:  ¬'reg1
//│ ╟── because: cannot constrain  'reg1  <:  ¬R1
//│ ╙── because: cannot constrain  r ∧ ¬outer  <:  ¬R1


// fun solve: [R] -> Stack[out PairOf[out Type[R], out Type[R]]] ->{R} ()
fun solve: [outer, R extends outer] -> Stack[out PairOf[out Type[R], out Type[R]]] ->{R} ()
fun solve = case
  Nil then ()
  Cons(c, cs) then if c is
    Pair(lhs, rhs) then
      if lhs is
        IntType then if rhs is
          IntType then ()
          Fun(_, _) then error()
          Unif(id, lbs, ubs) then
            // push(lbs, lhs)
            // let ncs = fold(ubs, cs, (it, lst) => Cons(Pair(lhs, read(it)), lst))
            // solve(ncs)
            error() // TODO
        Fun(l1, r1) then  if rhs is
          Fun(l2, r2) then
            solve(Cons(Pair(l2, l1), Cons(Pair(r1, r2), cs)))
          IntType then error()
          Unif(id, lbs, ubs) then
            push(lbs, lhs)
            region r in
              let ncs = r.ref cs
              iter of lbs, it =>
                whileDo of () =>
                  if next(it) is
                    Some(x) then
                      // set ncs = Cons(Pair(lhs, x), ncs)
                      ncs := Cons(Pair(lhs, x), !ncs)
                      true
                    None then false
              solve(!ncs)
        Unif(id, lbs, ubs) then
          // push(ubs, rhs)
          // let ncs = fold(lbs, cs, (it, lst) => Cons(Pair(read(it), rhs), lst))
          // solve(ncs)
          error() // TODO


solve(Cons(Pair(ty, ty), Nil))


:e
fun solve: [R] -> Stack[out PairOf[out Type[R], out Type[R]]] ->{R} ()
fun solve = case
  Nil then ()
  Cons(c, cs) then if c is
    Pair(lhs, rhs) then
      if lhs is
        IntType then if rhs is
          IntType then ()
          Fun(_, _) | Unif(_, _, _) then error()
        Fun(l1, r1) then  if rhs is
          Fun(l2, r2) then
            solve(Cons(Pair(l2, l1), cs))
            solve(Cons(Pair(r1, r2), cs))
          IntType | Unif(_, _, _) then error()
        Unif(id, lbs, ubs) then
          iter(lbs, it => solve(Cons(Pair(read(it), rhs), Nil)))
//│ ╔══[ERROR] Type error in function literal with expected type (Iter['T, S]) ->{S ∨ 'E} 'Res
//│ ║  l.238: 	          iter(lbs, it => solve(Cons(Pair(read(it), rhs), Nil)))
//│ ║         	                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  'R ∨ 'S1  <:  S ∨ 'E
//│ ╟── because: cannot constrain  'R  <:  'E ∨ S
//│ ╟── because: cannot constrain  'R1  <:  'E ∨ S
//│ ╟── because: cannot constrain  'R1  <:  'E ∨ 'S2
//│ ╟── because: cannot constrain  R2  <:  'E ∨ 'S2
//│ ╟── because: cannot constrain  ¬'E ∧ R2  <:  'S2
//│ ╟── because: cannot constrain  ¬'E ∧ R2  <:  ⊥
//│ ╟── because: cannot constrain  R2  <:  'E
//│ ╟── because: cannot constrain  R2  <:  ¬'R3
//│ ╟── because: cannot constrain  'R3  <:  ¬R2
//│ ╟── because: cannot constrain  'R4  <:  ¬R2
//│ ╙── because: cannot constrain  R2  <:  ¬R2
//│ ╔══[ERROR] Type error in function literal with expected type (Iter['T, S]) ->{S ∨ 'E} 'Res
//│ ║  l.238: 	          iter(lbs, it => solve(Cons(Pair(read(it), rhs), Nil)))
//│ ║         	                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  'R ∨ 'S1  <:  S ∨ 'E
//│ ╟── because: cannot constrain  'R  <:  'E ∨ S
//│ ╟── because: cannot constrain  'R5  <:  'E ∨ S
//│ ╟── because: cannot constrain  'R5  <:  'E ∨ 'S3
//│ ╟── because: cannot constrain  'R4  <:  'E ∨ 'S3
//│ ╟── because: cannot constrain  ¬'E ∧ 'R4  <:  'S3
//│ ╟── because: cannot constrain  ¬'E ∧ 'R4  <:  ⊥
//│ ╟── because: cannot constrain  'R4  <:  'E
//│ ╟── because: cannot constrain  'R4  <:  ¬'R3
//│ ╟── because: cannot constrain  'R3  <:  ¬'R4
//│ ╟── because: cannot constrain  'R4  <:  ¬'R4
//│ ╟── because: cannot constrain  'R4  <:  ⊥
//│ ╙── because: cannot constrain  R2  <:  ⊥


fun solve = case
  Nil then ()
  Cons(c, cs) then if c is
    Pair(lhs, rhs) then
      if lhs is
        IntType then if rhs is
          IntType then ()
          Fun(_, _) | Unif(_, _, _) then error()
        Fun(l1, r1) then  if rhs is
          Fun(l2, r2) then
            solve(Cons(Pair(l2, l1), cs))
            solve(Cons(Pair(r1, r2), cs))
          IntType | Unif(_, _, _) then error()
        Unif(id, lbs, ubs) then
          iter(lbs, it => solve(Cons(Pair(read(it), rhs), Nil)))


solve
//│ Type: ['Fun, 'Fun, 'eff, 'eff1, 'Unif] -> (Stack[out PairOf[out (Type[out 'Unif] ∧ Type[out 'Fun]) ∧ Type[?], out (((Type[?] ∧ Type[out 'Fun]) ∧ Type[?]) ∧ Type[?]) ∧ Type[?]]] ∧ Stack[?]) ->{(((('eff1 ∨ 'eff) ∨ 'Unif) ∨ 'eff) ∨ 'eff1) ∨ 'Unif} ()
//│ Where:
//│   ⊥ <: 'Fun
//│   'Fun <: ⊤
//│   'Fun <: ⊥
//│   'Fun <: 'Fun
//│   ⊥ <: 'Fun
//│   'Fun <: 'Fun
//│   'Fun <: ⊤
//│   'Fun <: ⊥
//│   'Fun <: ¬'Fun
//│   'Fun <: 'Unif
//│   'Fun <: 'Unif
//│   ⊥ <: 'Unif
//│   ⊥ <: 'eff
//│   'Fun <: 'eff
//│   'Fun <: 'eff
//│   'eff <: ¬'Fun
//│   'eff <: ¬'Fun
//│   'eff <: ⊤
//│   'Fun <: 'eff1
//│   'Fun <: 'eff1
//│   ⊥ <: 'eff1
//│   'eff <: 'eff1
//│   'eff1 <: 'eff
//│   'eff1 <: ¬'Fun
//│   'eff1 <: ¬'Fun
//│   'eff1 <: ⊤
//│   'Unif <: 'eff
//│   'Unif <: 'eff1
//│   'Unif <: ⊥
//│   'Unif <: ⊤
//│   'Unif <: ¬'eff
//│   'Unif <: ¬'eff1
//│   'Unif <: 'Fun

solve(Cons(Pair(ty, ty), Nil))


region r in
  solve(Cons(Pair(ty, ty), Nil))


:e
region r in
  solve(Cons(Pair(Unif(1, empty(r), empty(r)), Unif(2, empty(r), empty(r))), Nil))
//│ ╔══[ERROR] Type error in application with expected type 'caseScrut
//│ ║  l.335: 	  solve(Cons(Pair(Unif(1, empty(r), empty(r)), Unif(2, empty(r), empty(r))), Nil))
//│ ║         	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  Stack[in 'A out 'A1]  <:  'caseScrut
//│ ╟── because: cannot constrain  Stack[in 'A out 'A1]  <:  Stack[in ⊥ out PairOf[in ⊥ out Type[in ⊥ out (('Unif) ∧ ('Fun)) ∧ (⊤)], in ⊥ out Type[in ⊥ out ((((⊤) ∧ ('Fun1)) ∧ (⊤)) ∧ (⊤)) ∧ (⊤)]]]
//│ ╟── because: cannot constrain  'A1  <:  PairOf[in ⊥ out Type[in ⊥ out (('Unif) ∧ ('Fun)) ∧ (⊤)], in ⊥ out Type[in ⊥ out ((((⊤) ∧ ('Fun1)) ∧ (⊤)) ∧ (⊤)) ∧ (⊤)]]
//│ ╟── because: cannot constrain  PairOf[in 'A2 out 'A3, in 'B out 'B1]  <:  PairOf[in ⊥ out Type[in ⊥ out (('Unif) ∧ ('Fun)) ∧ (⊤)], in ⊥ out Type[in ⊥ out ((((⊤) ∧ ('Fun1)) ∧ (⊤)) ∧ (⊤)) ∧ (⊤)]]
//│ ╟── because: cannot constrain  'A3  <:  Type[in ⊥ out (('Unif) ∧ ('Fun)) ∧ (⊤)]
//│ ╟── because: cannot constrain  'A3  <:  Type[in ⊥ out 'Unif ∧ 'Fun]
//│ ╟── because: cannot constrain  Type[in 'R out 'R1]  <:  Type[in ⊥ out 'Unif ∧ 'Fun]
//│ ╟── because: cannot constrain  'R1  <:  'Unif ∧ 'Fun
//│ ╟── because: cannot constrain  'R1  <:  'Unif
//│ ╟── because: cannot constrain  r  <:  'Unif
//│ ╙── because: cannot constrain  r  <:  ⊥
//│ ╔══[ERROR] Type error in application with expected type 'caseScrut
//│ ║  l.335: 	  solve(Cons(Pair(Unif(1, empty(r), empty(r)), Unif(2, empty(r), empty(r))), Nil))
//│ ║         	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  Stack[in 'A out 'A1]  <:  'caseScrut
//│ ╟── because: cannot constrain  Stack[in 'A out 'A1]  <:  Stack[in ⊥ out PairOf[in ⊥ out Type[in ⊥ out (('Unif) ∧ ('Fun)) ∧ (⊤)], in ⊥ out Type[in ⊥ out ((((⊤) ∧ ('Fun1)) ∧ (⊤)) ∧ (⊤)) ∧ (⊤)]]]
//│ ╟── because: cannot constrain  'A1  <:  PairOf[in ⊥ out Type[in ⊥ out (('Unif) ∧ ('Fun)) ∧ (⊤)], in ⊥ out Type[in ⊥ out ((((⊤) ∧ ('Fun1)) ∧ (⊤)) ∧ (⊤)) ∧ (⊤)]]
//│ ╟── because: cannot constrain  PairOf[in 'A2 out 'A3, in 'B out 'B1]  <:  PairOf[in ⊥ out Type[in ⊥ out (('Unif) ∧ ('Fun)) ∧ (⊤)], in ⊥ out Type[in ⊥ out ((((⊤) ∧ ('Fun1)) ∧ (⊤)) ∧ (⊤)) ∧ (⊤)]]
//│ ╟── because: cannot constrain  'A3  <:  Type[in ⊥ out (('Unif) ∧ ('Fun)) ∧ (⊤)]
//│ ╟── because: cannot constrain  'A3  <:  Type[in ⊥ out 'Unif ∧ 'Fun]
//│ ╟── because: cannot constrain  Type[in 'R out 'R1]  <:  Type[in ⊥ out 'Unif ∧ 'Fun]
//│ ╟── because: cannot constrain  'R1  <:  'Unif ∧ 'Fun
//│ ╟── because: cannot constrain  'R1  <:  'Unif
//│ ╟── because: cannot constrain  r  <:  'Unif
//│ ╟── because: cannot constrain  r  <:  ¬'eff
//│ ╟── because: cannot constrain  'eff  <:  ¬r
//│ ╙── because: cannot constrain  r  <:  ¬r







// * Paper example


region r in
  let xs = empty(r)
  xs
//│ Type: ArrayList['A, ?]

region r in
  let xs = empty(r)
  push(xs, "1")
  clear(xs)


region r in // This is used to delimit the scope of mutation
  let xs = empty(r)  // Creates a new mutable list in region r
  push(xs, "1"); push(xs, "2"); push(xs, "3")
  iter(xs, it => foreach(it, e => println(e)))
  clear(xs)

:e
region r in // This is used to delimit the scope of mutation
  let xs = empty(r)  // Creates a new mutable list in region r
  push(xs, "1"); push(xs, "2"); push(xs, "3")
  iter(xs, it => foreach(it, e => println(e); clear(xs)))
//│ ╔══[ERROR] Type error in function literal with expected type (Iter['T, S]) ->{S ∨ 'E} 'Res
//│ ║  l.397: 	  iter(xs, it => foreach(it, e => println(e); clear(xs)))
//│ ║         	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  'R ∨ 'E1  <:  S ∨ 'E
//│ ╟── because: cannot constrain  'E1  <:  'E ∨ S
//│ ╟── because: cannot constrain  'R1  <:  'E ∨ S
//│ ╟── because: cannot constrain  ¬'S1 ∧ 'R1  <:  'E
//│ ╟── because: cannot constrain  ¬'S1 ∧ 'R1  <:  ¬'R2
//│ ╟── because: cannot constrain  'R2 ∧ 'R1  <:  'S1
//│ ╟── because: cannot constrain  'R2 ∧ 'R1  <:  ⊥
//│ ╟── because: cannot constrain  'R2  <:  ¬'R1
//│ ╟── because: cannot constrain  'R1  <:  ¬'R1
//│ ╟── because: cannot constrain  'R1  <:  ⊥
//│ ╙── because: cannot constrain  r  <:  ⊥



// ––––––––– TO IMPROVE LATER –––––––––


// TODO: simplify

fun test(x) = case
  IntType then TODO()
  Fun(l1, r1) then TODO()
  Unif(id, lbs, ubs) then clear(ubs)

test
//│ Type: ['Unif] -> ⊤ -> (((Type[out 'Unif] ∧ Type[?]) ∧ Type[?]) ->{'Unif} ())





fun solve = case
  Nil then ()
  Cons(c, cs) then if c is
    Pair(lhs, rhs) then
      if lhs is
        IntType then if rhs is
          IntType then ()
          else error()
        Fun(l1, r1) then  if rhs is
          Fun(l2, r2) then
            solve(Cons(Pair(l2, l1), cs))
            solve(Cons(Pair(r1, r2), cs))
          else error()
        Unif(id, lbs, ubs) then
          // Handle unification case here
          error() // Placeholder for unification logic


fun solve = case
  Nil then ()
  Cons(c, cs) and c is
    Pair(lhs, rhs) and lhs is
      IntType and rhs is
        IntType then ()
        else error()
      Fun(l1, r1) and rhs is
        Fun(l2, r2) then
          solve(Cons(Pair(l2, l1), cs))
          solve(Cons(Pair(r1, r2), cs))
        else error()
      Unif(id, lbs, ubs) then
        // Handle unification case here
        error() // Placeholder for unification logic

solve
//│ Type: (Stack[out PairOf[out Type[?], out Type[?]]] ∧ Stack[?]) -> ()


