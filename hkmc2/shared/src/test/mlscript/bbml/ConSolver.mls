:bbml


fun (;) seq(_, res) = res
fun println: Any -> ()
fun (~) concat: (Str, Str) -> Str
fun (???) TODO() = TODO()


class PairOf[A, B] with
  constructor
    Pair(fst: A, snd: B)

class Stack[A] with
  constructor
    Nil
    Cons(head: A, tail: Stack[A])

class ArrayList[A, R]
class Iter[T, R]

fun
  
  // empty:   [A, R] -> Region[R] ->{R} ArrayList[out A, out R]  // TODO investigate: why does this break things?
  empty:   [A, R] -> Region[R] ->{R} ArrayList[A, R]
  
  clear:   [A, R] -> (ArrayList[A, R]) ->{R} ()
  push:    [A, R] -> (ArrayList[A, R], A) ->{R} ()
  foreach: [E, R, T] -> (Iter[T, R], T ->{E} ()) ->{R | E} ()
  iter: [Res, R, E extends ~R, T] ->
    (ArrayList[T, R], [S] -> Iter[T, S] ->{S | E} Res) ->{E | R} Res

push
//│ Type: ['A, 'R] -> (ArrayList['A, 'R], 'A) ->{'R} ()


class Type[R] with
  constructor
    IntType
    Unif(id: Int, lowerBounds: ArrayList[Type[R], out R], upperBounds: ArrayList[Type[R], out R])
    Fun(lhs: Type[R], rhs: Type[R])

let ty = Fun(IntType, IntType)

// fun pp(x) = if x is
//   Int then "Int"
//   Fun(l, r) then pp(l) ~ " -> " ~ pp(r)

// :fixme
fun pp = case
  IntType then "Int"
  Unif(id, lbs, ubs) then "α" ~ String(id)
  Fun(l, r) then pp(l) ~ " -> " ~ pp(r)

pp(ty)
//│ Type: Str


:e
fun matchP = case
  Pair(IntType, IntType) then ()
//│ ╔══[ERROR] Pattern Ident(IntType) is not supported yet.
//│ ║  l.61: 	  Pair(IntType, IntType) then ()
//│ ╙──      	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Pattern Ident(IntType) is not supported yet.
//│ ║  l.61: 	  Pair(IntType, IntType) then ()
//│ ╙──      	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


fun error() = error()

fun solve = case
  Nil then ()
  Cons(c, cs) then if c is
    Pair(lhs, rhs) then
      if lhs is
        IntType then if rhs is
          IntType then ()
          Fun(_, _) | Unif(_, _, _) then error()
        Fun(l1, r1) then  if rhs is
          Fun(l2, r2) then
            solve(Cons(Pair(l2, l1), cs))
            solve(Cons(Pair(r1, r2), cs))
          IntType | Unif(_, _, _) then error()
        Unif(id, lbs, ubs) then
          clear(ubs)
          // iter(ubs, TODO())
          // Handle unification case here
          error() // Placeholder for unification logic

solve
//│ Type: ['Fun, 'Fun, 'eff, 'eff1, 'Unif] -> (Stack[out PairOf[out (Type[out 'Unif] ∧ Type[out 'Fun]) ∧ Type[?], out (((Type[?] ∧ Type[out 'Fun]) ∧ Type[?]) ∧ Type[?]) ∧ Type[?]]] ∧ Stack[?]) ->{('eff1 ∨ 'eff) ∨ 'Unif} ()
//│ Where:
//│   ⊥ <: 'Fun
//│   'Fun <: ⊤
//│   'Fun <: ⊥
//│   'Fun <: 'Fun
//│   ⊥ <: 'Fun
//│   'Fun <: ⊤
//│   'Fun <: 'Fun
//│   'Fun <: ⊥
//│   'Fun <: 'Unif
//│   'Fun <: 'Unif
//│   'Fun <: 'eff
//│   'Fun <: 'eff
//│   ⊥ <: 'eff
//│   'Fun <: 'eff1
//│   'Fun <: 'eff1
//│   'eff <: 'eff1
//│   ⊥ <: 'eff1
//│   'eff1 <: 'eff
//│   'Unif <: 'eff
//│   'Unif <: 'eff1
//│   'Unif <: ⊥







// * Paper example


region r in
  let xs = empty(r)
  xs
//│ Type: ArrayList['A, in 'R]
//│ Where:
//│   'R <: ⊥

region r in
  let xs = empty(r)
  push(xs, "1")
  clear(xs)


region r in // This is used to delimit the scope of mutation
  let xs = empty(r)  // Creates a new mutable list in region r
  push(xs, "1"); push(xs, "2"); push(xs, "3")
  iter(xs, it => foreach(it, e => println(e)))
  clear(xs)

:e
region r in // This is used to delimit the scope of mutation
  let xs = empty(r)  // Creates a new mutable list in region r
  push(xs, "1"); push(xs, "2"); push(xs, "3")
  iter(xs, it => foreach(it, e => println(e); clear(xs)))
//│ ╔══[ERROR] Type error in function literal with expected type (Iter['T, S]) ->{S ∨ 'E} 'Res
//│ ║  l.148: 	  iter(xs, it => foreach(it, e => println(e); clear(xs)))
//│ ║         	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  'R ∨ 'E1  <:  S ∨ 'E
//│ ╟── because: cannot constrain  'E1  <:  'E ∨ S
//│ ╟── because: cannot constrain  'R1  <:  'E ∨ S
//│ ╟── because: cannot constrain  ¬'S1 ∧ 'R1  <:  'E
//│ ╟── because: cannot constrain  ¬'S1 ∧ 'R1  <:  ¬'R2
//│ ╟── because: cannot constrain  'R2 ∧ 'R1  <:  'S1
//│ ╟── because: cannot constrain  'R2 ∧ 'R1  <:  ⊥
//│ ╟── because: cannot constrain  'R2  <:  ¬'R1
//│ ╟── because: cannot constrain  'R1  <:  ¬'R1
//│ ╟── because: cannot constrain  'R1  <:  ⊥
//│ ╙── because: cannot constrain  r  <:  ⊥



// ––––––––– TO IMPROVE LATER –––––––––


// TODO: simplify

fun test(x) = case
  IntType then TODO()
  Fun(l1, r1) then TODO()
  Unif(id, lbs, ubs) then clear(ubs)

test
//│ Type: ['Unif] -> ⊤ -> (((Type[out 'Unif] ∧ Type[?]) ∧ Type[?]) ->{'Unif} ())
//│ Where:
//│   'Unif <: ⊥




// ––––––––– TO FIX LATER –––––––––


:fixme
fun solve = case
  Nil then ()
  Cons(c, cs) then if c is
    Pair(lhs, rhs) then
      if lhs is
        IntType then if rhs is
          IntType then ()
          else error()
        Fun(l1, r1) then  if rhs is
          Fun(l2, r2) then
            solve(Cons(Pair(l2, l1), cs))
            solve(Cons(Pair(r1, r2), cs))
          else error()
        Unif(id, lbs, ubs) then
          // Handle unification case here
          error() // Placeholder for unification logic
//│ ╔══[ERROR] Expect 3 cases, but 1 got.
//│ ║  l.194: 	          IntType then ()
//│ ║         	          ^^^^^^^^^^^^^^^
//│ ║  l.195: 	          else error()
//│ ╙──       	^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Expect 3 cases, but 1 got.
//│ ║  l.197: 	          Fun(l2, r2) then
//│ ║         	          ^^^^^^^^^^^^^^^^
//│ ║  l.198: 	            solve(Cons(Pair(l2, l1), cs))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.199: 	            solve(Cons(Pair(r1, r2), cs))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.200: 	          else error()
//│ ╙──       	^^^^^^^^^^^^^^^^^^^^^^

// Q: why is it not complaining, here?
// :fixme
fun solve = case
  Nil then ()
  Cons(c, cs) and c is
    Pair(lhs, rhs) and lhs is
      IntType and rhs is
        IntType then ()
        else error()
      Fun(l1, r1) and rhs is
        Fun(l2, r2) then
          solve(Cons(Pair(l2, l1), cs))
          solve(Cons(Pair(r1, r2), cs))
        else error()
      Unif(id, lbs, ubs) then
        // Handle unification case here
        error() // Placeholder for unification logic

solve
//│ Type: (Stack[out PairOf[out Type[?], out Type[?]]] ∧ Stack[?]) -> ()


