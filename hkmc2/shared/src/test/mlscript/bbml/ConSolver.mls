:bbml


fun (~) concat: (Str, Str) -> Str

class PairOf[A, B] with
  constructor
    Pair(fst: A, snd: B)

class Stack[A] with
  constructor
    Nil
    Cons(head: A, tail: Stack[A])

class Seq[A, R]

fun
  empty: [A, R] -> Region[R] ->{R} Seq[out A, out R]
  clear: [A, R] -> (Seq[A, R]) ->{R} ()
  push:  [A, R] -> (Seq[A, R], A) ->{R} ()

push
//│ Type: ['A, 'R] -> (Seq['A, 'R], 'A) ->{'R} ()


class Type[R] with
  constructor
    IntType
    Unif(id: Int, lowerBounds: Seq[Type[R], out R], upperBounds: Seq[Type[R], out R])
    Fun(lhs: Type[R], rhs: Type[R])

let ty = Fun(IntType, IntType)

// fun pp(x) = if x is
//   Int then "Int"
//   Fun(l, r) then pp(l) ~ " -> " ~ pp(r)

// :fixme
fun pp = case
  IntType then "Int"
  Unif(id, lbs, ubs) then "α" ~ String(id)
  Fun(l, r) then pp(l) ~ " -> " ~ pp(r)

pp(ty)
//│ Type: Str

fun error() = error()

fun solve = case
  Nil then ()
  Cons(c, cs) then if c is
    Pair(lhs, rhs) then
      if lhs is
        IntType then if rhs is
          IntType then ()
          Fun(_, _) | Unif(_, _, _) then error()
        Fun(l1, r1) then  if rhs is
          Fun(l2, r2) then
            solve(Cons(Pair(l2, l1), cs))
            solve(Cons(Pair(r1, r2), cs))
          IntType | Unif(_, _, _) then error()
        Unif(id, lbs, ubs) then
          // Handle unification case here
          error() // Placeholder for unification logic

solve
//│ Type: (Stack[out PairOf[out Type[?], out Type[?]]] ∧ Stack[?]) -> ()













// ––––––––– TO FIX LATER –––––––––


:fixme
fun solve = case
  Nil then ()
  Cons(c, cs) then if c is
    Pair(lhs, rhs) then
      if lhs is
        IntType then if rhs is
          IntType then ()
          else error()
        Fun(l1, r1) then  if rhs is
          Fun(l2, r2) then
            solve(Cons(Pair(l2, l1), cs))
            solve(Cons(Pair(r1, r2), cs))
          else error()
        Unif(id, lbs, ubs) then
          // Handle unification case here
          error() // Placeholder for unification logic
//│ ╔══[ERROR] Expect 3 cases, but 1 got.
//│ ║  l.91: 	          IntType then ()
//│ ║        	          ^^^^^^^^^^^^^^^
//│ ║  l.92: 	          else error()
//│ ╙──      	^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Expect 3 cases, but 1 got.
//│ ║  l.94: 	          Fun(l2, r2) then
//│ ║        	          ^^^^^^^^^^^^^^^^
//│ ║  l.95: 	            solve(Cons(Pair(l2, l1), cs))
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.96: 	            solve(Cons(Pair(r1, r2), cs))
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.97: 	          else error()
//│ ╙──      	^^^^^^^^^^^^^^^^^^^^^^

// Q: why is it not complaining, here?
// :fixme
fun solve = case
  Nil then ()
  Cons(c, cs) and c is
    Pair(lhs, rhs) and lhs is
      IntType and rhs is
        IntType then ()
        else error()
      Fun(l1, r1) and rhs is
        Fun(l2, r2) then
          solve(Cons(Pair(l2, l1), cs))
          solve(Cons(Pair(r1, r2), cs))
        else error()
      Unif(id, lbs, ubs) then
        // Handle unification case here
        error() // Placeholder for unification logic

solve
//│ Type: (Stack[out PairOf[out Type[?], out Type[?]]] ∧ Stack[?]) -> ()


