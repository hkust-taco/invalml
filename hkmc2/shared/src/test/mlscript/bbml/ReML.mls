:js
:bbml


fun (;) seq(_, res) = res

fun (~) concat: (Str, Str) -> Str
fun concat(a, b) = @untyped a + b

// fun (???) TODO() = TODO()


fun println: Any -> ()
fun println(x) = @untyped globalThis.console.log(x)


println(1)
//│ > 1

"a" ~ "b"
//│ = "ab"
//│ Type: Str


// *** infrastructures


declare class Array[T, R]


class Pair[T, S] with
  constructor
    Pr(fst: T, snd: S)


fun mkArray: [T, R] -> Region[R] ->{R} Array[T, out R]
fun mkArray(r) = @untyped globalThis.Array()


fun push: [T, R] -> (Array[in T, out R], T) ->{R} ()
fun push(xs, x) = @untyped xs.push(x); ()


// push an element to front
fun unshift: [T, R] -> (Array[in T, out R], T) ->{R} ()
fun unshift(xs, x) = @untyped xs.unshift(x); ()


fun map: [T, S, R, E extends ~R] -> (Array[out T, out R], T ->{E} S) ->{E | R} Array[S, out R]
fun map(xs, f) = @untyped xs.map(f)


fun foreach: [T, R, E extends ~R] -> (Array[out T, out R], T ->{E} ()) ->{E | R} ()
fun foreach(xs, f) = @untyped xs.forEach(f)


fun len: [R] -> Array[in Nothing out Any, out R] ->{R} Int
fun len(xs) = @untyped xs.length


fun at: [T, R] -> (Array[out T, out R], Int) ->{R} T
fun at(xs, i) = @untyped xs.at(i)


fun slice: [T, R] -> (Array[out T, out R], Int) ->{R} Array[out T, out R]
fun slice(xs, i) = @untyped xs.slice(i)


fun concat: [T, R1, R2, R3] -> (Region[R3], Array[in T, out R1], Array[out T, out R2]) ->{R1 | R2 | R3} Array[T, out R3]
fun concat(r, xs, ys) = @untyped xs.concat(ys)


fun freezeArr: [T, R, E extends ~R] -> (Array[in Nothing, out Any], () ->{E} T) ->{E} T
fun freezeArr(xs, f) = f()


// matching on js array is not supported yet.
fun matchOne(xs, fn, fh) =
  if len(xs) is 0 then fn(xs)
  else fh(at(xs, 0), slice(xs, 1))

// fun matchTwo: [T, R, E1, E2, E3, S] -> (Array[out T, out R], Array[out T, out R] ->{E1} S, T ->{E2} S, (T, T, Array[out T, out R]) ->{E3} S) ->{E1 | E2 | E3 | R} S
fun matchTwo(xs, fn, f1, f2) =
  if len(xs) is 0 then fn(xs)
  else if len(xs) is 1 then f1(at(xs, 0))
  else f2(at(xs, 0), at(xs, 1), slice(xs, 2))

// it should have some primitive effects
// but we don't support for now
fun rand: () -> Int
fun rand() = @untyped globalThis.Math.floor(globalThis.Math.random() * 1000)


fun toString: Any -> Str
fun toString(x) = @untyped globalThis.String(x)


// it is not really executed in parallel
// but it is enough to display the ability of our type system
fun forkJoin: [T, S, P, E1, E2 extends ~E1, E3] ->
  (() ->{E1} T, () ->{E2} S, (T, S) ->{E3} P) ->{E1 | E2 | E3} P
fun forkJoin(f, g, h) =
  let x = f()
  let y = g()
  h(x, y)

// *** pmsort implementation


fun split(xs, r1, r2) =
  fun rs(xs, ys, zs) =
    matchTwo of xs, _ => Pr(ys, zs), x => push(ys, x); Pr(ys, zs), (x1, x2, r) => push(ys, x1); push(zs, x2); rs(r, ys, zs)
  rs(xs, mkArray(r1), mkArray(r2))


// fun merge: [T, R1, R2, R] -> (Array[out T, out R1], Array[out T, out R2], Region[R]) ->{R1 | R2 | R} Array[T, out R]
fun merge(arr1, arr2, r) =
  fun recm(xs, ys, acc) =
    matchOne of xs, _ => concat(r, acc, ys), (x, rx) =>
      matchOne of ys, _ => concat(r, acc, xs), (y, ry) =>
        if x < y then push(acc, x); recm(rx, ys, acc)
        else push(acc, y); recm(xs, ry, acc)
  recm(arr1, arr2, mkArray(r))


fun smsort(xs, r) =
  matchTwo of xs, _ => mkArray(r), x => let res = mkArray(r) in push(res, x); res, (_, _, _) =>
    let p = split(xs, r, r) in
      if p is Pr(fst, snd) then merge(smsort(fst, r), smsort(snd, r), r)


:e // wrong version!
// fun pmsort: [R1, R2] -> (Array[out Int, out R1], Region[R2]) ->{R1 | R2} Array[Int, out R2]
fun pmsort(xs, r) =
  matchTwo of xs, _ => mkArray(r), x => let res = mkArray(r) in push(res, x); res, (_, _, _) =>
    let p = split(xs, r, r) in
      if p is Pr(fst, snd) then
        forkJoin(_ => pmsort(fst, r), pmsort(snd, r), (r1, r2) => merge(r1, r2, r))
//│ ╔══[ERROR] Cannot type this function literal as () ->{'E1} 'T
//│ ║  l.138: 	        forkJoin(_ => pmsort(fst, r), pmsort(snd, r), (r1, r2) => merge(r1, r2, r))
//│ ╙──       	                      ^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type error in function literal
//│ ║  l.134: 	fun pmsort(xs, r) =
//│ ║         	           ^^^^^^^^
//│ ║  l.135: 	  matchTwo of xs, _ => mkArray(r), x => let res = mkArray(r) in push(res, x); res, (_, _, _) =>
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  ('xs, 'r) ->{'R ∨ 'eff ∨ 'R1 ∨ 'eff1 ∨ 'R2 ∨ 'eff2 ∨ 'R3 ∨ 'R4 ∨ 'R5} ('app ∨ 'app1 ∨ 'app2)  <:  'pmsort
//│ ╟── because: cannot constrain  ('xs, 'r) ->{'R ∨ 'eff ∨ 'R1 ∨ 'eff1 ∨ 'R2 ∨ 'eff2 ∨ 'R3 ∨ 'R4 ∨ 'R5} ('app ∨ 'app1 ∨ 'app2)  <:  ('S, 'r) ->{'eff3} ('app3)
//│ ╟── because: cannot constrain  'app ∨ 'app1 ∨ 'app2  <:  'app3
//│ ╟── because: cannot constrain  'app  <:  'app3
//│ ╟── because: cannot constrain  'app  <:  () ->{'E2} ('S1)
//│ ╙── because: cannot constrain  Array['T1, in ⊥ out 'R6]  <:  () ->{'E2} ('S1)
//│ ╔══[ERROR] Type error in function literal
//│ ║  l.134: 	fun pmsort(xs, r) =
//│ ║         	           ^^^^^^^^
//│ ║  l.135: 	  matchTwo of xs, _ => mkArray(r), x => let res = mkArray(r) in push(res, x); res, (_, _, _) =>
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  ('xs, 'r) ->{'R ∨ 'eff ∨ 'R1 ∨ 'eff1 ∨ 'R2 ∨ 'eff2 ∨ 'R3 ∨ 'R4 ∨ 'R5} ('app ∨ 'app1 ∨ 'app2)  <:  'pmsort
//│ ╟── because: cannot constrain  ('xs, 'r) ->{'R ∨ 'eff ∨ 'R1 ∨ 'eff1 ∨ 'R2 ∨ 'eff2 ∨ 'R3 ∨ 'R4 ∨ 'R5} ('app ∨ 'app1 ∨ 'app2)  <:  ('S, 'r) ->{'eff3} ('app3)
//│ ╟── because: cannot constrain  'app ∨ 'app1 ∨ 'app2  <:  'app3
//│ ╟── because: cannot constrain  'app1  <:  'app3
//│ ╟── because: cannot constrain  'app1  <:  () ->{'E2} ('S1)
//│ ╙── because: cannot constrain  Array['T2, in ⊥ out 'R7]  <:  () ->{'E2} ('S1)
//│ ╔══[ERROR] Type error in function literal
//│ ║  l.134: 	fun pmsort(xs, r) =
//│ ║         	           ^^^^^^^^
//│ ║  l.135: 	  matchTwo of xs, _ => mkArray(r), x => let res = mkArray(r) in push(res, x); res, (_, _, _) =>
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  ('xs, 'r) ->{'R ∨ 'eff ∨ 'R1 ∨ 'eff1 ∨ 'R2 ∨ 'eff2 ∨ 'R3 ∨ 'R4 ∨ 'R5} ('app ∨ 'app1 ∨ 'app2)  <:  'pmsort
//│ ╟── because: cannot constrain  ('xs, 'r) ->{'R ∨ 'eff ∨ 'R1 ∨ 'eff1 ∨ 'R2 ∨ 'eff2 ∨ 'R3 ∨ 'R4 ∨ 'R5} ('app ∨ 'app1 ∨ 'app2)  <:  ('S, 'r) ->{'eff3} ('app3)
//│ ╟── because: cannot constrain  'app ∨ 'app1 ∨ 'app2  <:  'app3
//│ ╟── because: cannot constrain  'app2  <:  'app3
//│ ╟── because: cannot constrain  'app2  <:  () ->{'E2} ('S1)
//│ ╙── because: cannot constrain  Array['T3, in ⊥ out 'R31]  <:  () ->{'E2} ('S1)
//│ ╔══[ERROR] Type error in function literal
//│ ║  l.134: 	fun pmsort(xs, r) =
//│ ║         	           ^^^^^^^^
//│ ║  l.135: 	  matchTwo of xs, _ => mkArray(r), x => let res = mkArray(r) in push(res, x); res, (_, _, _) =>
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  ('xs, 'r) ->{'R ∨ 'eff ∨ 'R1 ∨ 'eff1 ∨ 'R2 ∨ 'eff2 ∨ 'R3 ∨ 'R4 ∨ 'R5} ('app ∨ 'app1 ∨ 'app2)  <:  'pmsort
//│ ╟── because: cannot constrain  ('xs, 'r) ->{'R ∨ 'eff ∨ 'R1 ∨ 'eff1 ∨ 'R2 ∨ 'eff2 ∨ 'R3 ∨ 'R4 ∨ 'R5} ('app ∨ 'app1 ∨ 'app2)  <:  ('S, 'r) ->{'eff3} ('app3)
//│ ╟── because: cannot constrain  'app ∨ 'app1 ∨ 'app2  <:  'app3
//│ ╟── because: cannot constrain  'app2  <:  'app3
//│ ╟── because: cannot constrain  'app2  <:  () ->{'E2} ('S1)
//│ ╙── because: cannot constrain  Array['T4, in ⊥ out 'R32]  <:  () ->{'E2} ('S1)


fun pmsort: [R1, R2] -> (Array[out Int, out R1], Region[R2]) ->{R1 | R2} Array[Int, out R2]
fun pmsort(xs, r) =
  matchTwo of xs, _ => mkArray(r), x => let res = mkArray(r) in push(res, x); res, (_, _, _) =>
    region r1 in
      region r2 in
        let p = split(xs, r1, r2) in
          if p is Pr(fst, snd) then
            forkJoin(() => pmsort(fst, r1), () => pmsort(snd, r2), (rx, ry) => merge(rx, ry, r))


// *** simple tests


fun randArr(r, n) =
  if n is 0 then mkArray(r)
  else
    let x = rand()
    let xs = randArr(r, n - 1)
    push(xs, x)
    xs


fun printArr(xs) =
  foreach(xs, x => println(x))


region r in
  let arr = mkArray(r)
  push(arr, 1)
  push(arr, 2)
  push(arr, 3)
  push(arr, 4)
  let p = split(arr, r, r)
  if p is
    Pr(fst, snd) then
      merge(fst, snd, r)
//│ = [1, 2, 3, 4]
//│ Type: Array[in 'T out 'T ∨ Int, ?] ∨ Array[in 'T1 out ('T1 ∨ Int) ∨ Int, ?]


region r in
  let arr = mkArray(r)
  push(arr, 10)
  push(arr, 23)
  push(arr, 13)
  push(arr, 4)
  smsort(arr, r)
//│ = [4, 10, 13, 23]
//│ Type: ((Array['T, ?] ∨ Array[in 'T1 out 'T1 ∨ Int, ?]) ∨ Array[in 'T2 out (((((((((((((('T2 ∨ 'T3) ∨ 'T4) ∨ 'T1) ∨ Int) ∨ 'T) ∨ 'T1) ∨ Int) ∨ 'T) ∨ 'T1) ∨ Int) ∨ 'T) ∨ 'T4) ∨ 'T1) ∨ Int) ∨ 'T, ?]) ∨ Array[in 'T3 out (((((('T3 ∨ 'T4) ∨ 'T1) ∨ Int) ∨ 'T) ∨ 'T1) ∨ Int) ∨ 'T, ?]
//│ Where:
//│   'T <: Int
//│   'T1 <: Int
//│   'T4 <: Int
//│   'T3 <: Int
//│   'T3 <: 'T4
//│   'T2 <: Int
//│   'T2 <: 'T4
//│   'T2 <: 'T3 ∧ Int
//│   'T2 <: 'T3


// region r in
//   let arr = randArr(r, 5)
//   smsort(arr, r)



region r in
  let arr = mkArray(r)
  push(arr, 10)
  push(arr, 23)
  push(arr, 13)
  push(arr, 4)
  pmsort(arr, r)
//│ = [4, 10, 13, 23]
//│ Type: Array[Int, ?]
