:js
:bbml

:...
//│ ————————————————————————————————————————————————————————————————————————————————


// *** infrastructures


declare class Array[T, R]


class Pair[T, S] with
  constructor
    Pr(fst: T, snd: S)


fun mkArray: [T, R] -> Region[R] ->{R} Array[T, out R]
fun mkArray(r) = @untyped globalThis.Array()


fun push: [T, R] -> (Array[in T, out R], T) ->{R} ()
fun push(xs, x) = @untyped xs.push(x); ()


// push an element to front
fun unshift: [T, R] -> (Array[in T, out R], T) ->{R} ()
fun unshift(xs, x) = @untyped xs.unshift(x); ()


fun map: [T, S, R, E extends ~R] -> (Array[out T, out R], T ->{E} S) ->{E | R} Array[S, out R]
fun map(xs, f) = @untyped xs.map(f)


fun foreach: [T, R, E extends ~R] -> (Array[out T, out R], T ->{E} ()) ->{E | R} ()
fun foreach(xs, f) = @untyped xs.forEach(f)


fun len: [R] -> Array[in Nothing out Any, out R] ->{R} Int
fun len(xs) = @untyped xs.length


fun at: [T, R] -> (Array[out T, out R], Int) ->{R} T
fun at(xs, i) = @untyped xs.at(i)


fun slice: [T, R] -> (Array[out T, out R], Int) ->{R} Array[out T, out R]
fun slice(xs, i) = @untyped xs.slice(i)


fun concat: [T, R1, R2, R3] -> (Region[R3], Array[in T, out R1], Array[out T, out R2]) ->{R1 | R2 | R3} Array[T, out R3]
fun concat(r, xs, ys) = @untyped xs.concat(ys)


fun freezeArr: [T, R, E extends ~R] -> (Array[in Nothing, out Any], () ->{E} T) ->{E} T
fun freezeArr(xs, f) = f()


// matching on js array is not supported yet.
fun matchOne(xs, fn, fh) =
  if len(xs) is 0 then fn(xs)
  else fh(at(xs, 0), slice(xs, 1))

// fun matchTwo: [T, R, E1, E2, E3, S] -> (Array[out T, out R], Array[out T, out R] ->{E1} S, T ->{E2} S, (T, T, Array[out T, out R]) ->{E3} S) ->{E1 | E2 | E3 | R} S
fun matchTwo(xs, fn, f1, f2) =
  if len(xs) is 0 then fn(xs)
  else if len(xs) is 1 then f1(at(xs, 0))
  else f2(at(xs, 0), at(xs, 1), slice(xs, 2))

// it should have some primitive effects
// but we don't support for now
fun rand: () -> Int
fun rand() = @untyped globalThis.Math.floor(globalThis.Math.random() * 1000)


fun (;) seq(_, res) = res

fun println: Any -> ()
fun println(x) = @untyped globalThis.console.log(x)


// it is not really executed in parallel
// but it is enough to display the ability of our type system
fun forkJoin: [T, S, P, E1, E2 extends ~E1, E3] ->
  (() ->{E1} T, () ->{E2} S, (T, S) ->{E3} P) ->{E1 | E2 | E3} P
fun forkJoin(f, g, h) =
  let x = f()
  let y = g()
  h(x, y)


// *** pmsort implementation


fun split(xs, r1, r2) =
  fun rs(xs, ys, zs) =
    matchTwo of xs, _ => Pr(ys, zs), x => push(ys, x); Pr(ys, zs), (x1, x2, r) => push(ys, x1); push(zs, x2); rs(r, ys, zs)
  rs(xs, mkArray(r1), mkArray(r2))


// fun merge: [T, R1, R2, R] -> (Array[out T, out R1], Array[out T, out R2], Region[R]) ->{R1 | R2 | R} Array[T, out R]
fun merge(arr1, arr2, r) =
  fun recm(xs, ys, acc) =
    matchOne of xs, _ => concat(r, acc, ys), (x, rx) =>
      matchOne of ys, _ => concat(r, acc, xs), (y, ry) =>
        if x < y then push(acc, x); recm(rx, ys, acc)
        else push(acc, y); recm(xs, ry, acc)
  recm(arr1, arr2, mkArray(r))


fun smsort(xs, r) =
  matchTwo of xs, _ => mkArray(r), x => let res = mkArray(r) in push(res, x); res, (_, _, _) =>
    let p = split(xs, r, r) in
      if p is Pr(fst, snd) then merge(smsort(fst, r), smsort(snd, r), r)


// wrong version!
// fun pmsort: [R1, R2] -> (Array[out Int, out R1], Region[R2]) ->{R1 | R2} Array[Int, out R2]
// fun pmsort(xs, r) =
//   matchTwo of xs, _ => mkArray(r), x => let res = mkArray(r) in push(res, x); res, (_, _, _) =>
//     let p = split(xs, r, r) in
//       if p is Pr(fst, snd) then
//         forkJoin(_ => pmsort(fst, r), pmsort(snd, r), (r1, r2) => merge(r1, r2, r))


fun pmsort: [R1, R2] -> (Array[out Int, out R1], Region[R2]) ->{R1 | R2} Array[Int, out R2]
fun pmsort(xs, r) =
  matchTwo of xs, _ => mkArray(r), x => let res = mkArray(r) in push(res, x); res, (_, _, _) =>
    region r1 in
      region r2 in
        let p = split(xs, r1, r2) in
          if p is Pr(fst, snd) then
            forkJoin(() => pmsort(fst, r1), () => pmsort(snd, r2), (rx, ry) => merge(rx, ry, r))


// *** simple tests


fun randArr(r, n) =
  if n is 0 then mkArray(r)
  else
    let x = rand()
    let xs = randArr(r, n - 1)
    push(xs, x)
    xs


region r in
  let arr = mkArray(r) // you can try: let arr = randArr(r, 10)
  push(arr, 10)
  push(arr, 23)
  push(arr, 13)
  push(arr, 4)
  pmsort(arr, r)
//│ = [4, 10, 13, 23]
//│ Type: Array[Int, ?]
//│ ————————————————————————————————————————————————————————————————————————————————
