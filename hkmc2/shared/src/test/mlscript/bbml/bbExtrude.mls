:bbml
//│ Type: ⊤

//│ Type: ⊤
fun f(y) =
  let local = ((x => y(x) + 1) as [A] -> A -> Int) in y
//│ Type: ⊤

// * the parameter type of y is extruded.
f
//│ Type: ['y] -> 'y -> 'y
//│ Where:
//│   'y <: ⊤ -> Int

fun foo: [A] -> A -> Int
fun foo(x) = 0
//│ Type: ⊤

foo
//│ Type: (⊤) ->{⊥} Int

f(foo)
//│ Type: ⊤ -> Int

fun g: ([A] -> A -> Int) -> ([A] -> A -> Int)
fun g(y) =
  let local = ((x => y(x) + 1) as ([A] -> A -> Int)) in y
//│ Type: ⊤

g
//│ Type: ((⊤) ->{⊥} Int) ->{⊥} (⊤) ->{⊥} Int

g(foo)
//│ Type: (⊤) ->{⊥} Int

:e
y `=> (let t = run(x `=> x `+ y) in y)
//│ ╔══[ERROR] Type error in quoted term with expected type CodeBase[out 'T, ⊥, ?]
//│ ║  l.37: 	y `=> (let t = run(x `=> x `+ y) in y)
//│ ║        	                   ^^^^^^^^^^^^
//│ ╟── because: cannot constrain  CodeBase[in ⊥ out ('x) ->{⊥} ('cde), in ⊥ out 'ctx, in ⊥ out ⊤]  <:  CodeBase[in ⊥ out 'T, ⊥, in ⊥ out ⊤]
//│ ╟── because: cannot constrain  'ctx  <:  ⊥
//│ ╟── because: cannot constrain  'ctx  <:  ⊥
//│ ╟── because: cannot constrain  ¬'x1 ∧ y  <:  ⊥
//│ ╟── because: cannot constrain  y  <:  'x1
//│ ╙── because: cannot constrain  y  <:  ⊥
//│ Type: CodeBase[out 'y -> 'y, ⊥, ?]
//│ Where:
//│   'y <: Int

data class C[A](m: A, n: A -> Int)
//│ Type: ⊤


fun f: [A] -> ([B] -> (C[out B] & A) -> B) -> A -> Int
f
//│ Type: ['A] -> (['B] -> (C[out 'B] ∧ 'A) ->{⊥} 'B) ->{⊥} ('A) ->{⊥} Int

fun g: [D] -> C[in Int out D] -> D
g
//│ Type: ['D] -> (C[in Int out 'D]) ->{⊥} 'D


f(g)
//│ Type: (¬C[?] ∨ C[in Int out ⊥]) ->{⊥} Int

fun foo: C[in Int out Nothing]
foo
//│ Type: C[in Int out ⊥]

fun bar: C[in Int out Int]
bar
//│ Type: C[Int]

f(g)(foo)
//│ Type: Int

:fixme // ???
f(g)(bar)
//│ ╔══[ERROR] Type error in reference with expected type 'A
//│ ║  l.79: 	f(g)(bar)
//│ ║        	     ^^^
//│ ╟── because: cannot constrain  C[Int]  <:  'A
//│ ╟── because: cannot constrain  C[Int]  <:  'A
//│ ╟── because: cannot constrain  C[Int]  <:  ¬{C[in ⊥ out ¬⊥ ∧ 'B]} ∨ C[in Int out 'D]
//│ ╟── because: cannot constrain  Int ∧ 'B  <:  'D
//│ ╟── because: cannot constrain  Int ∧ 'B  <:  'D
//│ ╟── because: cannot constrain  Int ∧ 'B  <:  'B1
//│ ╟── because: cannot constrain  Int ∧ 'B  <:  'B1
//│ ╟── because: cannot constrain  Int ∧ 'B  <:  ⊥
//│ ╟── because: cannot constrain  'B  <:  ¬{Int}
//│ ╙── because: cannot constrain  ⊤  <:  ¬{Int}
//│ Type: Int

fun k(x) =
  fun f(y) = x(y)
  f(0) + 0
k
//│ Type: ['eff] -> (Int ->{'eff} Int) ->{'eff} Int

:e
k(_ => "")
//│ ╔══[ERROR] Type error in function literal with expected type 'x
//│ ║  l.102: 	k(_ => "")
//│ ║         	       ^^
//│ ╟── because: cannot constrain  ('_) ->{⊥} (Str)  <:  'x
//│ ╟── because: cannot constrain  ('_) ->{⊥} (Str)  <:  'x
//│ ╟── because: cannot constrain  ('_) ->{⊥} (Str)  <:  (Int) ->{'eff} (Int)
//│ ╙── because: cannot constrain  Str  <:  Int
//│ Type: Int

k(_ => 42)
//│ Type: Int


fun k(x) =
  fun f: [S, T] -> S -> T
  fun f(y) = x(y)
  f(0) + 0
k
//│ Type: (⊤ -> ⊥) -> Int


:e
k(_ => "")
//│ ╔══[ERROR] Type error in function literal with expected type 'x
//│ ║  l.125: 	k(_ => "")
//│ ║         	       ^^
//│ ╟── because: cannot constrain  ('_) ->{⊥} (Str)  <:  'x
//│ ╟── because: cannot constrain  ('_) ->{⊥} (Str)  <:  'x
//│ ╟── because: cannot constrain  ('_) ->{⊥} (Str)  <:  (⊤) ->{⊥} ⊥
//│ ╙── because: cannot constrain  Str  <:  ⊥
//│ Type: Int

:e
k(_ => 42)
//│ ╔══[ERROR] Type error in function literal with expected type 'x
//│ ║  l.136: 	k(_ => 42)
//│ ║         	       ^^
//│ ╟── because: cannot constrain  ('_) ->{⊥} (Int)  <:  'x
//│ ╟── because: cannot constrain  ('_) ->{⊥} (Int)  <:  'x
//│ ╟── because: cannot constrain  ('_) ->{⊥} (Int)  <:  (⊤) ->{⊥} ⊥
//│ ╙── because: cannot constrain  Int  <:  ⊥
//│ Type: Int


fun k(x) =
  let f = y => x(y)
  f(0) + 0
k
//│ Type: ['eff] -> (Int ->{'eff} Int) ->{'eff} Int
