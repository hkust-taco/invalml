:bbml

:...
//│ ————————————————————————————————————————————————————————————————————————————————

// * In this file, we implement a simple constraint solver, originally presented in https://doi.org/10.1145/3410225
// * We only implement int type, function types, and type variables for simplicity

// *** infrastructures

class PairOf[A, B] with
  constructor
    Pair(fst: A, snd: B)

class Stack[A] with
  constructor
    Nil
    Cons(head: A, tail: Stack[out A])

class ArrayList[A, R]
class Iter[T, R]


fun
  empty:   [A, R] -> Region[R] ->{R} ArrayList[A, out R]
  clear:   [A, R] -> (ArrayList[A, out R]) ->{R} ()
  push:    [A, R] -> (ArrayList[A, out R], A) ->{R} ()
  foreach: [E, R, T] -> (Iter[T, R], T ->{E} ()) ->{R | E} ()
  iter: [Res, R, E extends ~R, T] ->
    (ArrayList[T, out R], [S] -> Iter[T, S] ->{S | E} Res) ->{E | R} Res
  fold: [Res, R, E extends ~R, T] ->
    (ArrayList[T, out R], Res, [S] -> (Iter[T, S], Res) ->{S | E} Res) ->{E | R} Res
  read: [T, S] -> Iter[T, S] ->{S} T

fun error() = error()


// *** simple constraint solver


// Unif contains a type variable's id, lower bounds, and upper bounds.
class Type[R] with
  constructor
    IntType
    Unif(id: Int, lowerBounds: ArrayList[Type[R], out R], upperBounds: ArrayList[Type[R], out R])
    Fun(lhs: Type[R], rhs: Type[R])


fun solve(lst) = if lst is
  Nil then ()
  Cons(c, cs) then if c is
    Pair(lhs, rhs) then
      if lhs is
        IntType then if rhs is
          IntType then ()
          Fun(_, _) then error()
          Unif(id, lbs, ubs) then
            push(lbs, lhs)
            let ncs = fold(ubs, cs, (it, lst) => Cons(Pair(lhs, read(it)), lst))
            solve(ncs)
        Fun(l1, r1) then if rhs is
          Fun(l2, r2) then
            solve(Cons(Pair(l2, l1), Cons(Pair(r1, r2), cs)))
          IntType then error()
          Unif(id, lbs, ubs) then
            push(lbs, lhs)
            let ncs = fold(ubs, cs, (it, lst) => Cons(Pair(lhs, read(it)), lst))
            solve(ncs)
        Unif(id, lbs, ubs) then
          push(ubs, rhs)
          let ncs = fold(lbs, cs, (it, lst) => Cons(Pair(read(it), rhs), lst))
          solve(ncs)

// *** error example

// if we call the `solve` function during the iteration, the `solve` function
// can only handle the cases where no allocation is required (i.e., no type variables)
// fun solve(lst) = if lst is
//   Nil then ()
//   Cons(c, cs) then if c is
//     Pair(lhs, rhs) then
//       if lhs is
//         IntType then if rhs is
//           IntType then ()
//           Fun(_, _) then error()
//           Unif(id, lbs, ubs) then
//             push(lbs, lhs)
//             iter(lbs, it => solve(Cons(Pair(lhs, read(it)), Nil)))
//             solve(cs)
//         Fun(l1, r1) then  if rhs is
//           Fun(l2, r2) then
//             solve(Cons(Pair(l2, l1), Cons(Pair(r1, r2), cs)))
//           IntType then error()
//           Unif(id, lbs, ubs) then
//             push(lbs, lhs)
//             iter(lbs, it => solve(Cons(Pair(lhs, read(it)), Nil)))
//             solve(cs)
//         Unif(id, lbs, ubs) then
//           push(ubs, rhs)
//           iter(lbs, it => solve(Cons(Pair(read(it), rhs), Nil)))
//           solve(cs)


// The error' version of `solve` function can only be used for constraints without type variables
// solve(Cons(Pair(IntType, IntType), Nil))

// Calling the `solve` function to solve constraints involving type variables will lead to type errors
// region r in
//   let v1 = Unif(1, empty(r), empty(r))
//   let v2 = Unif(2, empty(r), empty(r))
//   solve(Cons(Pair(v1, Fun(IntType, v2)), Nil))

// *** examples

region r in
  solve(Cons(Pair(IntType, IntType), Nil))

region r in
  solve(Cons(Pair(IntType, Fun(IntType, IntType)), Nil))

region r in
  let v1 = Unif(1, empty(r), empty(r))
  let v2 = Unif(2, empty(r), empty(r))
  solve(Cons(Pair(v1, Fun(IntType, v2)), Nil))

//│ ————————————————————————————————————————————————————————————————————————————————
