:bbml
//│ Type: ⊤

//│ Type: ⊤


class IntList with
  constructor
    Nil
    Cons(x: Int, xs: IntList)
//│ Type: ⊤

Nil
//│ Type: IntList

Cons(1, Cons(2, Cons(3, Nil)))
//│ Type: IntList


:e
class Foo with
  constructor
    Bar(x)
//│ ╔══[ERROR] Invalid ADT parameter.
//│ ║  l.23: 	    Bar(x)
//│ ╙──      	        ^
//│ Type: ⊤


:e
Nil(1)
//│ ╔══[ERROR] Type error in application
//│ ║  l.31: 	Nil(1)
//│ ║        	^^^^^^
//│ ╙── because: cannot constrain  IntList  <:  (Int) ->{'eff} ('app)
//│ Type: ⊥

:e
Nil()
//│ ╔══[ERROR] Type error in application
//│ ║  l.39: 	Nil()
//│ ║        	^^^^^
//│ ╙── because: cannot constrain  IntList  <:  () ->{'eff} ('app)
//│ Type: ⊥


:e
Cons("1", Nil)
//│ ╔══[ERROR] Type error in string literal with expected type Int
//│ ║  l.48: 	Cons("1", Nil)
//│ ║        	     ^^^
//│ ╙── because: cannot constrain  Str  <:  Int
//│ Type: IntList


class Option[T] with
  constructor
    None
    Some(x: T)
//│ Type: ⊤


None
//│ Type: Option[in ⊤ out ⊥]

Some(42)
//│ Type: Option[in ⊤ out Int]

Some(false)
//│ Type: Option[in ⊤ out Bool]


class Fun[T, S] with
  constructor
    Pure(f: T -> S)
//│ Type: ⊤


Pure(x => x + 1)
//│ Type: Fun[in Int out ⊥, in ⊤ out Int]


class Value[T] with
  constructor
    IntVal(x: Int) extends Value[out Int]
    BoolVal(x: Bool) extends Value[out Bool]
//│ Type: ⊤

IntVal(42)
//│ Type: Value[out Int]

BoolVal(false)
//│ Type: Value[out Bool]

:e
IntVal("1")
//│ ╔══[ERROR] Type error in string literal with expected type Int
//│ ║  l.96: 	IntVal("1")
//│ ║        	       ^^^
//│ ╙── because: cannot constrain  Str  <:  Int
//│ Type: Value[out Int]

class Expr[T] with
  constructor
    Lit[S](x: S) extends Expr[out S]
    Var[S](nme: Str) extends Expr[out S]
    Add(lhs: Expr[out Int], rhs: Expr[out Int]) extends Expr[out Int]
    Lam[U, V](f: Expr[out U] -> Expr[out V]) extends Expr[out U -> V]
    App[U, V](f: Expr[out U -> V], a: Expr[out U]) extends Expr[out V]
//│ Type: ⊤

let a = Lit(42)
a
//│ Type: Expr[out Int]

let f = Lam(x => Add(x, Lit(1)))
f
//│ Type: Expr[out Int -> Int]

:e
Lam(42)
//│ ╔══[ERROR] Type error in integer literal with expected type (Expr[out 'U]) ->{⊥} Expr[out 'V]
//│ ║  l.121: 	Lam(42)
//│ ║         	    ^^
//│ ╙── because: cannot constrain  Int  <:  (Expr[in ⊥ out 'U]) ->{⊥} (Expr[in ⊥ out 'V])
//│ Type: Expr[out ⊤ -> ⊥]

App(f, a)
//│ Type: Expr[out Int]


let b = Lit(true)
b
//│ Type: Expr[out Bool]

:e
App(f, b)
//│ ╔══[ERROR] Type error in reference with expected type Expr[out 'U]
//│ ║  l.137: 	App(f, b)
//│ ║         	       ^
//│ ╟── because: cannot constrain  Expr[in ⊥ out 'S]  <:  Expr[in ⊥ out 'U]
//│ ╟── because: cannot constrain  'S  <:  'U
//│ ╟── because: cannot constrain  'S  <:  'U
//│ ╟── because: cannot constrain  'S  <:  'U1
//│ ╟── because: cannot constrain  'S  <:  'U1
//│ ╟── because: cannot constrain  Bool  <:  'U1
//│ ╟── because: cannot constrain  Bool  <:  'U1
//│ ╙── because: cannot constrain  Bool  <:  Int
//│ Type: Expr[out Int]


fun sum(xs) =
  if xs is
    Nil then 0
    Cons(x, xs) then x + sum(xs)
sum
//│ Type: IntList -> Int


sum(Cons(1, Cons(2, Cons(3, Cons(4, Nil)))))
//│ Type: Int


:e
fun badSum(xs) =
  if xs is
    Cons(x, xs) then x + badSum(xs)
//│ ╔══[ERROR] Expect 2 cases, but 1 got.
//│ ║  l.167: 	    Cons(x, xs) then x + badSum(xs)
//│ ╙──       	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ Type: ⊤

:e
fun badSum(xs) =
  if xs is
    Cons(x, xs) then x + badSum(xs)
    Cons(x, xs) then x + badSum(xs)
//│ ╔══[ERROR] Duplicate match branches.
//│ ║  l.176: 	    Cons(x, xs) then x + badSum(xs)
//│ ║         	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.177: 	    Cons(x, xs) then x + badSum(xs)
//│ ╙──       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Expect 2 cases, but 1 got.
//│ ║  l.176: 	    Cons(x, xs) then x + badSum(xs)
//│ ║         	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.177: 	    Cons(x, xs) then x + badSum(xs)
//│ ╙──       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ Type: ⊤


fun getOrElse(m, d) =
  if m is
    Some(x) then x
    None then d
getOrElse
//│ Type: ['d, 'Some] -> (Option[?] ∧ Option[out 'Some], 'd) -> ('Some ∨ 'd)


getOrElse(Some(42), 0)
//│ Type: Int

getOrElse(None, false)
//│ Type: Bool

getOrElse(Some(42), "42")
//│ Type: Int ∨ Str


if IntVal(1) is
  IntVal(x) then 1
  BoolVal(x) then 0
//│ Type: Int


fun toBool(v) =
  if v is
    IntVal(x) then x > 0
    BoolVal(x) then x
toBool
//│ Type: Value[?] -> Bool

toBool(IntVal(1))
//│ Type: Bool


class MyMap[K, V] with
  constructor
    Empty
    Pair(k: K, v: V, rest: MyMap[out K, out V])
//│ Type: ⊤

fun newMap(k, v) = Pair(k, v, Empty)
newMap
//│ Type: ['k, 'v] -> ('k, 'v) -> MyMap[in ⊤ out 'k, in ⊤ out 'v]

fun insert(m, k, v) = Pair(k, v, m)
insert
//│ Type: ['k, 'v, 'K, 'V] -> (MyMap[out 'K, out 'V], 'k, 'v) -> MyMap[in ⊤ out 'K, in ⊤ out 'V]
//│ Where:
//│   'k <: 'K
//│   'v <: 'V


fun getOrElse: [K, V] -> (MyMap[out K, out V], K, V) -> V
fun getOrElse(m, k, d) =
  if m is
    Empty then d
    Pair(k', v, r) then (if k == k' then v else getOrElse(r, k, d))
//│ Type: ⊤

let incMap1 = newMap(1, 2)
incMap1
//│ Type: MyMap[in ⊤ out Int, in ⊤ out Int]

let incMap2 = insert(incMap1, 2, 3)
incMap2
//│ Type: MyMap[in ⊤ out Int, in ⊤ out Int]

getOrElse(incMap2, 3, 4)
//│ Type: Int


fun toString: Any -> Str
//│ Type: ⊤

fun concat: (Str, Str) -> Str
//│ Type: ⊤

fun print: [T] -> Expr[out T] -> Str
fun print(e) = 
  if e is
    Lit(x) then toString(x)
    Var(nme) then nme
    Add(lhs, rhs) then concat(print(lhs), concat(" + ", print(rhs)))
    Lam(f) then
      let v = Var("arg") in concat(print(v), concat(" => ", print(f(v))))
    App(f, a) then concat(print(f), concat(" ", print(a)))
//│ Type: ⊤

let p = Lam(x => Add(x, Lit(1)))
p
//│ Type: Expr[out Int -> Int]

let a = App(p, Lit(2))
a
//│ Type: Expr[out Int]

print(p)
print(a)
//│ Type: Str
