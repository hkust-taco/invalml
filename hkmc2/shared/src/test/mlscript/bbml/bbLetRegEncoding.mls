:bbml



fun letreg: [E,Res] -> ([R] -> Region[R] ->{E | R} Res) ->{E} Res

letreg
//│ Type: ['E, 'Res] -> (['R] -> (Region['R]) ->{'E ∨ 'R} 'Res) ->{'E} 'Res

letreg(r => r)
//│ Type: Region[?]

:e
letreg(r => r).ref 1
//│ ╔══[ERROR] Type error in reference creation
//│ ║  l.14: 	letreg(r => r).ref 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  'Res  <:  Region['reg]
//│ ╟── because: cannot constrain  Region[in 'R out 'R1]  <:  Region['reg]
//│ ╟── because: cannot constrain  'R1  <:  'reg
//│ ╟── because: cannot constrain  'R1  <:  'R
//│ ╟── because: cannot constrain  ⊤  <:  'R
//│ ╙── because: cannot constrain  ⊤  <:  ⊥
//│ ╔══[ERROR] Type error in block
//│ ║  l.14: 	letreg(r => r).ref 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  'reg ∨ 'E  <:  ⊥
//│ ╟── because: cannot constrain  'reg  <:  ⊥
//│ ╟── because: cannot constrain  'R1  <:  ⊥
//│ ╙── because: cannot constrain  ⊤  <:  ⊥
//│ Type: Ref[Int, ?]

letreg(r => r.ref 1)
//│ Type: Ref[Int, ?]

letreg(r => !(r.ref 1))
//│ Type: Int

:e
!letreg(r => r.ref 1)
//│ ╔══[ERROR] Type error in block
//│ ║  l.40: 	!letreg(r => r.ref 1)
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  'reg ∨ 'E  <:  ⊥
//│ ╟── because: cannot constrain  'reg  <:  ⊥
//│ ╟── because: cannot constrain  'reg1  <:  ⊥
//│ ╟── because: cannot constrain  'R  <:  ⊥
//│ ╙── because: cannot constrain  ⊤  <:  ⊥
//│ Type: Int

letreg of r =>
  let x = r.ref 1
  x := !x + 1
  !x
//│ Type: Int

let f = letreg(r => arg => r.ref arg)

f
//│ Type: 'arg ->{⊤} Ref['arg, ?]

:e
letreg(r => arg => r.ref arg)(0)
//│ ╔══[ERROR] Type error in block
//│ ║  l.63: 	letreg(r => arg => r.ref arg)(0)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  'eff ∨ 'E  <:  ⊥
//│ ╟── because: cannot constrain  'eff  <:  ⊥
//│ ╟── because: cannot constrain  'reg  <:  ⊥
//│ ╟── because: cannot constrain  'R  <:  ⊥
//│ ╙── because: cannot constrain  ⊤  <:  ⊥
//│ Type: Ref['arg, ?]
//│ Where:
//│   Int <: 'arg



// * An incorrect one, just for testing the error:

fun letreg: [E,Res] -> ([R] -> Region[R] -> Res) ->{E} Res

:e
letreg(r => r.ref 1)
//│ ╔══[ERROR] Type error in function literal with expected type (Region[R]) ->{⊥} 'Res
//│ ║  l.83: 	letreg(r => r.ref 1)
//│ ║        	       ^^^^^^^^^^^^
//│ ╟── because: cannot constrain  'reg  <:  ⊥
//│ ╙── because: cannot constrain  R  <:  ⊥
//│ Type: Ref[Int, ?]

:e
letreg(r => !(r.ref 1))
//│ ╔══[ERROR] Type error in function literal with expected type (Region[R]) ->{⊥} 'Res
//│ ║  l.92: 	letreg(r => !(r.ref 1))
//│ ║        	       ^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  'reg ∨ 'reg1  <:  ⊥
//│ ╟── because: cannot constrain  'reg  <:  ⊥
//│ ╟── because: cannot constrain  'reg1  <:  ⊥
//│ ╙── because: cannot constrain  R  <:  ⊥
//│ Type: Int


