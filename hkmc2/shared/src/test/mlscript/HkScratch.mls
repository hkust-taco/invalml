:js
// :de
// :sjs
// :pt
// :elt

:global
:d

:pt
fun translateChoice(tree: Stack[Tree]) = 
  // fun go(trees) = if tree is
  //   Tree.App(Tree.Ident("keyword"), Tree.Literal(LiteralKind.String, name)) :: rest and
  //     Keywords.all.get(name) is Some(keyword) then
  //       Choice.keyword(keyword, (head, tail) => head :: tail, go(rest))
  //   Tree.Literal(LiteralKind.String, name) :: rest then
  //     Choice.reference(name, (head, tail) => head :: tail, "unnamed", go(rest))
  //   Nil then Choice.end(Nil)
  fun go(x) = ???
  
  if tree is
    Tree.Tuple(category, choiceTree, functionTree) and
      category is Tree.Ident(categoryName) and
        functionTree is Tree.Ident(functionName) and
          choiceTree is
            Tree.Tuple(elements) then Some(go(elements))
            other then Some(go(other :: Nil))
        else
          console.warn("expect the choiceTree to be a bracketed term but found " + choiceTree)
          None
      else
        console.warn("expect a the category to be an identifier but found " + category)
        None
    else
      console.warn("expect the definition to be a tuple but found " + tree)
      None
//│ Parsed tree:
//│ TermDef:
//│   k = Fun
//│   head = App:
//│     lhs = Ident of "translateChoice"
//│     rhs = Tup of Ls of 
//│       InfixApp:
//│         lhs = Ident of "tree"
//│         kw = keyword ':'
//│         rhs = App:
//│           lhs = Ident of "Stack"
//│           rhs = TyTup of Ls of 
//│             Ident of "Tree"
//│   rhs = S of Block of Ls of 
//│     TermDef:
//│       k = Fun
//│       head = App:
//│         lhs = Ident of "go"
//│         rhs = Tup of Ls of 
//│           Ident of "x"
//│       rhs = S of Ident of "???"
//│     IfLike:
//│       kw = keyword 'if'
//│       kwLoc = N
//│       split = InfixApp:
//│         lhs = Ident of "tree"
//│         kw = keyword 'is'
//│         rhs = Block of Ls of 
//│           InfixApp:
//│             lhs = App:
//│               lhs = Sel:
//│                 prefix = Ident of "Tree"
//│                 name = Ident of "Tuple"
//│               rhs = Tup of Ls of 
//│                 Ident of "category"
//│                 Ident of "choiceTree"
//│                 Ident of "functionTree"
//│             kw = keyword 'and'
//│             rhs = Block of Ls of 
//│               InfixApp:
//│                 lhs = InfixApp:
//│                   lhs = Ident of "category"
//│                   kw = keyword 'is'
//│                   rhs = App:
//│                     lhs = Sel:
//│                       prefix = Ident of "Tree"
//│                       name = Ident of "Ident"
//│                     rhs = Tup of Ls of 
//│                       Ident of "categoryName"
//│                 kw = keyword 'and'
//│                 rhs = Block of Ls of 
//│                   InfixApp:
//│                     lhs = InfixApp:
//│                       lhs = Ident of "functionTree"
//│                       kw = keyword 'is'
//│                       rhs = App:
//│                         lhs = Sel:
//│                           prefix = Ident of "Tree"
//│                           name = Ident of "Ident"
//│                         rhs = Tup of Ls of 
//│                           Ident of "functionName"
//│                     kw = keyword 'and'
//│                     rhs = Block of Ls of 
//│                       InfixApp:
//│                         lhs = Ident of "choiceTree"
//│                         kw = keyword 'is'
//│                         rhs = Block of Ls of 
//│                           InfixApp:
//│                             lhs = App:
//│                               lhs = Sel:
//│                                 prefix = Ident of "Tree"
//│                                 name = Ident of "Tuple"
//│                               rhs = Tup of Ls of 
//│                                 Ident of "elements"
//│                             kw = keyword 'then'
//│                             rhs = App:
//│                               lhs = Ident of "Some"
//│                               rhs = Tup of Ls of 
//│                                 App:
//│                                   lhs = Ident of "go"
//│                                   rhs = Tup of Ls of 
//│                                     Ident of "elements"
//│                           InfixApp:
//│                             lhs = Ident of "other"
//│                             kw = keyword 'then'
//│                             rhs = App:
//│                               lhs = Ident of "Some"
//│                               rhs = Tup of Ls of 
//│                                 App:
//│                                   lhs = Ident of "go"
//│                                   rhs = Tup of Ls of 
//│                                     App:
//│                                       lhs = Ident of "::"
//│                                       rhs = Tup of Ls of 
//│                                         Ident of "other"
//│                                         Ident of "Nil"
//│                   Modified:
//│                     modifier = keyword 'else'
//│                     modLoc = N
//│                     body = Block of Ls of 
//│                       App:
//│                         lhs = Sel:
//│                           prefix = Ident of "console"
//│                           name = Ident of "warn"
//│                         rhs = Tup of Ls of 
//│                           App:
//│                             lhs = Ident of "+"
//│                             rhs = Tup of Ls of 
//│                               StrLit of "expect the choiceTree to be a bracketed term but found "
//│                               Ident of "choiceTree"
//│                       Ident of "None"
//│               Modified:
//│                 modifier = keyword 'else'
//│                 modLoc = N
//│                 body = Block of Ls of 
//│                   App:
//│                     lhs = Sel:
//│                       prefix = Ident of "console"
//│                       name = Ident of "warn"
//│                     rhs = Tup of Ls of 
//│                       App:
//│                         lhs = Ident of "+"
//│                         rhs = Tup of Ls of 
//│                           StrLit of "expect a the category to be an identifier but found "
//│                           Ident of "category"
//│                   Ident of "None"
//│           Modified:
//│             modifier = keyword 'else'
//│             modLoc = N
//│             body = Block of Ls of 
//│               App:
//│                 lhs = Sel:
//│                   prefix = Ident of "console"
//│                   name = Ident of "warn"
//│                 rhs = Tup of Ls of 
//│                   App:
//│                     lhs = Ident of "+"
//│                     rhs = Tup of Ls of 
//│                       StrLit of "expect the definition to be a tuple but found "
//│                       Ident of "tree"
//│               Ident of "None"
//│ FAILURE: Unexpected type error
//│ FAILURE LOCATION: term (Elaborator.scala:340)
//│ ╔══[ERROR] Name not found: Stack
//│ ║  l.11: 	fun translateChoice(tree: Stack[Tree]) = 
//│ ╙──      	                          ^^^^^
//│ FAILURE: Unexpected type error
//│ FAILURE LOCATION: term (Elaborator.scala:340)
//│ ╔══[ERROR] Name not found: Tree
//│ ║  l.11: 	fun translateChoice(tree: Stack[Tree]) = 
//│ ╙──      	                                ^^^^
//│ FAILURE: Unexpected type error
//│ FAILURE LOCATION: term (Elaborator.scala:340)
//│ ╔══[ERROR] Name not found: None
//│ ║  l.36: 	      None
//│ ╙──      	      ^^^^
//│ FAILURE: Unexpected type error
//│ FAILURE LOCATION: term (Elaborator.scala:340)
//│ ╔══[ERROR] Name not found: Tree
//│ ║  l.22: 	    Tree.Tuple(category, choiceTree, functionTree) and
//│ ╙──      	    ^^^^
//│ FAILURE: Unexpected type error
//│ FAILURE LOCATION: dealWithAppCtorCase (Desugarer.scala:515)
//│ ╔══[ERROR] Cannot use this selection as an extractor
//│ ║  l.22: 	    Tree.Tuple(category, choiceTree, functionTree) and
//│ ╙──      	    ^^^^
//│ FAILURE: Unexpected exception
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing
//│ 	at: scala.Predef$.$qmark$qmark$qmark(Predef.scala:344)
//│ 	at: hkmc2.semantics.Elaborator$VarianceTraverser.traverseType(Elaborator.scala:1241)
//│ 	at: hkmc2.semantics.Elaborator$Traverser.traverseType$$anonfun$14(Elaborator.scala:1286)
//│ 	at: scala.runtime.function.JProcedure1.apply(JProcedure1.java:15)
//│ 	at: scala.runtime.function.JProcedure1.apply(JProcedure1.java:10)
//│ 	at: scala.Option.foreach(Option.scala:437)
//│ 	at: hkmc2.semantics.Elaborator$Traverser.traverseType(Elaborator.scala:1286)
//│ 	at: hkmc2.semantics.Elaborator.go$6$$anonfun$1$$anonfun$1(Elaborator.scala:1182)
//│ 	at: scala.runtime.function.JProcedure1.apply(JProcedure1.java:15)
//│ 	at: scala.runtime.function.JProcedure1.apply(JProcedure1.java:10)
//│ 	at: scala.collection.immutable.List.foreach(List.scala:334)
//│ 	at: hkmc2.semantics.Elaborator.go$6$$anonfun$1(Elaborator.scala:1182)
//│ 	at: scala.runtime.function.JProcedure1.apply(JProcedure1.java:15)
//│ 	at: scala.runtime.function.JProcedure1.apply(JProcedure1.java:10)
//│ 	at: scala.collection.immutable.List.foreach(List.scala:334)
//│ 	at: hkmc2.semantics.Elaborator.go$6(Elaborator.scala:1182)
//│ 	at: hkmc2.semantics.Elaborator.go$6$$anonfun$5(Elaborator.scala:1195)
//│ 	at: scala.runtime.function.JProcedure1.apply(JProcedure1.java:15)
//│ 	at: scala.runtime.function.JProcedure1.apply(JProcedure1.java:10)
//│ 	at: scala.collection.immutable.List.foreach(List.scala:334)
//│ 	at: hkmc2.semantics.Elaborator.go$6(Elaborator.scala:1195)
//│ 	at: hkmc2.semantics.Elaborator.computeVariances(Elaborator.scala:1198)
//│ 	at: hkmc2.semantics.Elaborator.topLevel(Elaborator.scala:1175)
//│ 	at: hkmc2.MLsDiffMaker.processTrees(MLsDiffMaker.scala:233)
//│ 	at: hkmc2.MLsDiffMaker.processOrigin(MLsDiffMaker.scala:214)
//│ 	at: hkmc2.DiffMaker.processBlock(DiffMaker.scala:215)
//│ 	at: hkmc2.DiffMaker.rec(DiffMaker.scala:318)
//│ 	at: hkmc2.DiffMaker.run(DiffMaker.scala:341)
//│ 	at: hkmc2.MLsDiffMaker.run(MLsDiffMaker.scala:125)
//│ 	at: hkmc2.JSBackendDiffMaker.run(JSBackendDiffMaker.scala:55)
//│ 	at: hkmc2.Watcher.go(Watcher.scala:104)
//│ 	at: hkmc2.Watcher.onModify(Watcher.scala:119)
//│ 	at: hkmc2.Watcher$$anon$1.onEvent(Watcher.scala:67)
//│ 	at: io.methvin.watcher.DirectoryWatcher.onEvent(DirectoryWatcher.java:425)
//│ 	at: io.methvin.watcher.DirectoryWatcher.runEventLoop(DirectoryWatcher.java:356)
//│ 	at: io.methvin.watcher.DirectoryWatcher.watch(DirectoryWatcher.java:250)
//│ 	at: hkmc2.Watcher.run(Watcher.scala:79)
//│ 	at: hkmc2.MainWatcher$.main(Watcher.scala:18)
//│ 	at: hkmc2.MainWatcher.main(Watcher.scala)

