:js
:llir
:cpp

:intl
:sllir
:scpp
fun mkTup(x, y) = [x, y]
fun fst(t) = if t is [x, y] then x 
mkTup(1, 2)
//│ = [1, 2]
//│ LLIR:
//│   
//│   def mkTup$840(x$843,y$844) =
//│     let x$856 = Tuple2$857(x$843,y$844) in
//│     x$856
//│   def fst$841(t$847) =
//│     case t$847 of
//│       Tuple2$857 =>
//│         let x$860 = t$847.<Tuple2$857:0> in
//│         let x$861 = t$847.<Tuple2$857:1> in
//│         x$860
//│       _ =>
//│         panic "match error"
//│   def j$859() =
//│     undefined
//│   def entry$863() =
//│     let* (x$862) = mkTup(1,2) in
//│     x$862
//│   entry = entry$863
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Tuple2;
//│ _mlsValue _mls_mkTup(_mlsValue, _mlsValue);
//│ _mlsValue _mls_j();
//│ _mlsValue _mls_fst(_mlsValue);
//│ _mlsValue _mls_entry1();
//│ struct _mls_Tuple2: public _mlsObject {
//│   _mlsValue _mls_field0;
//│   _mlsValue _mls_field1;
//│   constexpr static inline const char *typeName = "Tuple2";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_field0.print(); std::printf(", "); this->_mls_field1.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_field0); _mlsValue::destroy(this->_mls_field1);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_field0, _mlsValue _mls_field1) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Tuple2; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_field0 = _mls_field0; _mlsVal->_mls_field1 = _mls_field1;  return _mlsValue(_mlsVal); }
//│   
//│ };
//│ _mlsValue _mls_mkTup(_mlsValue _mls_x1, _mlsValue _mls_y) {
//│   _mlsValue _mls_retval;
//│   auto _mls_x = _mlsValue::create<_mls_Tuple2>(_mls_x1, _mls_y);
//│   _mls_retval = _mls_x;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j() {
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mlsValue::create<_mls_Unit>();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_fst(_mlsValue _mls_t) {
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Tuple2>(_mls_t)) {
//│     auto _mls_x2 = _mlsValue::cast<_mls_Tuple2>(_mls_t)->_mls_field0;
//│     auto _mls_x3 = _mlsValue::cast<_mls_Tuple2>(_mls_t)->_mls_field1;
//│     _mls_retval = _mls_x2;
//│   } else {
//│     throw std::runtime_error("match error");
//│   }
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_entry1() {
//│   _mlsValue _mls_retval;
//│   auto _mls_x4 = _mls_mkTup(_mlsValue::fromIntLit(1), _mlsValue::fromIntLit(2));
//│   _mls_retval = _mls_x4;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain() { return _mls_entry1(); }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 
//│ Interpreted:
//│ Tuple2(1,2)
