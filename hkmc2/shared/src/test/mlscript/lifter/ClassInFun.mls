:lift
:js

// make sure class fields are discriminated properly for immutable captures when supported
:effectHandlers
:sjs
abstract class Effect with
  fun perform()
handle h = Effect with
  fun perform()(k) = k()
fun f() =
  h.perform()
  1
f() + f() + f()
//│ JS (unsanitized):
//│ let f, Effect1, tmp, handleBlock$, Cont$func$f$1, Cont$handleBlock$h$1, Handler$h$1, lambda, f$, Cont$func$f$$ctor, Cont$func$f$$, Cont$handleBlock$h$$ctor, Cont$handleBlock$h$$, lambda$;
//│ Effect1 = class Effect {
//│   constructor() {}
//│   toString() { return "Effect"; }
//│ };
//│ lambda$ = function lambda$(Handler$h$$instance, k) {
//│   return runtime.safeCall(k())
//│ };
//│ lambda = (undefined, function (Handler$h$$instance) {
//│   return (k) => {
//│     return lambda$(Handler$h$$instance, k)
//│   }
//│ });
//│ Handler$h$1 = class Handler$h$ extends Effect1 {
//│   constructor() {
//│     let tmp1;
//│     tmp1 = super();
//│   }
//│   perform() {
//│     let lambda$this;
//│     lambda$this = runtime.safeCall(lambda(this));
//│     return runtime.mkEffect(this, lambda$this)
//│   }
//│   toString() { return "Handler$h$"; }
//│ };
//│ Cont$handleBlock$h$$ = function Cont$handleBlock$h$$(h$0, tmp$1, tmp$2, tmp$3, tmp$4, pc) {
//│   let tmp1;
//│   tmp1 = new Cont$handleBlock$h$1.class(pc);
//│   return tmp1(h$0, tmp$1, tmp$2, tmp$3, tmp$4)
//│ };
//│ Cont$handleBlock$h$$ctor = function Cont$handleBlock$h$$ctor(h$0, tmp$1, tmp$2, tmp$3, tmp$4) {
//│   return (pc) => {
//│     let tmp1;
//│     tmp1 = new Cont$handleBlock$h$1.class(pc);
//│     return tmp1(h$0, tmp$1, tmp$2, tmp$3, tmp$4)
//│   }
//│ };
//│ Cont$handleBlock$h$1 = function Cont$handleBlock$h$(pc1) {
//│   return (h$01, tmp$11, tmp$21, tmp$31, tmp$41) => {
//│     return new Cont$handleBlock$h$.class(pc1)(h$01, tmp$11, tmp$21, tmp$31, tmp$41);
//│   }
//│ };
//│ Cont$handleBlock$h$1.class = class Cont$handleBlock$h$ extends runtime.FunctionContFrame.class {
//│   constructor(pc) {
//│     return (h$0, tmp$1, tmp$2, tmp$3, tmp$4) => {
//│       let tmp1;
//│       tmp1 = super(null);
//│       this.h$0 = h$0;
//│       this.tmp$1 = tmp$1;
//│       this.tmp$2 = tmp$2;
//│       this.tmp$3 = tmp$3;
//│       this.tmp$4 = tmp$4;
//│       this.pc = pc;
//│       return this;
//│     }
//│   }
//│   resume(value$) {
//│     if (this.pc === 2) {
//│       this.tmp$1 = value$;
//│     } else if (this.pc === 3) {
//│       this.tmp$2 = value$;
//│     } else if (this.pc === 4) {
//│       this.tmp$4 = value$;
//│     }
//│     contLoop: while (true) {
//│       if (this.pc === 7) {
//│         this.tmp$1 = f$(this.h$0);
//│         if (this.tmp$1 instanceof runtime.EffectSig.class) {
//│           this.pc = 2;
//│           this.tmp$1.contTrace.last.next = this;
//│           this.tmp$1.contTrace.last = this;
//│           return this.tmp$1
//│         }
//│         this.pc = 2;
//│         continue contLoop;
//│       } else if (this.pc === 2) {
//│         this.pc = 6;
//│         continue contLoop;
//│       } else if (this.pc === 6) {
//│         this.tmp$2 = f$(this.h$0);
//│         if (this.tmp$2 instanceof runtime.EffectSig.class) {
//│           this.pc = 3;
//│           this.tmp$2.contTrace.last.next = this;
//│           this.tmp$2.contTrace.last = this;
//│           return this.tmp$2
//│         }
//│         this.pc = 3;
//│         continue contLoop;
//│       } else if (this.pc === 3) {
//│         this.tmp$3 = this.tmp$1 + this.tmp$2;
//│         this.pc = 5;
//│         continue contLoop;
//│       } else if (this.pc === 5) {
//│         this.tmp$4 = f$(this.h$0);
//│         if (this.tmp$4 instanceof runtime.EffectSig.class) {
//│           this.pc = 4;
//│           this.tmp$4.contTrace.last.next = this;
//│           this.tmp$4.contTrace.last = this;
//│           return this.tmp$4
//│         }
//│         this.pc = 4;
//│         continue contLoop;
//│       } else if (this.pc === 4) {
//│         return this.tmp$3 + this.tmp$4
//│       }
//│       break;
//│     }
//│   }
//│   toString() { return "Cont$handleBlock$h$(" + runtime.render(this.pc) + ")"; }
//│ };
//│ Cont$func$f$$ = function Cont$func$f$$(h$0, tmp$1, pc) {
//│   let tmp1;
//│   tmp1 = new Cont$func$f$1.class(pc);
//│   return tmp1(h$0, tmp$1)
//│ };
//│ Cont$func$f$$ctor = function Cont$func$f$$ctor(h$0, tmp$1) {
//│   return (pc) => {
//│     let tmp1;
//│     tmp1 = new Cont$func$f$1.class(pc);
//│     return tmp1(h$0, tmp$1)
//│   }
//│ };
//│ Cont$func$f$1 = function Cont$func$f$(pc1) {
//│   return (h$01, tmp$11) => {
//│     return new Cont$func$f$.class(pc1)(h$01, tmp$11);
//│   }
//│ };
//│ Cont$func$f$1.class = class Cont$func$f$ extends runtime.FunctionContFrame.class {
//│   constructor(pc) {
//│     return (h$0, tmp$1) => {
//│       let tmp1;
//│       tmp1 = super(null);
//│       this.h$0 = h$0;
//│       this.tmp$1 = tmp$1;
//│       this.pc = pc;
//│       return this;
//│     }
//│   }
//│   resume(value$) {
//│     if (this.pc === 0) {
//│       this.tmp$1 = value$;
//│     }
//│     contLoop: while (true) {
//│       if (this.pc === 1) {
//│         this.tmp$1 = runtime.safeCall(this.h$0.perform());
//│         if (this.tmp$1 instanceof runtime.EffectSig.class) {
//│           this.pc = 0;
//│           this.tmp$1.contTrace.last.next = this;
//│           this.tmp$1.contTrace.last = this;
//│           return this.tmp$1
//│         }
//│         this.pc = 0;
//│         continue contLoop;
//│       } else if (this.pc === 0) {
//│         return 1
//│       }
//│       break;
//│     }
//│   }
//│   toString() { return "Cont$func$f$(" + runtime.render(this.pc) + ")"; }
//│ };
//│ f$ = function f$(h) {
//│   let tmp1;
//│   tmp1 = runtime.safeCall(h.perform());
//│   if (tmp1 instanceof runtime.EffectSig.class) {
//│     tmp1.contTrace.last.next = Cont$func$f$$(h, tmp1, 0);
//│     tmp1.contTrace.last = tmp1.contTrace.last.next;
//│     return tmp1
//│   }
//│   return 1
//│ };
//│ f = function f(h) {
//│   return () => {
//│     return f$(h)
//│   }
//│ };
//│ handleBlock$ = function handleBlock$() {
//│   let h, tmp1, tmp2, tmp3, tmp4;
//│   h = new Handler$h$1();
//│   tmp1 = f$(h);
//│   if (tmp1 instanceof runtime.EffectSig.class) {
//│     tmp1.contTrace.last.next = Cont$handleBlock$h$$(h, tmp1, tmp2, tmp3, tmp4, 2);
//│     return runtime.handleBlockImpl(tmp1, h)
//│   }
//│   tmp2 = f$(h);
//│   if (tmp2 instanceof runtime.EffectSig.class) {
//│     tmp2.contTrace.last.next = Cont$handleBlock$h$$(h, tmp1, tmp2, tmp3, tmp4, 3);
//│     return runtime.handleBlockImpl(tmp2, h)
//│   }
//│   tmp3 = tmp1 + tmp2;
//│   tmp4 = f$(h);
//│   if (tmp4 instanceof runtime.EffectSig.class) {
//│     tmp4.contTrace.last.next = Cont$handleBlock$h$$(h, tmp1, tmp2, tmp3, tmp4, 4);
//│     return runtime.handleBlockImpl(tmp4, h)
//│   }
//│   return tmp3 + tmp4
//│ };
//│ tmp = handleBlock$();
//│ if (tmp instanceof runtime.EffectSig.class) {
//│   tmp = runtime.topLevelEffect(tmp, false);
//│ }
//│ tmp
//│ = 3

:expect 1
:sjs
fun f(x) =
  class Test() with
    fun get() = x
  Test()
f(1).get()
//│ JS (unsanitized):
//│ let Test1, f1, tmp1, Test$ctor, Test$;
//│ Test$ = function Test$(x$0) {
//│   let tmp2;
//│   tmp2 = new Test1.class();
//│   return tmp2(x$0)
//│ };
//│ Test$ctor = function Test$ctor(x$0) {
//│   return () => {
//│     let tmp2;
//│     tmp2 = new Test1.class();
//│     return tmp2(x$0)
//│   }
//│ };
//│ Test1 = function Test() {
//│   return (x$01) => {
//│     return new Test.class()(x$01);
//│   }
//│ };
//│ Test1.class = class Test {
//│   constructor() {
//│     return (x$0) => {
//│       this.x$0 = x$0;
//│       return this;
//│     }
//│   }
//│   get() {
//│     return this.x$0
//│   }
//│   toString() { return "Test(" + "" + ")"; }
//│ };
//│ f1 = function f(x) {
//│   return Test$(x)
//│ };
//│ tmp1 = f1(1);
//│ runtime.safeCall(tmp1.get())
//│ = 1

:expect 1
:sjs
fun f(used1, unused1) =
  fun g(g_arg) =
    let used3 = 2
    fun h = used3
    used1 + h
  let unused2 = 2
  data class Test(a) with
    fun get() = used1
  Test(unused1)
f(1, 2).get()
//│ JS (unsanitized):
//│ let h, Test3, g, f2, tmp2, Test$ctor1, Test$1, g$, h$;
//│ h$ = function h$(used3) {
//│   return used3
//│ };
//│ h = function h(used3) {
//│   return () => {
//│     return h$(used3)
//│   }
//│ };
//│ g$ = function g$(used1, g_arg) {
//│   let used3, tmp3;
//│   used3 = 2;
//│   tmp3 = h$(used3);
//│   return used1 + tmp3
//│ };
//│ g = function g(used1) {
//│   return (g_arg) => {
//│     return g$(used1, g_arg)
//│   }
//│ };
//│ Test$1 = function Test$(used1$0, a) {
//│   let tmp3;
//│   tmp3 = new Test3.class(a);
//│   return tmp3(used1$0)
//│ };
//│ Test$ctor1 = function Test$ctor(used1$0) {
//│   return (a) => {
//│     let tmp3;
//│     tmp3 = new Test3.class(a);
//│     return tmp3(used1$0)
//│   }
//│ };
//│ Test3 = function Test(a1) {
//│   return (used1$01) => {
//│     return new Test.class(a1)(used1$01);
//│   }
//│ };
//│ Test3.class = class Test2 {
//│   constructor(a) {
//│     return (used1$0) => {
//│       this.used1$0 = used1$0;
//│       this.a = a;
//│       return this;
//│     }
//│   }
//│   get() {
//│     return this.used1$0
//│   }
//│   toString() { return "Test(" + runtime.render(this.a) + ")"; }
//│ };
//│ f2 = function f(used1, unused1) {
//│   let unused2;
//│   unused2 = 2;
//│   return Test$1(used1, unused1)
//│ };
//│ tmp2 = f2(1, 2);
//│ runtime.safeCall(tmp2.get())
//│ = 1

:expect 1
fun f(used1, unused1) =
  fun g(g_arg) =
    let used3 = 2
    fun h = used3
    used1 + h
  let unused2 = 2
  class Test(a) with
    fun get() = used1
  new Test(unused1)
f(1, 2).get()
//│ = 1

:sjs
:expect 1
fun f(used1, unused1) =
  fun g(g_arg) =
    let used3 = 2
    fun h = used3
    used1 + h
  let unused2 = 2
  class Test with
    fun get() = used1
  new Test
f(1, 2).get()
//│ JS (unsanitized):
//│ let h2, Test7, g2, f4, tmp4, Test$ctor3, Test$3, g$2, h$2;
//│ h$2 = function h$(used3) {
//│   return used3
//│ };
//│ h2 = function h(used3) {
//│   return () => {
//│     return h$2(used3)
//│   }
//│ };
//│ g$2 = function g$(used1, g_arg) {
//│   let used3, tmp5;
//│   used3 = 2;
//│   tmp5 = h$2(used3);
//│   return used1 + tmp5
//│ };
//│ g2 = function g(used1) {
//│   return (g_arg) => {
//│     return g$2(used1, g_arg)
//│   }
//│ };
//│ Test$3 = function Test$(used1$0) {
//│   let tmp5;
//│   tmp5 = new Test7.class();
//│   return tmp5(used1$0)
//│ };
//│ Test$ctor3 = function Test$ctor(used1$0) {
//│   return () => {
//│     let tmp5;
//│     tmp5 = new Test7.class();
//│     return tmp5(used1$0)
//│   }
//│ };
//│ Test7 = function Test(used1$01) {
//│   return new Test.class()(used1$01);
//│ };
//│ Test7.class = class Test6 {
//│   constructor() {
//│     return (used1$0) => {
//│       this.used1$0 = used1$0;
//│       return this;
//│     }
//│   }
//│   get() {
//│     return this.used1$0
//│   }
//│   toString() { return "Test"; }
//│ };
//│ f4 = function f(used1, unused1) {
//│   let unused2;
//│   unused2 = 2;
//│   return Test$3(used1)
//│ };
//│ tmp4 = f4(1, 2);
//│ runtime.safeCall(tmp4.get())
//│ = 1

:sjs
:expect 2
fun f(x) =
  class A() with
    fun f() = set x = 2
  A().f()
  x
f(1)
//│ JS (unsanitized):
//│ let A1, f5, A$ctor, A$, f$capture1;
//│ A$ = function A$(f$capture$0) {
//│   let tmp5;
//│   tmp5 = new A1.class();
//│   return tmp5(f$capture$0)
//│ };
//│ A$ctor = function A$ctor(f$capture$0) {
//│   return () => {
//│     let tmp5;
//│     tmp5 = new A1.class();
//│     return tmp5(f$capture$0)
//│   }
//│ };
//│ A1 = function A() {
//│   return (f$capture$01) => {
//│     return new A.class()(f$capture$01);
//│   }
//│ };
//│ A1.class = class A {
//│   constructor() {
//│     return (f$capture$0) => {
//│       this.f$capture$0 = f$capture$0;
//│       return this;
//│     }
//│   }
//│   f() {
//│     this.f$capture$0.x0$ = 2;
//│     return runtime.Unit
//│   }
//│   toString() { return "A(" + "" + ")"; }
//│ };
//│ f$capture1 = function f$capture(x0$1) {
//│   return new f$capture.class(x0$1);
//│ };
//│ f$capture1.class = class f$capture {
//│   constructor(x0$) {
//│     this.x0$ = x0$;
//│   }
//│   toString() { return "f$capture(" + runtime.render(this.x0$) + ")"; }
//│ };
//│ f5 = function f(x) {
//│   let tmp5, tmp6, capture;
//│   capture = new f$capture1(x);
//│   tmp5 = A$(capture);
//│   tmp6 = runtime.safeCall(tmp5.f());
//│   return capture.x0$
//│ };
//│ f5(1)
//│ = 2

// only w should be in a capture
:expect 10111
:sjs
fun f() =
  let x = 1
  let y = 10
  let z = 10
  let w = 1000
  class Good() with
    fun foo() =
      set z = 100
      x + y + z + w
  class Bad() with
    fun foo() =
      set w = 10000
  Bad().foo()
  Good()
f().foo()
//│ JS (unsanitized):
//│ let Bad1, Good1, f6, tmp5, Bad$ctor, Bad$, Good$ctor, Good$, f$capture3;
//│ Good$ = function Good$(x$1, y$2, z$3, f$capture$0) {
//│   let tmp6;
//│   tmp6 = new Good1.class();
//│   return tmp6(x$1, y$2, z$3, f$capture$0)
//│ };
//│ Good$ctor = function Good$ctor(x$1, y$2, z$3, f$capture$0) {
//│   return () => {
//│     let tmp6;
//│     tmp6 = new Good1.class();
//│     return tmp6(x$1, y$2, z$3, f$capture$0)
//│   }
//│ };
//│ Good1 = function Good() {
//│   return (x$11, y$21, z$31, f$capture$01) => {
//│     return new Good.class()(x$11, y$21, z$31, f$capture$01);
//│   }
//│ };
//│ Good1.class = class Good {
//│   constructor() {
//│     return (x$1, y$2, z$3, f$capture$0) => {
//│       this.x$1 = x$1;
//│       this.y$2 = y$2;
//│       this.z$3 = z$3;
//│       this.f$capture$0 = f$capture$0;
//│       return this;
//│     }
//│   }
//│   foo() {
//│     let tmp6, tmp7;
//│     this.z$3 = 100;
//│     tmp6 = this.x$1 + this.y$2;
//│     tmp7 = tmp6 + this.z$3;
//│     return tmp7 + this.f$capture$0.w0$
//│   }
//│   toString() { return "Good(" + "" + ")"; }
//│ };
//│ Bad$ = function Bad$(f$capture$0) {
//│   let tmp6;
//│   tmp6 = new Bad1.class();
//│   return tmp6(f$capture$0)
//│ };
//│ Bad$ctor = function Bad$ctor(f$capture$0) {
//│   return () => {
//│     let tmp6;
//│     tmp6 = new Bad1.class();
//│     return tmp6(f$capture$0)
//│   }
//│ };
//│ Bad1 = function Bad() {
//│   return (f$capture$01) => {
//│     return new Bad.class()(f$capture$01);
//│   }
//│ };
//│ Bad1.class = class Bad {
//│   constructor() {
//│     return (f$capture$0) => {
//│       this.f$capture$0 = f$capture$0;
//│       return this;
//│     }
//│   }
//│   foo() {
//│     this.f$capture$0.w0$ = 10000;
//│     return runtime.Unit
//│   }
//│   toString() { return "Bad(" + "" + ")"; }
//│ };
//│ f$capture3 = function f$capture(w0$1) {
//│   return new f$capture.class(w0$1);
//│ };
//│ f$capture3.class = class f$capture2 {
//│   constructor(w0$) {
//│     this.w0$ = w0$;
//│   }
//│   toString() { return "f$capture(" + runtime.render(this.w0$) + ")"; }
//│ };
//│ f6 = function f() {
//│   let x, y, z, tmp6, tmp7, capture;
//│   capture = new f$capture3(null);
//│   x = 1;
//│   y = 10;
//│   z = 10;
//│   capture.w0$ = 1000;
//│   tmp6 = Bad$(capture);
//│   tmp7 = runtime.safeCall(tmp6.foo());
//│   return Good$(x, y, z, capture)
//│ };
//│ tmp5 = f6();
//│ runtime.safeCall(tmp5.foo())
//│ = 10111

:expect 2
fun f(x) =
  class A() with
    fun newA() = A()
    fun foo() =
      set x += 1
      x
    fun getX() = x
  A()
let a = f(0)
a.foo()
let b = a.newA()
b.foo()
a.getX()
//│ = 2
//│ a = A()
//│ b = A()

// handler

:stackSafe 10
:effectHandlers
fun sum(n) =
  if n == 0 then 0
  else
    n + sum(n - 1)
sum(100)
//│ = 5050

// instance checks

:w
fun f() =
  data class Test(a) with
    fun get() = a
  fun foo() = Test
  foo()(0)
f().get()
//│ ═══[WARNING] Cannot yet lift class `Test` as it is used as a first-class class.
//│ = 0

:sjs
:lift
:w
fun f(x) =
  class Test() with
    fun get() =
      fun h() = x
      h()
  let foo = Test
  foo()
f(2).get()
//│ ═══[WARNING] Cannot yet lift class `Test` as it is used as a first-class class.
//│ JS (unsanitized):
//│ let h3, f9, tmp11, h$3;
//│ h$3 = function h$(Test$instance, x) {
//│   return x
//│ };
//│ h3 = function h(Test$instance, x) {
//│   return () => {
//│     return h$3(Test$instance, x)
//│   }
//│ };
//│ f9 = function f(x) {
//│   let Test10, foo1;
//│   Test10 = function Test() {
//│     return new Test.class();
//│   };
//│   Test10.class = class Test9 {
//│     constructor() {}
//│     get() {
//│       return h$3(this, x)
//│     }
//│     toString() { return "Test(" + "" + ")"; }
//│   };
//│   foo1 = Test10;
//│   return runtime.safeCall(foo1())
//│ };
//│ tmp11 = f9(2);
//│ runtime.safeCall(tmp11.get())
//│ ═══[WARNING] Cannot yet lift class `Test` as it is used as a first-class class.
//│ = 2

:expect 2
fun test() =
  class A with
    fun get = 2
  class B() extends A
  B().get
test()
//│ = 2

// Note: semicolon required for auxparam before `return this;`
// :sjs
fun test(f) =
  class A(x) with
    f(x)
  A(1)

