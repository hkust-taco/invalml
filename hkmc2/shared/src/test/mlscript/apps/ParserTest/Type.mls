:js

import "../../../mlscript-compile/apps/parsing/Test.mls"

open Test { example }

example of """
type b = p * q * (r * s)
"""
//│ > «type b = p * q * r * s»

example of """
type a = b
type b = p * q * (r * s)
type f = int -> int
"""
//│ > «type a = b»
//│ > «type b = p * q * r * s»
//│ > «type f = int -> int»

example of """
:tree
type f = a -> b -> c
type g = (a -> b) -> c
"""
//│ > Define:
//│ >   kind = Type
//│ >   items = Stack of 
//│ >     Pair:
//│ >       first = Ident of "f"
//│ >       second = Infix:
//│ >         op = Keyword(`->`, 5, 4)
//│ >         lhs = Ident of "a"
//│ >         rhs = Infix:
//│ >           op = Keyword(`->`, 5, 4)
//│ >           lhs = Ident of "b"
//│ >           rhs = Ident of "c"
//│ > Define:
//│ >   kind = Type
//│ >   items = Stack of 
//│ >     Pair:
//│ >       first = Ident of "g"
//│ >       second = Infix:
//│ >         op = Keyword(`->`, 5, 4)
//│ >         lhs = Infix:
//│ >           op = Keyword(`->`, 5, 4)
//│ >           lhs = Ident of "a"
//│ >           rhs = Ident of "b"
//│ >         rhs = Ident of "c"
//│ > «type f = a -> b -> c»
//│ > «type g = a -> b -> c»

example of """
:tree
type f = int * string -> float
type g = int * (string -> float)
"""
//│ > Define:
//│ >   kind = Type
//│ >   items = Stack of 
//│ >     Pair:
//│ >       first = Ident of "f"
//│ >       second = Infix:
//│ >         op = Keyword(`->`, 5, 4)
//│ >         lhs = Infix:
//│ >           op = Keyword(`*`, 6, 6)
//│ >           lhs = Ident of "int"
//│ >           rhs = Ident of "string"
//│ >         rhs = Ident of "float"
//│ > Define:
//│ >   kind = Type
//│ >   items = Stack of 
//│ >     Pair:
//│ >       first = Ident of "g"
//│ >       second = Infix:
//│ >         op = Keyword(`*`, 6, 6)
//│ >         lhs = Ident of "int"
//│ >         rhs = Infix:
//│ >           op = Keyword(`->`, 5, 4)
//│ >           lhs = Ident of "string"
//│ >           rhs = Ident of "float"
//│ > «type f = int * string -> float»
//│ > «type g = int * string -> float»

example of """
type 'a f = 'a * 'a
"""
//│ > «type f «'a» :: Nil = 'a * 'a»

example of """
type foo = Bar | Qux
let double n = n * 2
"""
//│ > «type foo = Bar | Qux»
//│ > «let double n = n * 2»

example of """
type foo = Bar of int | Qux of int * int
"""
//│ > «type foo = Bar of int | Qux of int * int»

example of """
:tree
type 'a option = Some of 'a | None
"""
//│ > Define:
//│ >   kind = Type
//│ >   items = Stack of 
//│ >     Pair:
//│ >       first = App:
//│ >         callee = Ident of "option"
//│ >         argument = Stack of 
//│ >           Ident of "'a"
//│ >       second = Infix:
//│ >         op = Keyword(`|`, N/A, 4)
//│ >         lhs = Infix:
//│ >           op = Keyword(`of`, 9, 9)
//│ >           lhs = Ident of "Some"
//│ >           rhs = Ident of "'a"
//│ >         rhs = Ident of "None"
//│ > «type option «'a» :: Nil = Some of 'a | None»

example of """
:tree
type 'a tree = Leaf | Node of 'a tree * 'a * 'a tree
"""
//│ > Define:
//│ >   kind = Type
//│ >   items = Stack of 
//│ >     Pair:
//│ >       first = App:
//│ >         callee = Ident of "tree"
//│ >         argument = Stack of 
//│ >           Ident of "'a"
//│ >       second = Infix:
//│ >         op = Keyword(`|`, N/A, 4)
//│ >         lhs = Ident of "Leaf"
//│ >         rhs = Infix:
//│ >           op = Keyword(`*`, 6, 6)
//│ >           lhs = Infix:
//│ >             op = Keyword(`*`, 6, 6)
//│ >             lhs = App:
//│ >               callee = Ident of "tree"
//│ >               argument = Stack of 
//│ >                 Infix:
//│ >                   op = Keyword(`of`, 9, 9)
//│ >                   lhs = Ident of "Node"
//│ >                   rhs = Ident of "'a"
//│ >             rhs = Ident of "'a"
//│ >           rhs = App:
//│ >             callee = Ident of "tree"
//│ >             argument = Stack of 
//│ >               Ident of "'a"
//│ > «type tree «'a» :: Nil = Leaf | tree «Node of 'a» :: Nil * 'a * tree «'a» :: Nil»

example of """
type ('a, 'b) twist = a list * b list
"""
//│ > «type twist «('a, 'b)» :: Nil = list «a» :: Nil * list «b» :: Nil»


// example of """
// type qux = Qux of { q : int; u: int; x :int }
// """

// example of """
// type colour =
//   | Red | Green | Blue | Yellow | Black | White
//   | RGB of {r : int; g : int; b : int}
// type 'a tree = Lf | Br of 'a * 'a tree * 'a;;
// """

example of """
:tree
type t = {decoration : string; substance : t'}
and t' = Int of int | List of t list
"""
//│ > Define:
//│ >   kind = Type
//│ >   items = Stack of 
//│ >     Pair:
//│ >       first = Ident of "t"
//│ >       second = Bracketed#Curly of Sequence of Stack of 
//│ >         Infix:
//│ >           op = Keyword(`:`, 7, 7)
//│ >           lhs = Ident of "decoration"
//│ >           rhs = Ident of "string"
//│ >         Infix:
//│ >           op = Keyword(`:`, 7, 7)
//│ >           lhs = Ident of "substance"
//│ >           rhs = Ident of "t'"
//│ >     Pair:
//│ >       first = Ident of "t'"
//│ >       second = Infix:
//│ >         op = Keyword(`|`, N/A, 4)
//│ >         lhs = Infix:
//│ >           op = Keyword(`of`, 9, 9)
//│ >           lhs = Ident of "Int"
//│ >           rhs = Ident of "int"
//│ >         rhs = App:
//│ >           callee = Ident of "list"
//│ >           argument = Stack of 
//│ >             Infix:
//│ >               op = Keyword(`of`, 9, 9)
//│ >               lhs = Ident of "List"
//│ >               rhs = Ident of "t"
//│ > «type t = {decoration : string; substance : t'} and t' = Int of int | list «List of t» :: Nil»

example of """
:tree
exception E of int * string
"""
//│ > Define:
//│ >   kind = Exception
//│ >   items = Stack of 
//│ >     Pair:
//│ >       first = Infix:
//│ >         op = Keyword(`*`, 6, 6)
//│ >         lhs = Infix:
//│ >           op = Keyword(`of`, 9, 9)
//│ >           lhs = Ident of "E"
//│ >           rhs = Ident of "int"
//│ >         rhs = Ident of "string"
//│ >       second = Empty
//│ > «exception E of int * string = {}»

example of """
type 'a bst = E | N of 'a * 'a bst * 'a bst
let rec insert x = function
  | E -> N (x, E, E)
  | N (y, l, r) ->
      if x < y then N (y, insert x l, r)
      else N (y, l, insert x r)
let rec min_elt = function
  | E -> failwith "min_elt called on empty tree"
  | N (x, E, _) -> x
  | N (_, l, _) -> min_elt l
let rec remove x = function
  | E -> E
  | N (y, l, r) ->
      if x < y then N (y, remove x l, r)
      else if x > y then N (y, l, remove x r)
      else
        match (l, r) with
        | (E, _) -> r
        | (_, E) -> l
        | _ ->
            let m = min_elt r in
            N (m, l, remove m r)
"""
//│ > «type bst «'a» :: Nil = E | N of 'a * bst «'a» :: Nil * bst «'a» :: Nil»
//│ > «let insert x = function E -> N (x, E, E) | N (y, l, r) -> if x < y then N (y, insert x (l, r)) then N (y, l, insert x r) let min_elt = function E -> failwith "min_e…" | N (x, E, _) -> x | N (_, l, _) -> min_elt l let remove x = function E -> E | N (y, l, r) -> if x < y then N (y, remove x (l, r)) then if x > y then N (y, l, remove x r) then match (l, r) with (E, _) -> r | (_, E) -> l | _ -> let m = min_elt r in N (m, l, remove m r)»

