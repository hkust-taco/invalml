:js

import "../../mlscript-compile/apps/Lexer.mls"
import "../../mlscript-compile/apps/parsing/Token.mls"
import "../../mlscript-compile/Stack.mls"

fun lines(...strs) = strs.join("\n")

open Lexer { lex }
open Stack

fun mapJoin[A](stack: Stack[A], op: A -> Str, sep: Str) =
  let buffer = ""
  while stack is head :: tail do
    set buffer = buffer + op(head)
    if tail is _ :: _ do
      set buffer = buffer + sep
    set stack = tail
  buffer

fun printLexed(text) = print of
  (lex of text) mapJoin(Token.display, "\n")

lex of "0 1"
//â”‚ = Cons(Literal(Integer, "0"), Cons(Space, Cons(Literal(Integer, "1"), Nil)))

printLexed of "0 1  0xDEADCAFE 0b1101 0o755     3.1415926535"
//â”‚ > Literal(Integer, "0")
//â”‚ > Space
//â”‚ > Literal(Integer, "1")
//â”‚ > Space
//â”‚ > Literal(Integer, "0xDEADCAFE")
//â”‚ > Space
//â”‚ > Literal(Integer, "0b1101")
//â”‚ > Space
//â”‚ > Literal(Integer, "0o755")
//â”‚ > Space
//â”‚ > Literal(Decimal, "3.1415926535")

// Good strings.
printLexed of """
"hello, world"
"\x48\x65\x6C\x6C\x6F\x2C\x20\x77\x6F\x72\x6C\x64"
"\u0048\u0065\u006C\u006C\u006F\u002C\u0020\u0077\u006F\u0072\u006C\u0064"
"\u{48}\u{65}\u{6C}\u{6C}\u{6F}\u{2C}\u{20}\u{77}\u{6F}\u{72}\u{6C}\u{64}"
"\u{1F600}" // ðŸ˜€
"\u{1F601}" // ðŸ˜
"\u{1F602}" // ðŸ˜‚
"\u{1F603}" // ðŸ˜ƒ
"\u{1F604}" // ðŸ˜„
"\n\r\t\b"
"""
//â”‚ > Space
//â”‚ > Literal(String, "hello, world")
//â”‚ > Space
//â”‚ > Literal(String, "Hello, world")
//â”‚ > Space
//â”‚ > Literal(String, "Hello, world")
//â”‚ > Space
//â”‚ > Literal(String, "Hello, world")
//â”‚ > Space
//â”‚ > Literal(String, "ðŸ˜€")
//â”‚ > Space
//â”‚ > Comment( ðŸ˜€)
//â”‚ > Space
//â”‚ > Literal(String, "ðŸ˜")
//â”‚ > Space
//â”‚ > Comment( ðŸ˜)
//â”‚ > Space
//â”‚ > Literal(String, "ðŸ˜‚")
//â”‚ > Space
//â”‚ > Comment( ðŸ˜‚)
//â”‚ > Space
//â”‚ > Literal(String, "ðŸ˜ƒ")
//â”‚ > Space
//â”‚ > Comment( ðŸ˜ƒ)
//â”‚ > Space
//â”‚ > Literal(String, "ðŸ˜„")
//â”‚ > Space
//â”‚ > Comment( ðŸ˜„)
//â”‚ > Space
//â”‚ > Literal(String, "\n\r\t\b")
//â”‚ > Space

// Ill-formed Strings
// ==================

printLexed of """
"hello, world.   """
//â”‚ > Space
//â”‚ > Literal(String, "hello, world.   ")

printLexed of """
"hello, \world"""
//â”‚ > Space
//â”‚ > Literal(String, "hello, world")

printLexed of """let v' =
  let a, b = (1, 2) in a + b"""
//â”‚ > Identifier(let, false)
//â”‚ > Space
//â”‚ > Identifier(v', false)
//â”‚ > Space
//â”‚ > Identifier(=, true)
//â”‚ > Space
//â”‚ > Identifier(let, false)
//â”‚ > Space
//â”‚ > Identifier(a, false)
//â”‚ > Comma
//â”‚ > Space
//â”‚ > Identifier(b, false)
//â”‚ > Space
//â”‚ > Identifier(=, true)
//â”‚ > Space
//â”‚ > Open(Round)
//â”‚ > Literal(Integer, "1")
//â”‚ > Comma
//â”‚ > Space
//â”‚ > Literal(Integer, "2")
//â”‚ > Close(Round)
//â”‚ > Space
//â”‚ > Identifier(in, false)
//â”‚ > Space
//â”‚ > Identifier(a, false)
//â”‚ > Space
//â”‚ > Identifier(+, true)
//â”‚ > Space
//â”‚ > Identifier(b, false)

printLexed of lines of
  "let rec factorial x = // a simple factorial function"
  "  if x <= 1 then 1 else x * factorial (x - 1)"
  ""
  "let bool_of_string = function"
  "  | \"true\" -> true"
  "  | \"false\" -> false"
  "  | _ -> raise (Invalid_argument \"bool_of_string\")"
//â”‚ > Identifier(let, false)
//â”‚ > Space
//â”‚ > Identifier(rec, false)
//â”‚ > Space
//â”‚ > Identifier(factorial, false)
//â”‚ > Space
//â”‚ > Identifier(x, false)
//â”‚ > Space
//â”‚ > Identifier(=, true)
//â”‚ > Space
//â”‚ > Comment( a simple factorial function)
//â”‚ > Space
//â”‚ > Identifier(if, false)
//â”‚ > Space
//â”‚ > Identifier(x, false)
//â”‚ > Space
//â”‚ > Identifier(<=, true)
//â”‚ > Space
//â”‚ > Literal(Integer, "1")
//â”‚ > Space
//â”‚ > Identifier(then, false)
//â”‚ > Space
//â”‚ > Literal(Integer, "1")
//â”‚ > Space
//â”‚ > Identifier(else, false)
//â”‚ > Space
//â”‚ > Identifier(x, false)
//â”‚ > Space
//â”‚ > Identifier(*, true)
//â”‚ > Space
//â”‚ > Identifier(factorial, false)
//â”‚ > Space
//â”‚ > Open(Round)
//â”‚ > Identifier(x, false)
//â”‚ > Space
//â”‚ > Identifier(-, true)
//â”‚ > Space
//â”‚ > Literal(Integer, "1")
//â”‚ > Close(Round)
//â”‚ > Space
//â”‚ > Identifier(let, false)
//â”‚ > Space
//â”‚ > Identifier(bool_of_string, false)
//â”‚ > Space
//â”‚ > Identifier(=, true)
//â”‚ > Space
//â”‚ > Identifier(function, false)
//â”‚ > Space
//â”‚ > Identifier(|, true)
//â”‚ > Space
//â”‚ > Literal(String, "true")
//â”‚ > Space
//â”‚ > Identifier(->, true)
//â”‚ > Space
//â”‚ > Literal(Boolean, "true")
//â”‚ > Space
//â”‚ > Identifier(|, true)
//â”‚ > Space
//â”‚ > Literal(String, "false")
//â”‚ > Space
//â”‚ > Identifier(->, true)
//â”‚ > Space
//â”‚ > Literal(Boolean, "false")
//â”‚ > Space
//â”‚ > Identifier(|, true)
//â”‚ > Space
//â”‚ > Identifier(_, false)
//â”‚ > Space
//â”‚ > Identifier(->, true)
//â”‚ > Space
//â”‚ > Identifier(raise, false)
//â”‚ > Space
//â”‚ > Open(Round)
//â”‚ > Identifier(Invalid_argument, false)
//â”‚ > Space
//â”‚ > Literal(String, "bool_of_string")
//â”‚ > Close(Round)

// It turns out that OCaml identifiers' apostrophes are not limited to the end.
printLexed of "a'b"
printLexed of "'a"
//â”‚ > Identifier(a'b, false)
//â”‚ > TypeVariable(a)

:e
// It would be decent if we allow pattern parameters in functions.
fun take(pattern P, idx: Str, acc: Str) =
  while idx < str.length and str.charAt(idx) is ch and ch is P
    then
      set idx = idx + 1
      set acc = acc + ch
    else [acc, idx]
//â”‚ â•”â•â•[ERROR] Name not found: str
//â”‚ â•‘  l.225: 	  while idx < str.length and str.charAt(idx) is ch and ch is P
//â”‚ â•™â”€â”€       	              ^^^
//â”‚ â•”â•â•[ERROR] Name not found: str
//â”‚ â•‘  l.225: 	  while idx < str.length and str.charAt(idx) is ch and ch is P
//â”‚ â•™â”€â”€       	                             ^^^
//â”‚ â•”â•â•[ERROR] Cannot use this identifier as a pattern
//â”‚ â•‘  l.225: 	  while idx < str.length and str.charAt(idx) is ch and ch is P
//â”‚ â•™â”€â”€       	                                                             ^

:e
// We can mitigate the boilerplate if we support split around `of`.
fun foobar(x) = if x is
  None then "hello"
  Some of
    a then a
//â”‚ â•”â•â•[ERROR] Unrecognized pattern split.
//â”‚ â•‘  l.244: 	  Some of
//â”‚ â•‘         	  ^^^^^^^
//â”‚ â•‘  l.245: 	    a then a
//â”‚ â•™â”€â”€       	^^^^^^^^^^^^
//â”‚ â•”â•â•[ERROR] Name not found: None
//â”‚ â•‘  l.243: 	  None then "hello"
//â”‚ â•™â”€â”€       	  ^^^^
//â”‚ â•”â•â•[ERROR] Cannot use this identifier as a pattern
//â”‚ â•‘  l.243: 	  None then "hello"
//â”‚ â•™â”€â”€       	  ^^^^

