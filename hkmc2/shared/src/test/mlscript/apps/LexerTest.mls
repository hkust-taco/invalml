:js

import "../../mlscript-compile/apps/Lexer.mls"
import "../../mlscript-compile/apps/parsing/Token.mls"
import "../../mlscript-compile/Stack.mls"

fun lines(...strs) = strs.join("\n")

open Lexer { lex }
open Stack

fun mapJoin[A](stack: Stack[A], op: A -> Str, sep: Str) =
  let buffer = ""
  while stack is head :: tail do
    set buffer = buffer + op(head)
    if tail is _ :: _ do
      set buffer = buffer + sep
    set stack = tail
  buffer

fun printLexed(text) = print of
  (lex of text) mapJoin(Token.display, "\n")

lex of "0 1"
//│ = Cons(Literal(Integer, "0"), Cons(Space, Cons(Literal(Integer, "1"), Nil)))

printLexed of "0 1  0xDEADCAFE 0b1101 0o755     3.1415926535"
//│ > Literal(Integer, "0")
//│ > Space
//│ > Literal(Integer, "1")
//│ > Space
//│ > Literal(Integer, "0xDEADCAFE")
//│ > Space
//│ > Literal(Integer, "0b1101")
//│ > Space
//│ > Literal(Integer, "0o755")
//│ > Space
//│ > Literal(Decimal, "3.1415926535")

// Good strings.
printLexed of """
"hello, world"
"\x48\x65\x6C\x6C\x6F\x2C\x20\x77\x6F\x72\x6C\x64"
"\u0048\u0065\u006C\u006C\u006F\u002C\u0020\u0077\u006F\u0072\u006C\u0064"
"\u{48}\u{65}\u{6C}\u{6C}\u{6F}\u{2C}\u{20}\u{77}\u{6F}\u{72}\u{6C}\u{64}"
"\u{1F600}" // 😀
"\u{1F601}" // 😁
"\u{1F602}" // 😂
"\u{1F603}" // 😃
"\u{1F604}" // 😄
"\n\r\t\b"
"""
//│ > Space
//│ > Literal(String, "hello, world")
//│ > Space
//│ > Literal(String, "Hello, world")
//│ > Space
//│ > Literal(String, "Hello, world")
//│ > Space
//│ > Literal(String, "Hello, world")
//│ > Space
//│ > Literal(String, "😀")
//│ > Space
//│ > Comment( 😀)
//│ > Space
//│ > Literal(String, "😁")
//│ > Space
//│ > Comment( 😁)
//│ > Space
//│ > Literal(String, "😂")
//│ > Space
//│ > Comment( 😂)
//│ > Space
//│ > Literal(String, "😃")
//│ > Space
//│ > Comment( 😃)
//│ > Space
//│ > Literal(String, "😄")
//│ > Space
//│ > Comment( 😄)
//│ > Space
//│ > Literal(String, "\n\r\t\b")
//│ > Space

// Ill-formed Strings
// ==================

printLexed of """
"hello, world.   """
//│ > Space
//│ > Literal(String, "hello, world.   ")

printLexed of """
"hello, \world"""
//│ > Space
//│ > Literal(String, "hello, world")

printLexed of """let v' =
  let a, b = (1, 2) in a + b"""
//│ > Identifier(let, false)
//│ > Space
//│ > Identifier(v', false)
//│ > Space
//│ > Identifier(=, true)
//│ > Space
//│ > Identifier(let, false)
//│ > Space
//│ > Identifier(a, false)
//│ > Comma
//│ > Space
//│ > Identifier(b, false)
//│ > Space
//│ > Identifier(=, true)
//│ > Space
//│ > Open(Round)
//│ > Literal(Integer, "1")
//│ > Comma
//│ > Space
//│ > Literal(Integer, "2")
//│ > Close(Round)
//│ > Space
//│ > Identifier(in, false)
//│ > Space
//│ > Identifier(a, false)
//│ > Space
//│ > Identifier(+, true)
//│ > Space
//│ > Identifier(b, false)

printLexed of lines of
  "let rec factorial x = // a simple factorial function"
  "  if x <= 1 then 1 else x * factorial (x - 1)"
  ""
  "let bool_of_string = function"
  "  | \"true\" -> true"
  "  | \"false\" -> false"
  "  | _ -> raise (Invalid_argument \"bool_of_string\")"
//│ > Identifier(let, false)
//│ > Space
//│ > Identifier(rec, false)
//│ > Space
//│ > Identifier(factorial, false)
//│ > Space
//│ > Identifier(x, false)
//│ > Space
//│ > Identifier(=, true)
//│ > Space
//│ > Comment( a simple factorial function)
//│ > Space
//│ > Identifier(if, false)
//│ > Space
//│ > Identifier(x, false)
//│ > Space
//│ > Identifier(<=, true)
//│ > Space
//│ > Literal(Integer, "1")
//│ > Space
//│ > Identifier(then, false)
//│ > Space
//│ > Literal(Integer, "1")
//│ > Space
//│ > Identifier(else, false)
//│ > Space
//│ > Identifier(x, false)
//│ > Space
//│ > Identifier(*, true)
//│ > Space
//│ > Identifier(factorial, false)
//│ > Space
//│ > Open(Round)
//│ > Identifier(x, false)
//│ > Space
//│ > Identifier(-, true)
//│ > Space
//│ > Literal(Integer, "1")
//│ > Close(Round)
//│ > Space
//│ > Identifier(let, false)
//│ > Space
//│ > Identifier(bool_of_string, false)
//│ > Space
//│ > Identifier(=, true)
//│ > Space
//│ > Identifier(function, false)
//│ > Space
//│ > Identifier(|, true)
//│ > Space
//│ > Literal(String, "true")
//│ > Space
//│ > Identifier(->, true)
//│ > Space
//│ > Literal(Boolean, "true")
//│ > Space
//│ > Identifier(|, true)
//│ > Space
//│ > Literal(String, "false")
//│ > Space
//│ > Identifier(->, true)
//│ > Space
//│ > Literal(Boolean, "false")
//│ > Space
//│ > Identifier(|, true)
//│ > Space
//│ > Identifier(_, false)
//│ > Space
//│ > Identifier(->, true)
//│ > Space
//│ > Identifier(raise, false)
//│ > Space
//│ > Open(Round)
//│ > Identifier(Invalid_argument, false)
//│ > Space
//│ > Literal(String, "bool_of_string")
//│ > Close(Round)

// It turns out that OCaml identifiers' apostrophes are not limited to the end.
printLexed of "a'b"
printLexed of "'a"
//│ > Identifier(a'b, false)
//│ > TypeVariable(a)

:e
// It would be decent if we allow pattern parameters in functions.
fun take(pattern P, idx: Str, acc: Str) =
  while idx < str.length and str.charAt(idx) is ch and ch is P
    then
      set idx = idx + 1
      set acc = acc + ch
    else [acc, idx]
//│ ╔══[ERROR] Name not found: str
//│ ║  l.225: 	  while idx < str.length and str.charAt(idx) is ch and ch is P
//│ ╙──       	              ^^^
//│ ╔══[ERROR] Name not found: str
//│ ║  l.225: 	  while idx < str.length and str.charAt(idx) is ch and ch is P
//│ ╙──       	                             ^^^
//│ ╔══[ERROR] Cannot use this identifier as a pattern
//│ ║  l.225: 	  while idx < str.length and str.charAt(idx) is ch and ch is P
//│ ╙──       	                                                             ^

:e
// We can mitigate the boilerplate if we support split around `of`.
fun foobar(x) = if x is
  None then "hello"
  Some of
    a then a
//│ ╔══[ERROR] Unrecognized pattern split.
//│ ║  l.244: 	  Some of
//│ ║         	  ^^^^^^^
//│ ║  l.245: 	    a then a
//│ ╙──       	^^^^^^^^^^^^
//│ ╔══[ERROR] Name not found: None
//│ ║  l.243: 	  None then "hello"
//│ ╙──       	  ^^^^
//│ ╔══[ERROR] Cannot use this identifier as a pattern
//│ ║  l.243: 	  None then "hello"
//│ ╙──       	  ^^^^

