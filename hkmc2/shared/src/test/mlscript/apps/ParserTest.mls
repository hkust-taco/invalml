:js

import "../../mlscript-compile/Option.mls"
import "../../mlscript-compile/Stack.mls"
import "../../mlscript-compile/apps/Lexer.mls"

open Option
open Stack
open Lexer { Token, LiteralKind, BracketKind }

//  _     _     _
// | |   (_)___| |_
// | |   | / __| __|
// | |___| \__ \ |_
// |_____|_|___/\__|
// 
// =================

fun at(target, index) = target.at(index)

fun first(array) = if array is [first, ...] then first

fun second(array) = if array is [_, second, ...] then second

fun toStack(array) =
  let
    length = array.length
    i = length - 1
    reserve = Nil
  while i >= 0 do
    set reserve = array.at(i) :: reserve
    set i = i - 1
  reserve

fun stack(...args) = args toStack()

fun filter(xs, f) = if xs is
  head :: tail and
    f(head) then head :: filter(tail, f)
    else filter(tail, f)
  Nil then Nil
  
fun mapJoin[A](stack: Stack[A], op: A -> Str, sep: Str) =
  let buffer = ""
  while stack is head :: tail do
    set buffer = buffer + op(head)
    if tail is _ :: _ do
      set buffer = buffer + sep
    set stack = tail
  buffer

fun collectFirst[A, B](stack: Stack[A], op: A -> Option[B]) =
  let lastResult = None
  while stack is head :: tail and
    do set lastResult = op(head)
    lastResult is None do
      set stack = tail
  lastResult

fun collectToArray[A, B](stack: Stack[A], p: A -> Option[B]) =
  let elements = []
  while stack is head :: tail do
    if p(head) is Some(value) do
      elements.push of value
    set stack = tail
  elements

//  __  __
// |  \/  | __ _ _ __
// | |\/| |/ _` | '_ \
// | |  | | (_| | |_) |
// |_|  |_|\__,_| .__/
//              |_|
// ====================

class Map with
  val storage = new globalThis.Map()
  
  fun get(key) =
    if storage.has(key)
    then Some of storage.get(key)
    else None
  
  fun insert(key, value) =
    storage.set(key, value)
    ()
    
  fun values = globalThis.Array.from of storage.values()

fun toMap(...entries) =
  let
    m = new Map
    i = 0
    length = entries.length
  while i < length do
    m.insert of ...entries.at(i)
    set i += 1
  m
  

//  _  __                                _
// | |/ /___ _   ___      _____  _ __ __| |
// | ' // _ \ | | \ \ /\ / / _ \| '__/ _` |
// | . \  __/ |_| |\ V  V / (_) | | | (_| |
// |_|\_\___|\__, | \_/\_/ \___/|_|  \__,_|
//           |___/
// ========================================

let keywords = new Map()
//│ keywords = Map

class Keyword(val name: Str, val leftPrec: Option[Int], val rightPrec: Option[Int]) with
  keywords.insert(name, this)
  
  fun toString() = fold(+) of
    "Keyword(", name, ", "
    (if leftPrec is Some(prec) then prec.toString() else "N/A"), ", ",
    (if rightPrec is Some(prec) then prec.toString() else "N/A"), ")"

module Keywords with
  let prec = 0 
  fun currPrec = Some(prec)
  fun nextPrec =
    set prec = prec + 1
    Some(prec)
  val _class = Keyword("class", None, currPrec)
  let eqPrec = nextPrec
  let ascPrec = nextPrec
  val _equal = Keyword("=", eqPrec, eqPrec)
  val _colon = Keyword(":", ascPrec, eqPrec)
  val _semicolon = Keyword(";", ascPrec, eqPrec)
  val _case = Keyword("case", None, currPrec)
  let thenPrec = nextPrec
  val _then = Keyword("then", thenPrec, thenPrec)
  val _do = Keyword("do", thenPrec, thenPrec)
  val _else = Keyword("else", nextPrec, currPrec)
  val _fun = Keyword("fun", None, None)
  val _let = Keyword("let", nextPrec, currPrec)
  val _in = Keyword("in", thenPrec, thenPrec)
  val _true = Keyword("true", None, None)
  val _false = Keyword("false", None, None)
  val _fatArrow = Keyword of "=>", nextPrec, eqPrec
  val _thinArrow = Keyword of "->", currPrec, eqPrec
  val _underscore = Keyword of "_", None, None
  val maxPrec = prec

Keywords.maxPrec
//│ = 6

print of keywords.values.join("\n")
//│ > Keyword(class, N/A, 0)
//│ > Keyword(=, 1, 1)
//│ > Keyword(:, 2, 1)
//│ > Keyword(;, 2, 1)
//│ > Keyword(case, N/A, 2)
//│ > Keyword(then, 3, 3)
//│ > Keyword(do, 3, 3)
//│ > Keyword(else, 4, 4)
//│ > Keyword(fun, N/A, N/A)
//│ > Keyword(let, 5, 5)
//│ > Keyword(in, 3, 3)
//│ > Keyword(true, N/A, N/A)
//│ > Keyword(false, N/A, N/A)
//│ > Keyword(=>, 6, 1)
//│ > Keyword(->, 6, 1)
//│ > Keyword(_, N/A, N/A)

//  ____                        _
// |  _ \ _ __ ___  ___ ___  __| | ___ _ __   ___ ___
// | |_) | '__/ _ \/ __/ _ \/ _` |/ _ \ '_ \ / __/ _ \
// |  __/| | |  __/ (_|  __/ (_| |  __/ | | | (_|  __/
// |_|   |_|  \___|\___\___|\__,_|\___|_| |_|\___\___|
//
// ===================================================

fun makePrecMap(...ops) =
  let
    m = new Map
    i = 0
  while i < ops.length do
    ops.at(i).split(" ").forEach of (op, _, _) =>
      m.insert of op, i + Keywords.maxPrec
    set i += 1
  m

let precMap = makePrecMap(
  ","
  "@",
  ":",
  "|",
  "&",
  "=",
  "/ \\",
  "^",
  "!",
  "< >",
  "+ -",
  "* %",
  "~",
  "", // perfix operators
  "", // applications
  ".",
)
//│ precMap = Map

let largestPrec = 2147483647
//│ largestPrec = 2147483647

fun orMaxPrec(precOpt) = if precOpt is
  Some(prec) then prec
  None then largestPrec

fun charPrec(op) = if precMap.get(op) is Some(prec) then prec else largestPrec

pattern Letter = "a" ..= "z" | "A" ..= "Z"

fun hasLetter(s) = [..s].some((ch, _, _) => ch is Letter)

pattern FloatOperator = "+." | "-." | "*." | "/."

pattern RightAssociative = "@" | "/" | "," | ":"

fun opPrec(opStr) = if
  opStr is FloatOperator then [charPrec(opStr.at(0)), charPrec(opStr.at(1))]
  opStr hasLetter() then [Keywords.maxPrec, Keywords.maxPrec]
  let leftPrec = charPrec of opStr.at(0)
  let rightOp = opStr.at(-1)
  let rightPrec = charPrec of rightOp
  rightOp is RightAssociative then [leftPrec, rightPrec - 1]
  else [leftPrec, rightPrec]

opPrec("|>")
//│ = [9, 15]

//  _____
// |_   _| __ ___  ___
//   | || '__/ _ \/ _ \
//   | || | |  __/  __/
//   |_||_|  \___|\___|
//
// ====================

module Tree with
  class
    Empty()
    Error(tree: Tree, message: Str)
    Ident(name: Str, symbolic: Bool)
    Modified(modifier, subject)
    Literal(kind, value)
    Case(scrutinee: Tree, branches: Stack[Tree])
    App(callee: Tree, arguments: Stack[Tree])
    Infix(op: Keyword, lhs: Tree, rhs: Tree)
    LetLike(keyword: Keyword, lhs: Tree, rhs: Tree, body: Option[Tree])
  
  fun empty = Empty()
  fun error(message: Str) = empty Error(message)
  fun summary(tree) =
    fun par(text: Str, cond: Bool) = if cond then "(" + text + ")" else text
    fun prec(tree: Tree, side: Bool) = if tree is
      Empty(_) then largestPrec
      Error(tree, _) then prec(tree, side)
      Ident(_, _) then largestPrec
      Modified(_, _) then 1
      Literal(_, _) then largestPrec
      Case(_, _) then 2
      App(callee, _) and callee is
        Ident(op, _) and opPrec(op) is [leftPrec, rightPrec] and
          side then rightPrec
          else leftPrec
        else largestPrec
      Infix(op, _, _) and
        side then op.rightPrec orMaxPrec()
        else op.leftPrec orMaxPrec()
      LetLike(_, _, _, _) then 3
    fun go(tree) = if tree is
      Empty(_) then ""
      Error(tree, _) then "<⚠:" + go(tree) + ">"
      Ident(name, _) then name
      Modified(modifier, subject) then go(modifier) + " " + go(subject)
      Literal(_, value) then value
      Case(scrutinee, branches) then fold(+) of
        "case ", go(scrutinee)
        ...branches.map((branch, _, _) => "| " + go(branch))
      App(Ident(op, true), lhs :: rhs :: Nil) then
        if opPrec(op) is [leftPrec, rightPrec] then fold(+) of
          par of go(lhs), prec(lhs, false) < leftPrec
          " ", op, " "
          par of go(rhs), prec(rhs, true) < rightPrec
      App(callee, arguments) then fold(+) of
        go(callee), "(", arguments mapJoin(go, ","), ")"
      Infix(op, lhs, rhs) then fold(+) of
        go(lhs), " ", go(op), " ", go(rhs)
      LetLike(keyword, lhs, rhs, body) then fold(+) of
        keyword.name, " ", go(lhs), " = "
        if rhs is Some(rhs) then go(rhs) else ""
        " in "
        if body is Some(body) then go(body) else ""
      Keyword(name, _, _) then name
      Some(tree) then "<some:" + go(tree) + ">"
      None then "<none>"
      [..trees] then "<tuple:" + trees.map((tree, _, _) => go(tree)).join(";") + ">"
      else "<unexpected:" + tree + ">"
    go(tree)

//  ____                     ____        _
// |  _ \ __ _ _ __ ___  ___|  _ \ _   _| | ___
// | |_) / _` | '__/ __|/ _ \ |_) | | | | |/ _ \
// |  __/ (_| | |  \__ \  __/  _ <| |_| | |  __/
// |_|   \__,_|_|  |___/\___|_| \_\\__,_|_|\___|
//
// =============================================

class ParseRule(val name: Str, val choices: Stack[Choice]) with
  val endChoice = choices collectFirst of case
    Choice.End(value) then Some(value)
    else None
  val keywordChoices = toMap of ...(choices collectToArray of choice =>
      if choice is Choice.Keyword(keyword, rest) then Some([keyword.name, rest]) else None)
  val exprChoice = choices collectFirst of case
    Choice.Expr(process, rest) then Some([process, rest])
    else None
  // Display parse rules as a tree in a BNF-like format.
  fun display =
    fun go(rule) =
      let
        choices = rule.choices
        lines = []
      while choices is head :: tail do
        lines.push of (if head is
          Choice.Keyword(keyword, rest) and
            let prefix = "`" + keyword.name + "` "
            go(rest) is
              [name, [line]] then [prefix + line]
              [name, [head', ..tail']] then [prefix + head', ..tail']
          Choice.Expr(_, rest) and
            let prefix = "<expression> "
            go(rest) is
              [name, [line]] then [prefix + line]
              [name, lines] then [prefix, ..lines.map((line, _, _) => "  " + line)]
          Choice.End(_) then ["<end>"])
        set choices = tail
      [rule.name, lines.flat()]
    if go(this) is [name, lines] then
      "<" + name + "> ::= " + if lines is
        [line] then line
        [head, ..tail] then head + "\n" + tail.join("\n")
  
// Shorthands for constructing parse rules.
fun rule(name, ...choices) = ParseRule(name, toStack(choices))
module Choice with
  class Keyword(keyword: Keyword, rest: ParseRule)
  class Expr(process: Tree -> Tree, rest: ParseRule)
  class End(value: Tree)
  // Shorthands for constructing rule choices.
  fun keyword(keyword, name, ...choices) = Keyword(keyword, rule(name, ...choices))
  fun expr(process, name, ...choices) = Expr(process, rule(name, ...choices))
  fun end(value) = End(value)

//  ____       _
// |  _ \  ___| |__  _   _  __ _
// | | | |/ _ \ '_ \| | | |/ _` |
// | |_| |  __/ |_) | |_| | (_| |
// |____/ \___|_.__/ \__,_|\__, |
//                         |___/
// ==============================

import "../../mlscript-compile/TreeTracer.mls"

open TreeTracer { TreeTracer }

let tracer = new TreeTracer
//│ tracer = TreeTracer

fun indented(text) = text.split("\n").join("\n  ")

fun showAsTree(thing) =
  fun itemize(something) = if something is
    Some(content) then tuple of ["Some of " + go(content)], []
    None then tuple of "None", []
    head :: tail then
      let
        items = [go(head)]
        remaining = tail
      while remaining is
        head' :: tail' do
          items.push(go of head')
          set remaining = tail'
      tuple of ("Stack of \n" + "  " + indented of items.join("\n")), []
    Nil then ["Nil", []]
    Str then [JSON.stringify(something), []] // TODO: This doesn't work.
    Int then [something.toString(), []]
    Tree.Empty then ["Empty", []]
    Tree.Error(Tree.Empty, m) then tuple of "Error", [["message", go(m)]]
    Tree.Error(t, m) then tuple of "Error", [["tree", go(t)], ["message", go(m)]]
    Tree.Ident(n, _) then tuple of "Ident", [["name", go(n)]]
    Tree.Modified(m, s) then
      tuple of "Modified", [["modifier", go(m)], ["subject", go(s)]]
    Tree.Literal(k, v) then tuple of ("Literal#" + go(k) + " of " + go(v)), []
    Tree.Case(branches) then tuple of "Case", [["branches", go(branches)]]
    Tree.App(c, a) then tuple of "App", [["callee", go(c)], ["arguments", go(a)]]
    Tree.Infix(op, lhs, rhs) then tuple of
      "Infix", [["op", go(op)], ["lhs", go(lhs)], ["rhs", go(rhs)]]
    Tree.LetLike(n, l, r, b) then tuple of
      "LetLike", [["name", go(n)], ["lhs", go(l)], ["rhs", go(r)], ["body", go(b)]]
    Keyword(_, _, _) as keyword then [keyword.toString(), []]
    LiteralKind.Integer then tuple of "Integer", []
    LiteralKind.Decimal then tuple of "Decimal", []
    LiteralKind.String then tuple of "String", []
    LiteralKind.Boolean then tuple of "Boolean", []
    else tuple of "Unknown", [["JSON.stringify(_)", JSON.stringify(something)]]
  fun go(something) = if itemize(something) is
    [intro, []] then intro
    [intro, [field]] and intro != "Unknown" then intro + " of " + second of field
    [intro, fields] then
      let dialogue = fields.map of (field, _, _) =>
        field first() + " = " + field second()
      intro + ":\n  " + indented of dialogue.join("\n")
  go(thing)

fun letLike(keyword: Keyword) =
  let intro = keyword.name + " binding: "
  Choice.keyword of
    keyword
    intro + "keyword"
    Choice.expr of
      (lhs, rhsAndBody) => if rhsAndBody is [rhs, body] then
        Tree.LetLike(keyword, lhs, rhs, body)
      intro + "left-hand side"
      Choice.keyword of
        Keywords._equal
        intro + "equal sign"
        Choice.expr of
          (expr, body) => [Some(expr), body]
          intro + "right-hand side"
          Choice.keyword of
            Keywords._in
            intro + "`in` keyword"
            Choice.expr of
              (body, something) =>
                print("wooooo" + something)
                Some(body)
              intro + "body"
              Choice.end of None
          Choice.end of None
      Choice.end of [None, None]

let letChoice = letLike(Keywords._let)
//│ letChoice = Keyword(Keyword(let, 5, 5), ParseRule("let binding: keyword", Cons(Expr([function tmp8], ParseRule("let binding: left-hand side", Cons(Keyword(Keyword(=, 1, 1), ParseRule("let binding: equal sign", Cons(Expr([function], ParseRule("let binding: right-hand side", Cons(Keyword(Keyword(in, 3, 3), ParseRule("let binding: `in` keyword", Cons(Expr([function], ParseRule("let binding: body", Cons(End(None), Nil))), Nil))), Cons(End(None), Nil)))), Nil))), Cons(End([None, None]), Nil)))), Nil)))

print of rule("let binding", letChoice).display
//│ > <let binding> ::= `let` <expression> 
//│ >   `=` <expression> 
//│ >     `in` <expression> <end>
//│ >     <end>
//│ >   <end>

let prefixRules = rule("start of the statement", letChoice)
//│ prefixRules = ParseRule("start of the statement", Cons(Keyword(Keyword(let, 5, 5), ParseRule("let binding: keyword", Cons(Expr([function tmp8], ParseRule("let binding: left-hand side", Cons(Keyword(Keyword(=, 1, 1), ParseRule("let binding: equal sign", Cons(Expr([function], ParseRule("let binding: right-hand side", Cons(Keyword(Keyword(in, 3, 3), ParseRule("let binding: `in` keyword", Cons(Expr([function], ParseRule("let binding: body", Cons(End(None), Nil))), Nil))), Cons(End(None), Nil)))), Nil))), Cons(End([None, None]), Nil)))), Nil))), Nil))

prefixRules.endChoice
//│ = None

prefixRules.keywordChoices.get("let")
//│ = Some(ParseRule("let binding: keyword", Cons(Expr([function tmp8], ParseRule("let binding: left-hand side", Cons(Keyword(Keyword(=, 1, 1), ParseRule("let binding: equal sign", Cons(Expr([function], ParseRule("let binding: right-hand side", Cons(Keyword(Keyword(in, 3, 3), ParseRule("let binding: `in` keyword", Cons(Expr([function], ParseRule("let binding: body", Cons(End(None), Nil))), Nil))), Cons(End(None), Nil)))), Nil))), Cons(End([None, None]), Nil)))), Nil)))

prefixRules.exprChoice
//│ = None

fun parse(tokens) =
  let
    current = tokens
    counter = 0
  
  fun yeetSpaces =
    while current is Token.Space :: tail do
      tracer.print of "skipped a space at " + counter
      set
        current = tail
        counter = counter + 1
    current
    
  fun consume =
    if current is head :: tail then
      tracer.print of "consumed " + head + " at " + counter
      set current = tail
      set counter = counter + 1
    else
      tracer.print of "consumed: EOF"
  
  fun parseRule(prec: Int, rule: ParseRule, opened: Option[BracketKind]) = tracer.trace of
    "parsing rule \"" + rule.name + "\" with precedence " + prec
    result => "parsed: " + result Tree.summary()
    () => ...
    if yeetSpaces is
      Token.Close(encountered) :: _ and opened is
        do tracer.print of "the case of closing brackets"
        Some(expected) and
          encountered == expected and rule.endChoice is
            Some(value) then
              consume
              value
            None then
              // The rule doesn't allow an end here.
              Tree.error("unexpected close bracket `" + encountered + "`")
          else
            // The rule expects a different close bracket.
            Tree.error("mismatched brackets")
        None then Tree.error("unexpected bracket: " + encountered)
      Token.Identifier(name, _) :: _ and
        do tracer.print of "check if \"" + name + "\" is a keyword or not"
        keywords.get(name) is
          Some(keyword) and rule.keywordChoices.get(name) is
            Some(rule) then
              consume
              parseRule(keyword.rightPrec orMaxPrec(), rule, opened)
            None then Tree.error("unexpected keyword `" + name + "`")
        do tracer.print of "\"" + name + "\" is not a keyword"
      other :: _ and
        do tracer.print of "try parse an expression from " + Token.preview(current)
        let reserve = simpleExpr(prec, opened)
        rule.exprChoice is
          Some([process, rest]) then 
            let rhs = parseRule(prec, rest, opened)
            tracer.print of "the result from sub-rule: " + rhs Tree.summary()
            tracer.print of "the reserved expression: " + reserve Tree.summary()
            process(reserve, rhs)
          None then Tree.error("unexpected expression")
      Nil and rule.endChoice is
        Some(value) then value
        None then Tree.error("unexpected EOF")
  
  fun simpleExpr(prec: Int, bracket: Option[BracketKind]) = tracer.trace of
    "simple expression with precedence " + prec
    result => "simple expression: " + result Tree.summary()
    () => if yeetSpaces is
      Token.Identifier(name, symbolic) :: _ and keywords.get(name) is
        Some(keyword) and prefixRules.keywordChoices.get(name) is
          Some(rule) then
            consume
            parseRule(keyword.rightPrec orMaxPrec(), rule, bracket)
          None then Tree.error("unexpected keyword `" + name + "` without any prefix rules")
        None then
          consume
          exprCont(Tree.Ident(name, symbolic), prec, bracket)
      Token.Literal(kind, literal) :: _ then
        consume
        exprCont(Tree.Literal(kind, literal), prec, bracket)
      Token.Open(kind) :: _ then
        consume
        let content = if
          // TODO: should the prec be 0?
          let content = simpleExpr(0, Some(kind))
          yeetSpaces is Token.Close(kind') :: _ and
            kind == kind' then
              consume
              content
            else content Tree.Error("mismatched brackets")
          else content Tree.Error("missing close bracket")
        exprCont(content, prec, bracket)
      Token.Close(kind) :: _ and bracket is
        Some(kind') and
          kind == kind' then
            consume
            Tree.Empty()
          else Tree.error("mismatched brackets")
        None then Tree.error("missing close bracket")
      token :: _ then Tree.error("unrecognized token: " + token)
      Nil then Tree.error("unexpected EOF")
  
  fun exprCont(acc: Tree, prec: Int, bracket: Option[BracketKind]) = if yeetSpaces is
    Token.Identifier(name, _) :: _ and keywords.get(name) is Some(keyword) and
      do tracer.print of "found an infix keyword: " + name
      keyword.leftPrec is Some(leftPrec) and
        leftPrec > prec then
          consume
          let rhs = simpleExpr(leftPrec, bracket)
          exprCont(Tree.Infix(keyword, acc, rhs), prec, bracket)
        else
          acc
    Token.Identifier(name, true) :: _ and
      do tracer.print of "found an operator \"" + name + "\""
      opPrec(name) is [leftPrec, rightPrec] and
        leftPrec > prec then
          consume
          let op = Tree.Ident(name, true)
          let rhs = simpleExpr(rightPrec, bracket)
          exprCont(Tree.App(op, acc :: rhs :: Nil), prec, bracket)
        else
          acc
    Token.Close(kind) :: _ and bracket is
      do tracer.print of "found a close bracket of " + kind
      Some(kind') and
        kind == kind' then acc
        else acc Tree.Error("mismatched brackets")
      None then acc Tree.Error("missing close bracket")
    token :: _ then acc Tree.Error("unrecognized token " + token)
    Nil and bracket is
      do tracer.print of "found an EOF"
      Some then acc Tree.Error("expect a close bracket instead of EOF")
      None then acc
  
  simpleExpr(0, None)

fun printParsed(...lines) =
  let
    source = lines.join("\n")
    tokens = Lexer.lex(source)
    tree = parse(tokens)
  print of showAsTree(tree)

printParsed of "(x) => x"
//│ > ┍ simple expression with precedence 0
//│ > ├ consumed Open(Round) at 0
//│ > ├─┮ simple expression with precedence 0
//│ > │ ├ consumed Identifier("x", false) at 1
//│ > │ ├ found a close bracket of Round
//│ > │ ┕ simple expression: x
//│ > ├ consumed Close(Round) at 2
//│ > ├ skipped a space at 3
//│ > ├ found an infix keyword: =>
//│ > ├ consumed Identifier("=>", true) at 4
//│ > ├─┮ simple expression with precedence 6
//│ > │ ├ skipped a space at 5
//│ > │ ├ consumed Identifier("x", false) at 6
//│ > │ ├ found an EOF
//│ > │ ┕ simple expression: x
//│ > ├ found an EOF
//│ > ┕ simple expression: x => x
//│ > Infix:
//│ >   op = Keyword(=>, 6, 1)
//│ >   lhs = Ident of "x"
//│ >   rhs = Ident of "x"

printParsed of "(1 + 2) * 3"
//│ > ┍ simple expression with precedence 0
//│ > ├ consumed Open(Round) at 0
//│ > ├─┮ simple expression with precedence 0
//│ > │ ├ consumed Literal(Integer, "1") at 1
//│ > │ ├ skipped a space at 2
//│ > │ ├ found an operator "+"
//│ > │ ├ consumed Identifier("+", true) at 3
//│ > │ ├─┮ simple expression with precedence 16
//│ > │ │ ├ skipped a space at 4
//│ > │ │ ├ consumed Literal(Integer, "2") at 5
//│ > │ │ ├ found a close bracket of Round
//│ > │ │ ┕ simple expression: 2
//│ > │ ├ found a close bracket of Round
//│ > │ ┕ simple expression: 1 + 2
//│ > ├ consumed Close(Round) at 6
//│ > ├ skipped a space at 7
//│ > ├ found an operator "*"
//│ > ├ consumed Identifier("*", true) at 8
//│ > ├─┮ simple expression with precedence 17
//│ > │ ├ skipped a space at 9
//│ > │ ├ consumed Literal(Integer, "3") at 10
//│ > │ ├ found an EOF
//│ > │ ┕ simple expression: 3
//│ > ├ found an EOF
//│ > ┕ simple expression: (1 + 2) * 3
//│ > App:
//│ >   callee = Ident of "*"
//│ >   arguments = Stack of 
//│ >     App:
//│ >       callee = Ident of "+"
//│ >       arguments = Stack of 
//│ >         Literal#Integer of "1"
//│ >         Literal#Integer of "2"
//│ >     Literal#Integer of "3"

printParsed of "1 + 2 ** 5 * 4"
//│ > ┍ simple expression with precedence 0
//│ > ├ consumed Literal(Integer, "1") at 0
//│ > ├ skipped a space at 1
//│ > ├ found an operator "+"
//│ > ├ consumed Identifier("+", true) at 2
//│ > ├─┮ simple expression with precedence 16
//│ > │ ├ skipped a space at 3
//│ > │ ├ consumed Literal(Integer, "2") at 4
//│ > │ ├ skipped a space at 5
//│ > │ ├ found an operator "**"
//│ > │ ├ consumed Identifier("**", true) at 6
//│ > │ ├─┮ simple expression with precedence 17
//│ > │ │ ├ skipped a space at 7
//│ > │ │ ├ consumed Literal(Integer, "5") at 8
//│ > │ │ ├ skipped a space at 9
//│ > │ │ ├ found an operator "*"
//│ > │ │ ┕ simple expression: 5
//│ > │ ├ found an operator "*"
//│ > │ ├ consumed Identifier("*", true) at 10
//│ > │ ├─┮ simple expression with precedence 17
//│ > │ │ ├ skipped a space at 11
//│ > │ │ ├ consumed Literal(Integer, "4") at 12
//│ > │ │ ├ found an EOF
//│ > │ │ ┕ simple expression: 4
//│ > │ ├ found an EOF
//│ > │ ┕ simple expression: 2 ** 5 * 4
//│ > ├ found an EOF
//│ > ┕ simple expression: 1 + 2 ** 5 * 4
//│ > App:
//│ >   callee = Ident of "+"
//│ >   arguments = Stack of 
//│ >     Literal#Integer of "1"
//│ >     App:
//│ >       callee = Ident of "*"
//│ >       arguments = Stack of 
//│ >         App:
//│ >           callee = Ident of "**"
//│ >           arguments = Stack of 
//│ >             Literal#Integer of "2"
//│ >             Literal#Integer of "5"
//│ >         Literal#Integer of "4"

printParsed of
  "let zero = 0 in zero"
//│ > ┍ simple expression with precedence 0
//│ > ├ consumed Identifier("let", false) at 0
//│ > ├─┮ parsing rule "let binding: keyword" with precedence 5
//│ > │ ├ skipped a space at 1
//│ > │ ├ check if "zero" is a keyword or not
//│ > │ ├ "zero" is not a keyword
//│ > │ ├ try parse an expression from ┃zero│␠│=│␠│0├┈┄╌
//│ > │ ├─┮ simple expression with precedence 5
//│ > │ │ ├ consumed Identifier("zero", false) at 2
//│ > │ │ ├ skipped a space at 3
//│ > │ │ ├ found an infix keyword: =
//│ > │ │ ┕ simple expression: zero
//│ > │ ├─┮ parsing rule "let binding: left-hand side" with precedence 5
//│ > │ │ ├ check if "=" is a keyword or not
//│ > │ │ ├ consumed Identifier("=", true) at 4
//│ > │ │ ├─┮ parsing rule "let binding: equal sign" with precedence 1
//│ > │ │ │ ├ skipped a space at 5
//│ > │ │ │ ├ try parse an expression from ┃0│␠│in│␠│zero┃
//│ > │ │ │ ├─┮ simple expression with precedence 1
//│ > │ │ │ │ ├ consumed Literal(Integer, "0") at 6
//│ > │ │ │ │ ├ skipped a space at 7
//│ > │ │ │ │ ├ found an infix keyword: in
//│ > │ │ │ │ ├ consumed Identifier("in", false) at 8
//│ > │ │ │ │ ├─┮ simple expression with precedence 3
//│ > │ │ │ │ │ ├ skipped a space at 9
//│ > │ │ │ │ │ ├ consumed Identifier("zero", false) at 10
//│ > │ │ │ │ │ ├ found an EOF
//│ > │ │ │ │ │ ┕ simple expression: zero
//│ > │ │ │ │ ├ found an EOF
//│ > │ │ │ │ ┕ simple expression: 0 in zero
//│ > │ │ │ ├─┮ parsing rule "let binding: right-hand side" with precedence 1
//│ > │ │ │ │ ┕ parsed: <none>
//│ > │ │ │ ├ the result from sub-rule: <none>
//│ > │ │ │ ├ the reserved expression: 0 in zero
//│ > │ │ │ ┕ parsed: <tuple:<some:0 in zero>;<none>>
//│ > │ │ ┕ parsed: <tuple:<some:0 in zero>;<none>>
//│ > │ ├ the result from sub-rule: <tuple:<some:0 in zero>;<none>>
//│ > │ ├ the reserved expression: zero
//│ > │ ┕ parsed: let zero = 0 in zero in 
//│ > ┕ simple expression: let zero = 0 in zero in 
//│ > LetLike:
//│ >   name = Keyword(let, 5, 5)
//│ >   lhs = Ident of "zero"
//│ >   rhs = Some of Infix:
//│ >     op = Keyword(in, 3, 3)
//│ >     lhs = Literal#Integer of "0"
//│ >     rhs = Ident of "zero"
//│ >   body = None

printParsed of """
let one = 1 in
let zero = 0 in
one + zero
"""
//│ > ┍ simple expression with precedence 0
//│ > ├ skipped a space at 0
//│ > ├ consumed Identifier("let", false) at 1
//│ > ├─┮ parsing rule "let binding: keyword" with precedence 5
//│ > │ ├ skipped a space at 2
//│ > │ ├ check if "one" is a keyword or not
//│ > │ ├ "one" is not a keyword
//│ > │ ├ try parse an expression from ┃one│␠│=│␠│1├┈┄╌
//│ > │ ├─┮ simple expression with precedence 5
//│ > │ │ ├ consumed Identifier("one", false) at 3
//│ > │ │ ├ skipped a space at 4
//│ > │ │ ├ found an infix keyword: =
//│ > │ │ ┕ simple expression: one
//│ > │ ├─┮ parsing rule "let binding: left-hand side" with precedence 5
//│ > │ │ ├ check if "=" is a keyword or not
//│ > │ │ ├ consumed Identifier("=", true) at 5
//│ > │ │ ├─┮ parsing rule "let binding: equal sign" with precedence 1
//│ > │ │ │ ├ skipped a space at 6
//│ > │ │ │ ├ try parse an expression from ┃1│␠│in│␠│let├┈┄╌
//│ > │ │ │ ├─┮ simple expression with precedence 1
//│ > │ │ │ │ ├ consumed Literal(Integer, "1") at 7
//│ > │ │ │ │ ├ skipped a space at 8
//│ > │ │ │ │ ├ found an infix keyword: in
//│ > │ │ │ │ ├ consumed Identifier("in", false) at 9
//│ > │ │ │ │ ├─┮ simple expression with precedence 3
//│ > │ │ │ │ │ ├ skipped a space at 10
//│ > │ │ │ │ │ ├ consumed Identifier("let", false) at 11
//│ > │ │ │ │ │ ├─┮ parsing rule "let binding: keyword" with precedence 5
//│ > │ │ │ │ │ │ ├ skipped a space at 12
//│ > │ │ │ │ │ │ ├ check if "zero" is a keyword or not
//│ > │ │ │ │ │ │ ├ "zero" is not a keyword
//│ > │ │ │ │ │ │ ├ try parse an expression from ┃zero│␠│=│␠│0├┈┄╌
//│ > │ │ │ │ │ │ ├─┮ simple expression with precedence 5
//│ > │ │ │ │ │ │ │ ├ consumed Identifier("zero", false) at 13
//│ > │ │ │ │ │ │ │ ├ skipped a space at 14
//│ > │ │ │ │ │ │ │ ├ found an infix keyword: =
//│ > │ │ │ │ │ │ │ ┕ simple expression: zero
//│ > │ │ │ │ │ │ ├─┮ parsing rule "let binding: left-hand side" with precedence 5
//│ > │ │ │ │ │ │ │ ├ check if "=" is a keyword or not
//│ > │ │ │ │ │ │ │ ├ consumed Identifier("=", true) at 15
//│ > │ │ │ │ │ │ │ ├─┮ parsing rule "let binding: equal sign" with precedence 1
//│ > │ │ │ │ │ │ │ │ ├ skipped a space at 16
//│ > │ │ │ │ │ │ │ │ ├ try parse an expression from ┃0│␠│in│␠│one├┈┄╌
//│ > │ │ │ │ │ │ │ │ ├─┮ simple expression with precedence 1
//│ > │ │ │ │ │ │ │ │ │ ├ consumed Literal(Integer, "0") at 17
//│ > │ │ │ │ │ │ │ │ │ ├ skipped a space at 18
//│ > │ │ │ │ │ │ │ │ │ ├ found an infix keyword: in
//│ > │ │ │ │ │ │ │ │ │ ├ consumed Identifier("in", false) at 19
//│ > │ │ │ │ │ │ │ │ │ ├─┮ simple expression with precedence 3
//│ > │ │ │ │ │ │ │ │ │ │ ├ skipped a space at 20
//│ > │ │ │ │ │ │ │ │ │ │ ├ consumed Identifier("one", false) at 21
//│ > │ │ │ │ │ │ │ │ │ │ ├ skipped a space at 22
//│ > │ │ │ │ │ │ │ │ │ │ ├ found an operator "+"
//│ > │ │ │ │ │ │ │ │ │ │ ├ consumed Identifier("+", true) at 23
//│ > │ │ │ │ │ │ │ │ │ │ ├─┮ simple expression with precedence 16
//│ > │ │ │ │ │ │ │ │ │ │ │ ├ skipped a space at 24
//│ > │ │ │ │ │ │ │ │ │ │ │ ├ consumed Identifier("zero", false) at 25
//│ > │ │ │ │ │ │ │ │ │ │ │ ├ skipped a space at 26
//│ > │ │ │ │ │ │ │ │ │ │ │ ├ found an EOF
//│ > │ │ │ │ │ │ │ │ │ │ │ ┕ simple expression: zero
//│ > │ │ │ │ │ │ │ │ │ │ ├ found an EOF
//│ > │ │ │ │ │ │ │ │ │ │ ┕ simple expression: one + zero
//│ > │ │ │ │ │ │ │ │ │ ├ found an EOF
//│ > │ │ │ │ │ │ │ │ │ ┕ simple expression: 0 in one + zero
//│ > │ │ │ │ │ │ │ │ ├─┮ parsing rule "let binding: right-hand side" with precedence 1
//│ > │ │ │ │ │ │ │ │ │ ┕ parsed: <none>
//│ > │ │ │ │ │ │ │ │ ├ the result from sub-rule: <none>
//│ > │ │ │ │ │ │ │ │ ├ the reserved expression: 0 in one + zero
//│ > │ │ │ │ │ │ │ │ ┕ parsed: <tuple:<some:0 in one + zero>;<none>>
//│ > │ │ │ │ │ │ │ ┕ parsed: <tuple:<some:0 in one + zero>;<none>>
//│ > │ │ │ │ │ │ ├ the result from sub-rule: <tuple:<some:0 in one + zero>;<none>>
//│ > │ │ │ │ │ │ ├ the reserved expression: zero
//│ > │ │ │ │ │ │ ┕ parsed: let zero = 0 in one + zero in 
//│ > │ │ │ │ │ ┕ simple expression: let zero = 0 in one + zero in 
//│ > │ │ │ │ ├ found an EOF
//│ > │ │ │ │ ┕ simple expression: 1 in let zero = 0 in one + zero in 
//│ > │ │ │ ├─┮ parsing rule "let binding: right-hand side" with precedence 1
//│ > │ │ │ │ ┕ parsed: <none>
//│ > │ │ │ ├ the result from sub-rule: <none>
//│ > │ │ │ ├ the reserved expression: 1 in let zero = 0 in one + zero in 
//│ > │ │ │ ┕ parsed: <tuple:<some:1 in let zero = 0 in one + zero in >;<none>>
//│ > │ │ ┕ parsed: <tuple:<some:1 in let zero = 0 in one + zero in >;<none>>
//│ > │ ├ the result from sub-rule: <tuple:<some:1 in let zero = 0 in one + zero in >;<none>>
//│ > │ ├ the reserved expression: one
//│ > │ ┕ parsed: let one = 1 in let zero = 0 in one + zero in  in 
//│ > ┕ simple expression: let one = 1 in let zero = 0 in one + zero in  in 
//│ > LetLike:
//│ >   name = Keyword(let, 5, 5)
//│ >   lhs = Ident of "one"
//│ >   rhs = Some of Infix:
//│ >     op = Keyword(in, 3, 3)
//│ >     lhs = Literal#Integer of "1"
//│ >     rhs = LetLike:
//│ >       name = Keyword(let, 5, 5)
//│ >       lhs = Ident of "zero"
//│ >       rhs = Some of Infix:
//│ >         op = Keyword(in, 3, 3)
//│ >         lhs = Literal#Integer of "0"
//│ >         rhs = App:
//│ >           callee = Ident of "+"
//│ >           arguments = Stack of 
//│ >             Ident of "one"
//│ >             Ident of "zero"
//│ >       body = None
//│ >   body = None
