:js

import "../../mlscript-compile/apps/Lexer.mls"
import "../../mlscript-compile/apps/parsing/Precedence.mls"
import "../../mlscript-compile/apps/parsing/ParseRule.mls"
import "../../mlscript-compile/apps/parsing/Token.mls"
import "../../mlscript-compile/apps/parsing/Tree.mls"
import "../../mlscript-compile/apps/parsing/TokenHelpers.mls"
import "../../mlscript-compile/apps/parsing/TreeHelpers.mls"
import "../../mlscript-compile/apps/Parser.mls"
import "../../mlscript-compile/Iter.mls"
import "../../mlscript-compile/Option.mls"
import "../../mlscript-compile/Stack.mls"

open Token { LiteralKind }
open Parser { parse, tracer }
open Option { Some, None }
open Precedence { Keywords, opPrec, TypeKeywords }
open Stack
open TreeHelpers { showAsTree }

Keywords.maxPrec
//│ = 9

opPrec(";")
//│ = [2147483647, 2147483647]

opPrec("|>")
//│ = [12, 18]

opPrec("<:")
//│ = [18, 10]

opPrec("::")
//│ = [11, 10]

opPrec of "+"
//│ = [19, 19]

print of Keywords.all.values.join("\n")
//│ > Keyword(`;;`, 0, 0)
//│ > Keyword(`class`, N/A, 0)
//│ > Keyword(`begin`, N/A, 0)
//│ > Keyword(`end`, 0, N/A)
//│ > Keyword(`;`, 1, 0)
//│ > Keyword(`,`, 2, 1)
//│ > Keyword(`=`, 3, 3)
//│ > Keyword(`and`, N/A, 4)
//│ > Keyword(`|`, N/A, 4)
//│ > Keyword(`->`, 5, 3)
//│ > Keyword(`:`, 4, 3)
//│ > Keyword(`match`, 6, 6)
//│ > Keyword(`with`, N/A, 6)
//│ > Keyword(`case`, N/A, 6)
//│ > Keyword(`if`, 8, 7)
//│ > Keyword(`then`, 7, 7)
//│ > Keyword(`do`, 7, 7)
//│ > Keyword(`else`, 7, 7)
//│ > Keyword(`let`, 3, 1)
//│ > Keyword(`in`, 7, 7)
//│ > Keyword(`true`, N/A, N/A)
//│ > Keyword(`false`, N/A, N/A)
//│ > Keyword(`as`, 9, 9)
//│ > Keyword(`fun`, 9, N/A)
//│ > Keyword(`function`, 9, N/A)
//│ > Keyword(`type`, 9, N/A)
//│ > Keyword(`exception`, 9, N/A)
//│ > Keyword(`rec`, 9, 3)

print of TypeKeywords.all.values.join("\n")
//│ > Keyword(`type`, N/A, N/A)
//│ > Keyword(`exception`, N/A, N/A)
//│ > Keyword(`let`, N/A, N/A)
//│ > Keyword(`and`, N/A, N/A)
//│ > Keyword(`;`, 1, 0)
//│ > Keyword(`,`, 2, 2)
//│ > Keyword(`|`, 3, 3)
//│ > Keyword(``, 4, 4)
//│ > Keyword(`->`, 5, 4)
//│ > Keyword(`of`, 6, 6)
//│ > Keyword(`*`, 7, 7)
//│ > Keyword(`#`, 8, 8)
//│ > Keyword(`:`, 9, 9)
//│ > Keyword(`.`, 11, 11)

print of Parser.exprRules.display
//│ > <prefix rules for expressions> ::= `let` [`rec` ] 
//│ >   <expr> 
//│ >     `=` <expr> 
//│ >       `and` <expr> `=` <rec>
//│ >       `in` <expr> 
//│ >       
//│ > `fun` <expr> `->` <expr> 
//│ > `match` <expr> 
//│ >   `with` [`|` ] 
//│ >     <expr> 
//│ >       `->` <expr> 
//│ >         
//│ >         `|` <rec>
//│ > `function` [`|` ] 
//│ >   <expr> 
//│ >     `->` <expr> 
//│ >       
//│ >       `|` <rec>
//│ > `if` <expr> 
//│ >   `then` <expr> 
//│ >     `else` <expr> 
//│ >     

print of Parser.infixRules.display
//│ > <the continuation of expressions> ::= `|` <expr> 

pattern Flag = "tree" | "trace" | "tokens"

fun flags(tokens) =
  let result = new Set
  while tokens is
    Token.Space :: Token.Identifier(":", _) :: Token.Identifier(Flag as flag, _) :: tail then
      result.add(flag)
      set tokens = tail
    Token.Identifier(":", _) :: Token.Identifier(Flag as flag, _) :: tail then
      result.add(flag)
      set tokens = tail
    else [result, tokens]

fun example(...lines) =
  let
    source = lines.join("\n")
    tokens = Lexer.lex(source)
  if flags(tokens) is [flags, tokens] then ...
  if flags.has("tokens") do
    print of TokenHelpers.panorama(tokens)
  tracer.reset()
  set tracer.enabled = flags.has("trace")
  let trees = parse(tokens)
  set tracer.enabled = false
  if flags.has("tree") do
    print of trees
      Iter.fromStack()
      Iter.mapping of showAsTree
      Iter.joined of "\n"
  print of trees
    Iter.fromStack()
    Iter.mapping of Tree.summary
    Iter.joined of "\n"

example of "(x) => x"
//│ > «x => x»

example of "(1 + 2) * 3"
//│ > «(1 + 2) * 3»

example of "1 + 2 ** 5 * 4"
//│ > «1 + 2 ** 5 * 4»

example of "let zero = 0 in zero"
//│ > «let zero = 0 in zero»

example of """
let one = 1 in
let zero = 0 in
one + zero
"""
//│ > «let one = 1 in let zero = 0 in one + zero»

example of """
f x y
"""
//│ > «f(x)(y)»

example of """
let pi = 4.0 *. atan 1.0
"""
//│ > «let pi = 4.0 *. atan(1.0)»

example of "let square x = x *. x"
//│ > «let square(x) = x *. x»

example of "square (sin pi) +. square (cos pi)"
//│ > «square(sin(pi)) +. square(cos(pi))»

:todo
example of "(1 < 2) = false"
//│ ═══[RUNTIME ERROR] Error: Not implemented

example of "let cat s1 s2 = s1 ^ \" \" ^ s2"
//│ > «let cat(s1)(s2) = s1 ^ " " ^ s2»

example of "fun x -> x"
//│ > «fun x -> x»

example of """
let compose f g = fun x -> f (g x) in
  let cos2 = compose square cos
"""
//│ > «let compose(f)(g) = fun x -> f(g(x)) in let cos2 = compose(square)(cos) in {}»

:todo
example of "type sign = Positive | Negative"
//│ > «type sign = Positive | Negative»

example of "true"
//│ > «true»

example of """
match x with true -> 1 | false -> 0
"""
//│ > «match x with true -> 1 | false -> 0»

example of """
function (_, 0) -> "both zero"
"""
//│ > «function (_, 0) -> "both …"»

example of """
function (0, 0) -> "both zero"
       | (0, _) -> "first only zero"
       | (_, 0) -> "second only zero"
       | (_, _) -> "neither zero"
"""
//│ > «function (0, 0) -> "both …" | (0, _) -> "first…" | (_, 0) -> "secon…" | (_, _) -> "neith…"»

set tracer.enabled = false

example of "if f x then y else z"
//│ > «if f(x) then y then z»

example of "if f x then if g x then z else w else if h x then y else w"
//│ > «if f(x) then if g(x) then z then w then if h(x) then y then w»

example of "1, 2, 3"
//│ > «(1, 2, 3)»

example of "1; 2; 3"
//│ > «1; 2; 3»

example of """
1, 2; 3, 4; 5
"""
//│ > «(1, 2); (3, 4); 5»

// > The expressions `( expr )` and `begin expr end` have the same value as `expr`.
// > The two constructs are semantically equivalent, but it is good style to use
// > `begin … end` inside control structures.
example of """
begin
  print_string "hello";
  print_string "world"
end
"""
//│ > «print_string("hello"); print_string("world")»

// TODO: comment on this syntax design smell in the paper
example of """
if a == b then
  a
else
  b
"""
//│ > «if a == b then a then b»

example of """
let f a b =
  if a == b then
    print_endline "Equal"
  else begin
    print_string "Not Equal: ";
    print_int a;
    print_string " and ";
    print_int b;
    print_newline ()
  end
"""
//│ > «let f(a)(b) = if a == b then print_endline("Equal") then print_string("Not E…"); print_int(a); print_string(" and "); print_int(b); print_newline(())»

example of """
let foo = y; x
"""
//│ > «let foo = y; x»

example of """
let translate p dx dy =
    p.x <- p.x +. dx; p.y <- p.y +. dy
"""
//│ > «let translate(p)(dx)(dy) = (p.x <- p.x) +. dx; (p.y <- p.y) +. dy»

example of "()"
//│ > «()»

example of """
match x with | 0 -> 1
"""
//│ > «match x with 0 -> 1»

example of """
let fullname ?title first second =
  match title with
  | Some t -> t ^ " " ^ first ^ " " ^ second
  | None -> first ^ " " ^ second
"""
//│ > «let fullname ? title(first)(second) = match title with Some(t) -> t ^ " " ^ first ^ " " ^ second | None -> first ^ " " ^ second»

example of """
let a = if x then 1 else 0 in
let b = 0
"""
//│ > «let a = if x then 1 then 0 in let b = 0 in {}»

example of """
let rec factorial x =
  if x <= 1 then 1 else x * factorial (x - 1)
and sum l =
  match l with
  | [] -> 0
  | h :: t -> h + sum t
in
  factorial 5 + sum [1; 2; 3]
"""
//│ > «let factorial(x) = if x <= 1 then 1 then x * factorial(x - 1) and sum(l) = match l with [] -> 0 | h :: t -> h + sum(t) in factorial(5) + sum([1; 2; 3])»

example of "begin end"
//│ > «»

example of """
let v' =
    let a, b = (1, 2) in a + b
  in v'
"""
//│ > «let v' = let (a, b) = (1, 2) in a + b in v'»

example of """
let a = 0 and b = 1 in a + b
"""
//│ > «let a = 0 and b = 1 in a + b»

example of """
let rec even =
  function 0 -> true | n -> odd (n - 1)
and odd =
  function 0 -> false | n -> even (n - 1)
in
  even 1000
"""
//│ > «let even = function 0 -> true | n -> odd(n - 1) and odd = function 0 -> false | n -> even(n - 1) in even(1000)»

example of """
let rec even =
  function 0 -> true | n -> odd (n - 1)
and odd =
  function 0 -> false | n -> even (n - 1)
"""
//│ > «let even = function 0 -> true | n -> odd(n - 1) and odd = function 0 -> false | n -> even(n - 1)»

example of """
let a = 0
let b = 0
let f x = x + 1
let g x = f (f x)
"""
//│ > «let a = 0»
//│ > «let b = 0»
//│ > «let f(x) = x + 1»
//│ > «let g(x) = f(f(x))»

example of """
:tree
-2 * 3
;;
~2 * 3
"""
//│ > App:
//│ >   callee = Ident of "*"
//│ >   arguments = Stack of 
//│ >     App:
//│ >       callee = Ident of "-"
//│ >       arguments = Stack of 
//│ >         Literal#Integer of "2"
//│ >     Literal#Integer of "3"
//│ > App:
//│ >   callee = Ident of "*"
//│ >   arguments = Stack of 
//│ >     App:
//│ >       callee = Ident of "~"
//│ >       arguments = Stack of 
//│ >         Literal#Integer of "2"
//│ >     Literal#Integer of "3"
//│ > «(-(2)) * 3»
//│ > «~(2) * 3»

:todo
example of """
let f x = x
;;
1 + 2 * 3
"""
//│ > «let f(x) = x»
//│ > «1 + 2 * 3»

example of """
type a = b
type b = int * int
type f = int -> int
"""
//│ > «type a = b»
//│ > «type b = int * int»
//│ > «type f = int -> int»

example of """
:tree
type f = int * string -> float
type g = int * (string -> float)
"""
//│ > Define:
//│ >   kind = Type
//│ >   items = Stack of 
//│ >     Pair:
//│ >       first = Ident of "f"
//│ >       second = Infix:
//│ >         op = Keyword(`->`, 5, 4)
//│ >         lhs = Infix:
//│ >           op = Keyword(`*`, 7, 7)
//│ >           lhs = Ident of "int"
//│ >           rhs = Ident of "string"
//│ >         rhs = Ident of "float"
//│ > Define:
//│ >   kind = Type
//│ >   items = Stack of 
//│ >     Pair:
//│ >       first = Ident of "g"
//│ >       second = Infix:
//│ >         op = Keyword(`*`, 7, 7)
//│ >         lhs = Ident of "int"
//│ >         rhs = Infix:
//│ >           op = Keyword(`->`, 5, 4)
//│ >           lhs = Ident of "string"
//│ >           rhs = Ident of "float"
//│ > «type f = int * string -> float»
//│ > «type g = int * string -> float»

example of """
type 'a f = 'a * 'a
"""
//│ > «type f('a) = 'a * 'a»

example of """
type foo = Bar | Qux
let double n = n * 2
"""
//│ > «type foo = Bar | Qux»
//│ > «let double(n) = n * 2»

example of """
:tree
type foo = Bar of int | Qux of int * int
"""
//│ > Define:
//│ >   kind = Type
//│ >   items = Stack of 
//│ >     Pair:
//│ >       first = Ident of "foo"
//│ >       second = Infix:
//│ >         op = Keyword(`|`, 3, 3)
//│ >         lhs = Infix:
//│ >           op = Keyword(`of`, 6, 6)
//│ >           lhs = Ident of "Bar"
//│ >           rhs = Ident of "int"
//│ >         rhs = Infix:
//│ >           op = Keyword(`of`, 6, 6)
//│ >           lhs = Ident of "Qux"
//│ >           rhs = Infix:
//│ >             op = Keyword(`*`, 7, 7)
//│ >             lhs = Ident of "int"
//│ >             rhs = Ident of "int"
//│ > «type foo = Bar of int | Qux of int * int»

example of """
:tree
type 'a option = Some of 'a | None
"""
//│ > Define:
//│ >   kind = Type
//│ >   items = Stack of 
//│ >     Pair:
//│ >       first = App:
//│ >         callee = Ident of "option"
//│ >         arguments = Stack of 
//│ >           Ident of "'a"
//│ >       second = Infix:
//│ >         op = Keyword(`|`, 3, 3)
//│ >         lhs = Infix:
//│ >           op = Keyword(`of`, 6, 6)
//│ >           lhs = Ident of "Some"
//│ >           rhs = Ident of "'a"
//│ >         rhs = Ident of "None"
//│ > «type option('a) = Some of 'a | None»

example of """
:tree
type 'a tree = Leaf | Node of 'a tree * 'a * 'a tree
"""
//│ > Define:
//│ >   kind = Type
//│ >   items = Stack of 
//│ >     Pair:
//│ >       first = App:
//│ >         callee = Ident of "tree"
//│ >         arguments = Stack of 
//│ >           Ident of "'a"
//│ >       second = Infix:
//│ >         op = Keyword(`|`, 3, 3)
//│ >         lhs = Ident of "Leaf"
//│ >         rhs = Infix:
//│ >           op = Keyword(`of`, 6, 6)
//│ >           lhs = Ident of "Node"
//│ >           rhs = Infix:
//│ >             op = Keyword(`*`, 7, 7)
//│ >             lhs = Infix:
//│ >               op = Keyword(`*`, 7, 7)
//│ >               lhs = App:
//│ >                 callee = Ident of "tree"
//│ >                 arguments = Stack of 
//│ >                   Ident of "'a"
//│ >               rhs = Ident of "'a"
//│ >             rhs = App:
//│ >               callee = Ident of "tree"
//│ >               arguments = Stack of 
//│ >                 Ident of "'a"
//│ > «type tree('a) = Leaf | Node of tree('a) * 'a * tree('a)»

example of """
type ('a, 'b) twist = a list * b list
"""
//│ > «type twist(('a, 'b)) = list(a) * list(b)»

example of """
type empty = < >
type more = < .. >
"""
//│ > «type empty = <>»
//│ > «type more = <..>»

example of """
type test_type = < a : int >
type test_type = < a : int; b : string >
type test_type = < a : int; b : string; .. >
"""
//│ > «type test_type = <a : int>»
//│ > «type test_type = <a : int; b : string>»
//│ > «type test_type = <a : int; b : string; ..>»

:todo polymorphic type expressions
example of """
type tool = < cool : 'a . 'a wool >
"""
//│ > «type tool = <cool : wool('a . 'a)>»

example of """
type pv = [ `A | `B of int | `C of int * int ]
"""
//│ > «type pv = `A | `B of int | `C of int * int»

example of """
type qux = Qux of { q : int; u: int; x :int }
"""
//│ > «type qux = Qux of {q : int; u : int; x : int}»

example of """
type colour =
  | Red | Green | Blue | Yellow | Black | White
  | RGB of {r : int; g : int; b : int}
type 'a tree = Lf | Br of 'a * 'a tree * 'a;;
"""
//│ > «type colour = Red | Green | Blue | Yellow | Black | White | RGB of {r : int; g : int; b : int}»
//│ > «type tree('a) = Lf | Br of 'a * tree('a) * 'a»

example of """
:tree
type t = {decoration : string; substance : t'}
and t' = Int of int | List of t list
"""
//│ > Define:
//│ >   kind = Type
//│ >   items = Stack of 
//│ >     Pair:
//│ >       first = Ident of "t"
//│ >       second = Bracketed#Curly of Sequence of Stack of 
//│ >         Infix:
//│ >           op = Keyword(`:`, 9, 9)
//│ >           lhs = Ident of "decoration"
//│ >           rhs = Ident of "string"
//│ >         Infix:
//│ >           op = Keyword(`:`, 9, 9)
//│ >           lhs = Ident of "substance"
//│ >           rhs = Ident of "t'"
//│ >     Pair:
//│ >       first = Ident of "t'"
//│ >       second = Infix:
//│ >         op = Keyword(`|`, 3, 3)
//│ >         lhs = Infix:
//│ >           op = Keyword(`of`, 6, 6)
//│ >           lhs = Ident of "Int"
//│ >           rhs = Ident of "int"
//│ >         rhs = Infix:
//│ >           op = Keyword(`of`, 6, 6)
//│ >           lhs = Ident of "List"
//│ >           rhs = App:
//│ >             callee = Ident of "list"
//│ >             arguments = Stack of 
//│ >               Ident of "t"
//│ > «type t = {decoration : string; substance : t'} and t' = Int of int | List of list(t)»

example of """
:tree
exception E of int * string
"""
//│ > Define:
//│ >   kind = Exception
//│ >   items = Stack of 
//│ >     Pair:
//│ >       first = Infix:
//│ >         op = Keyword(`of`, 6, 6)
//│ >         lhs = Ident of "E"
//│ >         rhs = Infix:
//│ >           op = Keyword(`*`, 7, 7)
//│ >           lhs = Ident of "int"
//│ >           rhs = Ident of "string"
//│ >       second = Empty
//│ > «exception E of int * string = {}»

example of """
type 'a bst = E | N of 'a * 'a bst * 'a bst
let rec insert x = function
  | E -> N (x, E, E)
  | N (y, l, r) ->
      if x < y then N (y, insert x l, r)
      else N (y, l, insert x r)
let rec min_elt = function
  | E -> failwith "min_elt called on empty tree"
  | N (x, E, _) -> x
  | N (_, l, _) -> min_elt l
let rec remove x = function
  | E -> E
  | N (y, l, r) ->
      if x < y then N (y, remove x l, r)
      else if x > y then N (y, l, remove x r)
      else
        match (l, r) with
        | (E, _) -> r
        | (_, E) -> l
        | _ ->
            let m = min_elt r in
            N (m, l, remove m r)
"""
//│ > «type bst('a) = E | N of 'a * bst('a) * bst('a)»
//│ > «let insert(x) = function E -> N((x, E, E)) | N((y, l, r)) -> if x < y then N((y, insert(x)(l), r)) then N((y, l, insert(x)(r)))»
//│ > «let min_elt = function E -> failwith("min_e…") | N((x, E, _)) -> x | N((_, l, _)) -> min_elt(l)»
//│ > «let remove(x) = function E -> E | N((y, l, r)) -> if x < y then N((y, remove(x)(l), r)) then if x > y then N((y, l, remove(x)(r))) then match (l, r) with (E, _) -> r | (_, E) -> l | _ -> let m = min_elt(r) in N((m, l, remove(m)(r)))»


// TODO add tests for
// f expr .( expr ) <- expr
// f (expr .( expr ) <- expr)


