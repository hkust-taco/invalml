:js

import "../../../mlscript-compile/apps/parsing/Lexer.mls"
import "../../../mlscript-compile/apps/parsing/Token.mls"
import "../../../mlscript-compile/Stack.mls"
import "../../../mlscript-compile/Iter.mls"

fun lines(...strs) = strs.join("\n")

open Lexer { lex }
open Stack

fun printLexed(text) = print of
  lex(text, false)
    Iter.fromStack()
    Iter.mapping of Token.display
    Iter.joined of "\n"

printLexed of "0 1  0xDEADCAFE 0b1101 0o755     3.1415926535"
//â”‚ > integer "0" at 1:1-1:2
//â”‚ > space at 1:2-1:3
//â”‚ > integer "1" at 1:3-1:4
//â”‚ > space at 1:4-1:6
//â”‚ > integer "0xDEADCAFE" at 1:1-1:7
//â”‚ > space at 1:16-1:17
//â”‚ > integer "0b1101" at 1:12-1:18
//â”‚ > space at 1:23-1:24
//â”‚ > integer "0o755" at 1:20-1:25
//â”‚ > space at 1:29-1:34
//â”‚ > decimal "3.1415926535" at 1:23-1:35

// Good strings.
printLexed of """
"hello, world"
"\x48\x65\x6C\x6C\x6F\x2C\x20\x77\x6F\x72\x6C\x64"
"\u0048\u0065\u006C\u006C\u006F\u002C\u0020\u0077\u006F\u0072\u006C\u0064"
"\u{48}\u{65}\u{6C}\u{6C}\u{6F}\u{2C}\u{20}\u{77}\u{6F}\u{72}\u{6C}\u{64}"
"\u{1F600}" // ðŸ˜€
"\u{1F601}" // ðŸ˜
"\u{1F602}" // ðŸ˜‚
"\u{1F603}" // ðŸ˜ƒ
"\u{1F604}" // ðŸ˜„
"\n\r\t\b"
"""
//â”‚ > space at 1:1-2:1
//â”‚ > string "hello, world" at 2:2-2:15
//â”‚ > space at 2:15-3:1
//â”‚ > string "Hello, world" at 3:2-3:51
//â”‚ > space at 3:51-4:1
//â”‚ > string "Hello, world" at 4:2-4:75
//â”‚ > space at 4:75-5:1
//â”‚ > string "Hello, world" at 5:2-5:75
//â”‚ > space at 5:75-6:1
//â”‚ > string "ðŸ˜€" at 6:2-6:12
//â”‚ > space at 6:12-6:13
//â”‚ > comment at 6:14-6:18
//â”‚ > space at 6:18-7:1
//â”‚ > string "ðŸ˜" at 7:2-7:12
//â”‚ > space at 7:12-7:13
//â”‚ > comment at 7:14-7:18
//â”‚ > space at 7:18-8:1
//â”‚ > string "ðŸ˜‚" at 8:2-8:12
//â”‚ > space at 8:12-8:13
//â”‚ > comment at 8:14-8:18
//â”‚ > space at 8:18-9:1
//â”‚ > string "ðŸ˜ƒ" at 9:2-9:12
//â”‚ > space at 9:12-9:13
//â”‚ > comment at 9:14-9:18
//â”‚ > space at 9:18-10:1
//â”‚ > string "ðŸ˜„" at 10:2-10:12
//â”‚ > space at 10:12-10:13
//â”‚ > comment at 10:14-10:18
//â”‚ > space at 10:18-11:1
//â”‚ > string "\n\r\t\b" at 11:2-11:11
//â”‚ > space at 11:11-12:1

// Ill-formed Strings
// ==================

printLexed of """
"hello, world.   """
//â”‚ > space at 1:1-2:1
//â”‚ > string "hello, world.   " at 2:2-2:18

printLexed of """
"hello, \world"""
//â”‚ > space at 1:1-2:1
//â”‚ > string "hello, world" at 2:2-2:15

printLexed of """let v' =
  let a, b = (1, 2) in a + b"""
//â”‚ > identifier `let` at 1:1-1:4
//â”‚ > space at 1:4-1:5
//â”‚ > identifier `v'` at 1:5-1:7
//â”‚ > space at 1:7-1:8
//â”‚ > identifier `=` at 1:8-1:9
//â”‚ > space at 1:9-2:3
//â”‚ > identifier `let` at 2:3-2:6
//â”‚ > space at 2:6-2:7
//â”‚ > identifier `a` at 2:7-2:8
//â”‚ > identifier `,` at 2:8-2:9
//â”‚ > space at 2:9-2:10
//â”‚ > identifier `b` at 2:10-2:11
//â”‚ > space at 2:11-2:12
//â”‚ > identifier `=` at 2:12-2:13
//â”‚ > space at 2:13-2:14
//â”‚ > identifier `(` at 2:13-2:14
//â”‚ > integer "1" at 2:15-2:16
//â”‚ > identifier `,` at 2:16-2:17
//â”‚ > space at 2:17-2:18
//â”‚ > integer "2" at 2:18-2:19
//â”‚ > identifier `)` at 2:18-2:19
//â”‚ > space at 2:20-2:21
//â”‚ > identifier `in` at 2:21-2:23
//â”‚ > space at 2:23-2:24
//â”‚ > identifier `a` at 2:24-2:25
//â”‚ > space at 2:25-2:26
//â”‚ > identifier `+` at 2:26-2:27
//â”‚ > space at 2:27-2:28
//â”‚ > identifier `b` at 2:28-2:29

printLexed of lines of
  "let rec factorial x = // a simple factorial function"
  "  if x <= 1 then 1 else x * factorial (x - 1)"
  ""
  "let bool_of_string = function"
  "  | \"true\" -> true"
  "  | \"false\" -> false"
  "  | _ -> raise (Invalid_argument \"bool_of_string\")"
//â”‚ > identifier `let` at 1:1-1:4
//â”‚ > space at 1:4-1:5
//â”‚ > identifier `rec` at 1:5-1:8
//â”‚ > space at 1:8-1:9
//â”‚ > identifier `factorial` at 1:9-1:18
//â”‚ > space at 1:18-1:19
//â”‚ > identifier `x` at 1:19-1:20
//â”‚ > space at 1:20-1:21
//â”‚ > identifier `=` at 1:21-1:22
//â”‚ > space at 1:22-1:23
//â”‚ > comment at 1:24-1:53
//â”‚ > space at 1:53-2:3
//â”‚ > identifier `if` at 2:3-2:5
//â”‚ > space at 2:5-2:6
//â”‚ > identifier `x` at 2:6-2:7
//â”‚ > space at 2:7-2:8
//â”‚ > identifier `<=` at 2:8-2:10
//â”‚ > space at 2:10-2:11
//â”‚ > integer "1" at 2:11-2:12
//â”‚ > space at 2:12-2:13
//â”‚ > identifier `then` at 2:13-2:17
//â”‚ > space at 2:17-2:18
//â”‚ > integer "1" at 2:18-2:19
//â”‚ > space at 2:19-2:20
//â”‚ > identifier `else` at 2:20-2:24
//â”‚ > space at 2:24-2:25
//â”‚ > identifier `x` at 2:25-2:26
//â”‚ > space at 2:26-2:27
//â”‚ > identifier `*` at 2:27-2:28
//â”‚ > space at 2:28-2:29
//â”‚ > identifier `factorial` at 2:29-2:38
//â”‚ > space at 2:38-2:39
//â”‚ > identifier `(` at 2:38-2:39
//â”‚ > identifier `x` at 2:40-2:41
//â”‚ > space at 2:41-2:42
//â”‚ > identifier `-` at 2:42-2:43
//â”‚ > space at 2:43-2:44
//â”‚ > integer "1" at 2:44-2:45
//â”‚ > identifier `)` at 2:44-2:45
//â”‚ > space at 2:46-4:1
//â”‚ > identifier `let` at 4:1-4:4
//â”‚ > space at 4:4-4:5
//â”‚ > identifier `bool_of_string` at 4:5-4:19
//â”‚ > space at 4:19-4:20
//â”‚ > identifier `=` at 4:20-4:21
//â”‚ > space at 4:21-4:22
//â”‚ > identifier `function` at 4:22-4:30
//â”‚ > space at 4:30-5:3
//â”‚ > identifier `|` at 5:3-5:4
//â”‚ > space at 5:4-5:5
//â”‚ > string "true" at 5:6-5:11
//â”‚ > space at 5:11-5:12
//â”‚ > identifier `->` at 5:12-5:14
//â”‚ > space at 5:14-5:15
//â”‚ > boolean "true" at 5:15-5:19
//â”‚ > space at 5:19-6:3
//â”‚ > identifier `|` at 6:3-6:4
//â”‚ > space at 6:4-6:5
//â”‚ > string "false" at 6:6-6:12
//â”‚ > space at 6:12-6:13
//â”‚ > identifier `->` at 6:13-6:15
//â”‚ > space at 6:15-6:16
//â”‚ > boolean "false" at 6:16-6:21
//â”‚ > space at 6:21-7:3
//â”‚ > identifier `|` at 7:3-7:4
//â”‚ > space at 7:4-7:5
//â”‚ > identifier `_` at 7:5-7:6
//â”‚ > space at 7:6-7:7
//â”‚ > identifier `->` at 7:7-7:9
//â”‚ > space at 7:9-7:10
//â”‚ > identifier `raise` at 7:10-7:15
//â”‚ > space at 7:15-7:16
//â”‚ > identifier `(` at 7:15-7:16
//â”‚ > identifier `Invalid_argument` at 7:17-7:33
//â”‚ > space at 7:33-7:34
//â”‚ > string "bool_of_string" at 7:35-7:50
//â”‚ > identifier `)` at 7:49-7:50

// It turns out that OCaml identifiers' apostrophes are not limited to the end.
printLexed of "a'b"
printLexed of "'a"
//â”‚ > identifier `a'b` at 1:1-1:4
//â”‚ > identifier `'a` at 1:1-1:1

printLexed of "[< ] < .. ... >"
//â”‚ > identifier `[` at 1:1-1:1
//â”‚ > identifier `<` at 1:2-1:3
//â”‚ > space at 1:3-1:4
//â”‚ > identifier `]` at 1:3-1:4
//â”‚ > space at 1:5-1:6
//â”‚ > identifier `<` at 1:6-1:7
//â”‚ > space at 1:7-1:8
//â”‚ > identifier `..` at 1:8-1:10
//â”‚ > space at 1:10-1:11
//â”‚ > identifier `...` at 1:11-1:14
//â”‚ > space at 1:14-1:15
//â”‚ > identifier `>` at 1:15-1:16

printLexed of "`a `b _"
//â”‚ > identifier ``a` at 1:1-1:1
//â”‚ > space at 1:3-1:4
//â”‚ > identifier ``b` at 1:2-1:4
//â”‚ > space at 1:6-1:7
//â”‚ > identifier `_` at 1:7-1:8

:e
// It would be decent if we allow pattern parameters in functions.
fun take(pattern P, idx: Str, acc: Str) =
  while idx < str.length and str.charAt(idx) is ch and ch is P
    then
      set idx = idx + 1
      set acc = acc + ch
    else [acc, idx]
//â”‚ â•”â•â•[ERROR] Name not found: str
//â”‚ â•‘  l.238: 	  while idx < str.length and str.charAt(idx) is ch and ch is P
//â”‚ â•™â”€â”€       	              ^^^
//â”‚ â•”â•â•[ERROR] Name not found: str
//â”‚ â•‘  l.238: 	  while idx < str.length and str.charAt(idx) is ch and ch is P
//â”‚ â•™â”€â”€       	                             ^^^
//â”‚ â•”â•â•[ERROR] Cannot use this reference as a pattern
//â”‚ â•‘  l.238: 	  while idx < str.length and str.charAt(idx) is ch and ch is P
//â”‚ â•™â”€â”€       	                                                             ^

