:js

import "../../../mlscript-compile/apps/parsing/Lexer.mls"
import "../../../mlscript-compile/apps/parsing/Token.mls"
import "../../../mlscript-compile/Stack.mls"
import "../../../mlscript-compile/Iter.mls"

fun lines(...strs) = strs.join("\n")

open Lexer { lex }
open Stack

fun printLexed(text) = print of
  lex(text, false)
    Iter.fromStack()
    Iter.mapping of Token.display
    Iter.joined of "\n"

printLexed of "0 1  0xDEADCAFE 0b1101 0o755     3.1415926535"
//│ > integer "0" at 1:1-1:2
//│ > space at 1:2-1:3
//│ > integer "1" at 1:3-1:4
//│ > space at 1:4-1:6
//│ > integer "0xDEADCAFE" at 1:1-1:7
//│ > space at 1:16-1:17
//│ > integer "0b1101" at 1:12-1:18
//│ > space at 1:23-1:24
//│ > integer "0o755" at 1:20-1:25
//│ > space at 1:29-1:34
//│ > decimal "3.1415926535" at 1:23-1:35

// Good strings.
printLexed of """
"hello, world"
"\x48\x65\x6C\x6C\x6F\x2C\x20\x77\x6F\x72\x6C\x64"
"\u0048\u0065\u006C\u006C\u006F\u002C\u0020\u0077\u006F\u0072\u006C\u0064"
"\u{48}\u{65}\u{6C}\u{6C}\u{6F}\u{2C}\u{20}\u{77}\u{6F}\u{72}\u{6C}\u{64}"
"\u{1F600}" // 😀
"\u{1F601}" // 😁
"\u{1F602}" // 😂
"\u{1F603}" // 😃
"\u{1F604}" // 😄
"\n\r\t\b"
"""
//│ > space at 1:1-2:1
//│ > string "hello, world" at 2:2-2:15
//│ > space at 2:15-3:1
//│ > string "Hello, world" at 3:2-3:51
//│ > space at 3:51-4:1
//│ > string "Hello, world" at 4:2-4:75
//│ > space at 4:75-5:1
//│ > string "Hello, world" at 5:2-5:75
//│ > space at 5:75-6:1
//│ > string "😀" at 6:2-6:12
//│ > space at 6:12-6:13
//│ > comment at 6:14-6:18
//│ > space at 6:18-7:1
//│ > string "😁" at 7:2-7:12
//│ > space at 7:12-7:13
//│ > comment at 7:14-7:18
//│ > space at 7:18-8:1
//│ > string "😂" at 8:2-8:12
//│ > space at 8:12-8:13
//│ > comment at 8:14-8:18
//│ > space at 8:18-9:1
//│ > string "😃" at 9:2-9:12
//│ > space at 9:12-9:13
//│ > comment at 9:14-9:18
//│ > space at 9:18-10:1
//│ > string "😄" at 10:2-10:12
//│ > space at 10:12-10:13
//│ > comment at 10:14-10:18
//│ > space at 10:18-11:1
//│ > string "\n\r\t\b" at 11:2-11:11
//│ > space at 11:11-12:1

// Ill-formed Strings
// ==================

printLexed of """
"hello, world.   """
//│ > space at 1:1-2:1
//│ > string "hello, world.   " at 2:2-2:18

printLexed of """
"hello, \world"""
//│ > space at 1:1-2:1
//│ > string "hello, world" at 2:2-2:15

printLexed of """let v' =
  let a, b = (1, 2) in a + b"""
//│ > identifier `let` at 1:1-1:4
//│ > space at 1:4-1:5
//│ > identifier `v'` at 1:5-1:7
//│ > space at 1:7-1:8
//│ > identifier `=` at 1:8-1:9
//│ > space at 1:9-2:3
//│ > identifier `let` at 2:3-2:6
//│ > space at 2:6-2:7
//│ > identifier `a` at 2:7-2:8
//│ > identifier `,` at 2:8-2:9
//│ > space at 2:9-2:10
//│ > identifier `b` at 2:10-2:11
//│ > space at 2:11-2:12
//│ > identifier `=` at 2:12-2:13
//│ > space at 2:13-2:14
//│ > identifier `(` at 2:13-2:14
//│ > integer "1" at 2:15-2:16
//│ > identifier `,` at 2:16-2:17
//│ > space at 2:17-2:18
//│ > integer "2" at 2:18-2:19
//│ > identifier `)` at 2:18-2:19
//│ > space at 2:20-2:21
//│ > identifier `in` at 2:21-2:23
//│ > space at 2:23-2:24
//│ > identifier `a` at 2:24-2:25
//│ > space at 2:25-2:26
//│ > identifier `+` at 2:26-2:27
//│ > space at 2:27-2:28
//│ > identifier `b` at 2:28-2:29

printLexed of lines of
  "let rec factorial x = // a simple factorial function"
  "  if x <= 1 then 1 else x * factorial (x - 1)"
  ""
  "let bool_of_string = function"
  "  | \"true\" -> true"
  "  | \"false\" -> false"
  "  | _ -> raise (Invalid_argument \"bool_of_string\")"
//│ > identifier `let` at 1:1-1:4
//│ > space at 1:4-1:5
//│ > identifier `rec` at 1:5-1:8
//│ > space at 1:8-1:9
//│ > identifier `factorial` at 1:9-1:18
//│ > space at 1:18-1:19
//│ > identifier `x` at 1:19-1:20
//│ > space at 1:20-1:21
//│ > identifier `=` at 1:21-1:22
//│ > space at 1:22-1:23
//│ > comment at 1:24-1:53
//│ > space at 1:53-2:3
//│ > identifier `if` at 2:3-2:5
//│ > space at 2:5-2:6
//│ > identifier `x` at 2:6-2:7
//│ > space at 2:7-2:8
//│ > identifier `<=` at 2:8-2:10
//│ > space at 2:10-2:11
//│ > integer "1" at 2:11-2:12
//│ > space at 2:12-2:13
//│ > identifier `then` at 2:13-2:17
//│ > space at 2:17-2:18
//│ > integer "1" at 2:18-2:19
//│ > space at 2:19-2:20
//│ > identifier `else` at 2:20-2:24
//│ > space at 2:24-2:25
//│ > identifier `x` at 2:25-2:26
//│ > space at 2:26-2:27
//│ > identifier `*` at 2:27-2:28
//│ > space at 2:28-2:29
//│ > identifier `factorial` at 2:29-2:38
//│ > space at 2:38-2:39
//│ > identifier `(` at 2:38-2:39
//│ > identifier `x` at 2:40-2:41
//│ > space at 2:41-2:42
//│ > identifier `-` at 2:42-2:43
//│ > space at 2:43-2:44
//│ > integer "1" at 2:44-2:45
//│ > identifier `)` at 2:44-2:45
//│ > space at 2:46-4:1
//│ > identifier `let` at 4:1-4:4
//│ > space at 4:4-4:5
//│ > identifier `bool_of_string` at 4:5-4:19
//│ > space at 4:19-4:20
//│ > identifier `=` at 4:20-4:21
//│ > space at 4:21-4:22
//│ > identifier `function` at 4:22-4:30
//│ > space at 4:30-5:3
//│ > identifier `|` at 5:3-5:4
//│ > space at 5:4-5:5
//│ > string "true" at 5:6-5:11
//│ > space at 5:11-5:12
//│ > identifier `->` at 5:12-5:14
//│ > space at 5:14-5:15
//│ > boolean "true" at 5:15-5:19
//│ > space at 5:19-6:3
//│ > identifier `|` at 6:3-6:4
//│ > space at 6:4-6:5
//│ > string "false" at 6:6-6:12
//│ > space at 6:12-6:13
//│ > identifier `->` at 6:13-6:15
//│ > space at 6:15-6:16
//│ > boolean "false" at 6:16-6:21
//│ > space at 6:21-7:3
//│ > identifier `|` at 7:3-7:4
//│ > space at 7:4-7:5
//│ > identifier `_` at 7:5-7:6
//│ > space at 7:6-7:7
//│ > identifier `->` at 7:7-7:9
//│ > space at 7:9-7:10
//│ > identifier `raise` at 7:10-7:15
//│ > space at 7:15-7:16
//│ > identifier `(` at 7:15-7:16
//│ > identifier `Invalid_argument` at 7:17-7:33
//│ > space at 7:33-7:34
//│ > string "bool_of_string" at 7:35-7:50
//│ > identifier `)` at 7:49-7:50

// It turns out that OCaml identifiers' apostrophes are not limited to the end.
printLexed of "a'b"
printLexed of "'a"
//│ > identifier `a'b` at 1:1-1:4
//│ > identifier `'a` at 1:1-1:1

printLexed of "[< ] < .. ... >"
//│ > identifier `[` at 1:1-1:1
//│ > identifier `<` at 1:2-1:3
//│ > space at 1:3-1:4
//│ > identifier `]` at 1:3-1:4
//│ > space at 1:5-1:6
//│ > identifier `<` at 1:6-1:7
//│ > space at 1:7-1:8
//│ > identifier `..` at 1:8-1:10
//│ > space at 1:10-1:11
//│ > identifier `...` at 1:11-1:14
//│ > space at 1:14-1:15
//│ > identifier `>` at 1:15-1:16

printLexed of "`a `b _"
//│ > identifier ``a` at 1:1-1:1
//│ > space at 1:3-1:4
//│ > identifier ``b` at 1:2-1:4
//│ > space at 1:6-1:7
//│ > identifier `_` at 1:7-1:8

:e
// It would be decent if we allow pattern parameters in functions.
fun take(pattern P, idx: Str, acc: Str) =
  while idx < str.length and str.charAt(idx) is ch and ch is P
    then
      set idx = idx + 1
      set acc = acc + ch
    else [acc, idx]
//│ ╔══[ERROR] Name not found: str
//│ ║  l.238: 	  while idx < str.length and str.charAt(idx) is ch and ch is P
//│ ╙──       	              ^^^
//│ ╔══[ERROR] Name not found: str
//│ ║  l.238: 	  while idx < str.length and str.charAt(idx) is ch and ch is P
//│ ╙──       	                             ^^^
//│ ╔══[ERROR] Cannot use this reference as a pattern
//│ ║  l.238: 	  while idx < str.length and str.charAt(idx) is ch and ch is P
//│ ╙──       	                                                             ^

