

fun foo: Any -> Bool
fun (|>) pipe(x, f) = f(x)
fun abs(x) = if x < 0 then -x else x

:pt
:sjs
fun sign(x) = if x
  < 0 then -1
  > 0 then 1
  else 0
//│ Parsed tree:
//│ TermDef:
//│   k = Fun
//│   head = App:
//│     lhs = Ident of "sign"
//│     rhs = Tup of Ls of 
//│       Ident of "x"
//│   rhs = S of IfLike:
//│     kw = keyword 'if'
//│     kwLoc = N
//│     split = OpSplit:
//│       lhs = Ident of "x"
//│       ops_rhss = Ls of 
//│         InfixApp:
//│           lhs = OpApp:
//│             lhs = SplitPoint
//│             op = Ident of "<"
//│             rhss = Ls of 
//│               IntLit of 0
//│           kw = keyword 'then'
//│           rhs = App:
//│             lhs = Ident of "-"
//│             rhs = Tup of Ls of 
//│               IntLit of 1
//│         InfixApp:
//│           lhs = OpApp:
//│             lhs = SplitPoint
//│             op = Ident of ">"
//│             rhss = Ls of 
//│               IntLit of 0
//│           kw = keyword 'then'
//│           rhs = IntLit of 1
//│         Modified:
//│           modifier = keyword 'else'
//│           modLoc = N
//│           body = IntLit of 0
//│ JS (unsanitized):
//│ let sign;
//│ sign = function sign(x) {
//│   let scrut, scrut1;
//│   scrut1 = x < 0;
//│   if (scrut1 === true) {
//│     return - 1
//│   } else {
//│     scrut = x > 0;
//│     if (scrut === true) {
//│       return 1
//│     } else {
//│       return 0
//│     }
//│   }
//│ };

:pt
:elt
fun example(args) =
  if foo(args)
    < 0 then "invalid"
    == 0 then "null"
    |> abs
      > 100 then "large"
      < 10 then "small"
      else "medium"
//│ Parsed tree:
//│ TermDef:
//│   k = Fun
//│   head = App:
//│     lhs = Ident of "example"
//│     rhs = Tup of Ls of 
//│       Ident of "args"
//│   rhs = S of Block of Ls of 
//│     IfLike:
//│       kw = keyword 'if'
//│       kwLoc = N
//│       split = OpSplit:
//│         lhs = App:
//│           lhs = Ident of "foo"
//│           rhs = Tup of Ls of 
//│             Ident of "args"
//│         ops_rhss = Ls of 
//│           InfixApp:
//│             lhs = OpApp:
//│               lhs = SplitPoint
//│               op = Ident of "<"
//│               rhss = Ls of 
//│                 IntLit of 0
//│             kw = keyword 'then'
//│             rhs = StrLit of "invalid"
//│           InfixApp:
//│             lhs = OpApp:
//│               lhs = SplitPoint
//│               op = Ident of "=="
//│               rhss = Ls of 
//│                 IntLit of 0
//│             kw = keyword 'then'
//│             rhs = StrLit of "null"
//│           OpSplit:
//│             lhs = OpApp:
//│               lhs = SplitPoint
//│               op = Ident of "|>"
//│               rhss = Ls of 
//│                 Ident of "abs"
//│             ops_rhss = Ls of 
//│               InfixApp:
//│                 lhs = OpApp:
//│                   lhs = SplitPoint
//│                   op = Ident of ">"
//│                   rhss = Ls of 
//│                     IntLit of 100
//│                 kw = keyword 'then'
//│                 rhs = StrLit of "large"
//│               InfixApp:
//│                 lhs = OpApp:
//│                   lhs = SplitPoint
//│                   op = Ident of "<"
//│                   rhss = Ls of 
//│                     IntLit of 10
//│                 kw = keyword 'then'
//│                 rhs = StrLit of "small"
//│               Modified:
//│                 modifier = keyword 'else'
//│                 modLoc = N
//│                 body = StrLit of "medium"
//│ Elaborated tree:
//│ Blk:
//│   stats = Ls of 
//│     TermDefinition:
//│       owner = N
//│       k = Fun
//│       sym = member:example
//│       params = Ls of 
//│         ParamList:
//│           flags = ()
//│           params = Ls of 
//│             Param:
//│               flags = ()
//│               sym = args
//│               sign = N
//│               modulefulness = Modulefulness of N
//│           restParam = N
//│       tparams = N
//│       sign = N
//│       body = S of IfLike:
//│         kw = keyword 'if'
//│         desugared = Let:
//│           sym = $scrut
//│           term = App:
//│             lhs = Ref:
//│               sym = member:foo
//│               iargsLs = N
//│             rhs = Tup of Ls of 
//│               Fld:
//│                 flags = ()
//│                 term = Ref:
//│                   sym = args
//│                   iargsLs = N
//│                 asc = N
//│             iargsLs = N
//│           tail = Let: \
//│           sym = $scrut
//│           term = App:
//│             lhs = Ref:
//│               sym = builtin:<
//│               iargsLs = N
//│             rhs = Tup of Ls of 
//│               Fld:
//│                 flags = ()
//│                 term = Ref:
//│                   sym = $scrut
//│                   iargsLs = N
//│                 asc = N
//│               Fld:
//│                 flags = ()
//│                 term = Lit of IntLit of 0
//│                 asc = N
//│             iargsLs = N
//│           tail = Cons: \
//│           head = Branch:
//│             scrutinee = Ref:
//│               sym = $scrut
//│               iargsLs = N
//│             pattern = Lit of BoolLit of true
//│             continuation = Else of Lit of StrLit of "invalid"
//│           tail = Let: \
//│           sym = $scrut
//│           term = App:
//│             lhs = Ref:
//│               sym = builtin:==
//│               iargsLs = N
//│             rhs = Tup of Ls of 
//│               Fld:
//│                 flags = ()
//│                 term = Ref:
//│                   sym = $scrut
//│                   iargsLs = N
//│                 asc = N
//│               Fld:
//│                 flags = ()
//│                 term = Lit of IntLit of 0
//│                 asc = N
//│             iargsLs = N
//│           tail = Cons: \
//│           head = Branch:
//│             scrutinee = Ref:
//│               sym = $scrut
//│               iargsLs = N
//│             pattern = Lit of BoolLit of true
//│             continuation = Else of Lit of StrLit of "null"
//│           tail = Let: \
//│           sym = $scrut
//│           term = App:
//│             lhs = Ref:
//│               sym = member:pipe
//│               iargsLs = N
//│             rhs = Tup of Ls of 
//│               Fld:
//│                 flags = ()
//│                 term = Ref:
//│                   sym = $scrut
//│                   iargsLs = N
//│                 asc = N
//│               Fld:
//│                 flags = ()
//│                 term = Ref:
//│                   sym = member:abs
//│                   iargsLs = N
//│                 asc = N
//│             iargsLs = N
//│           tail = Let: \
//│           sym = $scrut
//│           term = App:
//│             lhs = Ref:
//│               sym = builtin:>
//│               iargsLs = N
//│             rhs = Tup of Ls of 
//│               Fld:
//│                 flags = ()
//│                 term = Ref:
//│                   sym = $scrut
//│                   iargsLs = N
//│                 asc = N
//│               Fld:
//│                 flags = ()
//│                 term = Lit of IntLit of 100
//│                 asc = N
//│             iargsLs = N
//│           tail = Cons: \
//│           head = Branch:
//│             scrutinee = Ref:
//│               sym = $scrut
//│               iargsLs = N
//│             pattern = Lit of BoolLit of true
//│             continuation = Else of Lit of StrLit of "large"
//│           tail = Let: \
//│           sym = $scrut
//│           term = App:
//│             lhs = Ref:
//│               sym = builtin:<
//│               iargsLs = N
//│             rhs = Tup of Ls of 
//│               Fld:
//│                 flags = ()
//│                 term = Ref:
//│                   sym = $scrut
//│                   iargsLs = N
//│                 asc = N
//│               Fld:
//│                 flags = ()
//│                 term = Lit of IntLit of 10
//│                 asc = N
//│             iargsLs = N
//│           tail = Cons: \
//│           head = Branch:
//│             scrutinee = Ref:
//│               sym = $scrut
//│               iargsLs = N
//│             pattern = Lit of BoolLit of true
//│             continuation = Else of Lit of StrLit of "small"
//│           tail = Else of Lit of StrLit of "medium"
//│       resSym = ‹result of member:example›
//│       flags = ()
//│       modulefulness = Modulefulness of N
//│       annotations = Nil
//│   res = Lit of UnitLit of false


