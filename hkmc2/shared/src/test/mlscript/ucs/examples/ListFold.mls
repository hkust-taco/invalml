:js

import "../../../mlscript-compile/Stack.mls"
import "../../../mlscript-compile/Option.mls"
import "../../../mlscript-compile/Str.mls"

open Stack
open Option
open Str

fun (|>) pipe(x, f) = f(x)

fun findFirst(f, xs) =
  if xs is
    Nil then None
    Cons(x, _) and f(x) then Some(x)
    Cons(_, xs) then findFirst(f, xs)

fun (::) cons(head, tail) = Cons(head, tail)

let oneTwoThree = 1 :: 2 :: 3 :: Nil
//│ oneTwoThree = Cons(1, Cons(2, Cons(3, Nil)))

// Note that JavaScript doesn't have tail call optimization. Therefore, this
// implementation is still inefficient in practice.
fun join(sep) =
  fun aux(acc, xs) =
    if xs is
      Nil then acc
      Cons(x, xs') then aux(acc ~ sep ~ Str.from(x), xs')
  (xs) =>
    if xs is
      Cons(x, xs') then aux(Str.from(x), xs')
      Nil then ""

join(", ")(1 :: 2 :: 3 :: Nil)
(1 :: 2 :: 3 :: Nil) |> join(", ")
//│ = "1, 2, 3"

fun showList(xs) = "[" ~ join(", ")(xs) ~ "]"

fun (:::) appendAll(xs, ys) =
  if xs is
    Nil then ys
    Cons(x, xs') then x :: (xs' ::: ys)

((1 :: 2 :: 3 :: Nil) ::: (4 :: 5 :: 6 :: Nil)) |> showList
//│ = "[1, 2, 3, 4, 5, 6]"

fun reverse(xs) =
  fun aux(acc, xs) =
    if xs is
      Nil then acc
      Cons(x, xs') then aux(x :: acc, xs')
  aux(Nil, xs)

(1 :: 2 :: 3 :: Nil) |> showList
reverse(1 :: 2 :: 3 :: Nil) |> showList
//│ = "[3, 2, 1]"

//   __       _     _ _          __ _
//  / _| ___ | | __| | |    ___ / _| |_
// | |_ / _ \| |/ _` | |   / _ \ |_| __|
// |  _| (_) | | (_| | |__|  __/  _| |_
// |_|  \___/|_|\__,_|_____\___|_|  \__|
//

fun foldLeft(f)(z) =
  fun aux(acc, xs) =
    if xs is
      Nil then acc
      Cons(x, xs') then aux(f(acc, x), xs')
  (xs) => aux(z, xs)

let sum = foldLeft((acc, x) => acc + x)(0)
//│ sum = [function]

:expect 0
sum(Nil)
//│ = 0

:expect 6
sum(1 :: 2 :: 3 :: Nil)
//│ = 6

let product = foldLeft((acc, x) => acc * x)(1)
//│ product = [function]

:expect 1
product(Nil)
//│ = 1

:expect 6
product(1 :: 2 :: 3 :: Nil)
//│ = 6

let length = foldLeft((acc, _) => acc + 1)(0)
//│ length = [function]

:expect 0
length(Nil)
//│ = 0

:expect 3
length(1 :: 2 :: 3 :: Nil)
//│ = 3

let reverse' = foldLeft((acc, x) => x :: acc)(Nil)
//│ reverse' = [function]

reverse'(Nil)
//│ = Nil

reverse'(1 :: 2 :: 3 :: Nil) |> showList
//│ = "[3, 2, 1]"


//   __       _     _ ____  _       _     _
//  / _| ___ | | __| |  _ \(_) __ _| |__ | |_
// | |_ / _ \| |/ _` | |_) | |/ _` | '_ \| __|
// |  _| (_) | | (_| |  _ <| | (_| | | | | |_
// |_|  \___/|_|\__,_|_| \_\_|\__, |_| |_|\__|
//                            |___/

fun foldRight(f)(z) =
  fun aux(acc, xs) =
    if xs is
      Nil then acc
      Cons(x, xs') then f(x, aux(acc, xs'))
  (xs) => aux(z, xs)

let double = foldRight((x, acc) => x :: x :: acc)(Nil)
//│ double = [function]

double(Nil) |> showList
//│ = "[]"

double(1 :: 2 :: 3 :: Nil) |> showList
//│ = "[1, 1, 2, 2, 3, 3]"

let flatten = foldRight((xs, acc) => xs ::: acc)(Nil)
//│ flatten = [function]

flatten(Nil) |> showList
//│ = "[]"

flatten(oneTwoThree :: oneTwoThree :: oneTwoThree :: Nil) |> showList
//│ = "[1, 2, 3, 1, 2, 3, 1, 2, 3]"

fun id(x) = x

fun foldLeft'[A, B](f: (A, B) -> A)(z: A) =
  let g(x, y)(z) = y(f(z, x))
  (xs) => foldRight(g)(id)(xs)(z)

let minus = foldLeft'((acc, x) => acc - x)(0)
//│ minus = [function]

minus(Nil)
//│ = 0

minus(1 :: 2 :: 3 :: Nil)
//│ = -6

let reverse'' = foldLeft'((acc, x) => x :: acc)(Nil)
//│ reverse'' = [function]

reverse(Nil)
//│ = Nil

reverse(1 :: 2 :: 3 :: Nil) |> showList
//│ = "[3, 2, 1]"

