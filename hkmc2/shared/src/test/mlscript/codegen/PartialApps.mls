:js


fun foo(x, y, z) = [x, y, z]

let f = foo(1, _, 3)
//│ f = [function f]

f(2)
//│ = [1, 2, 3]

:sjs
let f = foo(1, _, _)
//│ JS (unsanitized):
//│ let f2, f3; f3 = function f(_0, _1) { return foo(1, _0, _1) }; f2 = f3;
//│ f = [function f]

f(2, 3)
//│ = [1, 2, 3]

let g = f(_, 3)
//│ g = [function g]

g(2)
//│ = [1, 2, 3]

foo(_, _, 3) of 1, 2
//│ = [function]

{foo(_, _, 3)} of 1, 2
//│ = [1, 2, 3]

{foo(_, _, 3)}(1, 2)
//│ = [1, 2, 3]


fun foo2(x, y, z)(a, b) = [x, y, z, a, b]

{foo2(_, _, 3)(4, _)}(1, 2, 5)
//│ = [1, 2, 3, 4, 5]


// :sjs
let f = [_]
f(27)
//│ = [27]
//│ f = [function f]

// :sjs
let f = [_ + 1]
f.0(27)
//│ = 28
//│ f = [[function]]

let f = foo(..._)
f([1, 2, 3])
//│ = [1, 2, 3]
//│ f = [function f]

let f = [..._]
f([1, 2, 3])
//│ = [1, 2, 3]
//│ f = [function f]

// :sjs
let f = [..._]
f([])
//│ = []
//│ f = [function f]


let h = _ - 2
//│ h = [function h]

h(1)
//│ = -1


:sjs
let i = _(0, 1, _)
//│ JS (unsanitized):
//│ let i, i1; i1 = function i(_0, _1) { return runtime.safeCall(_0(0, 1, _1)) }; i = i1;
//│ i = [function i]

i(print, 2)
//│ > 0 1 2

:re
i(print)(2)
//│ ═══[RUNTIME ERROR] Error: Function 'i' expected 2 arguments but got 1

// :re
i((x, y, z) => x + y + z, 2)
//│ = 3

// :re
i((...args) => [...args], _)(2)
//│ = [function]


123 |> (_ + 1)
//│ = 124

// * Note: missing parens
123 |> _ + 1
//│ = [function]

123 |> ((_ + 1) >> (_ * 2))
//│ = 248

:re
123 |> (_ + 1 >> _ * 2)
//│ ═══[RUNTIME ERROR] Error: Function expected 2 arguments but got 1

(_ + 1 + _ * 2) of 123, 456
//│ = 1036

// * Note: lack of parens
let f = _ * 2 + 1 |> print in f(3)
//│ > 7

123 |> (_ + 1) |> (_ * 2)
//│ = 248

(_ * 2) <| (_ + 1) <| 123
//│ = 248

(_ + 1) >> (_ * 2) <| 123
//│ = 248


let j = _.x in j(x: 123)
//│ = 123

let j = _.x(123) in j(x: print)
//│ > 123


let j = _.x(1, _) in j((x: tuple), 0)
//│ = [1, 0]

// ie
let j = (obj, arg) => obj.x(1, arg) in j((x: tuple), 0)
//│ = [1, 0]

// TODO: really support this?
let j = _.x.y(1, _) in j((x: y: tuple), 0)
//│ = [1, 0]


data class C(a, b, c)

2 |> C(1, _, 3) |> print
//│ = [function]

2 |> (C(1, _, 3)) |> print
//│ > C(1, 2, 3)

2 |> {C(1, _, 3)} |> print
//│ > C(1, 2, 3)

2 |> {C(1, _, 3)} !> print
//│ > C(1, 2, 3)
//│ = C(1, 2, 3)

{2 |> {C(1, _, 3)}} !> print
//│ > C(1, 2, 3)
//│ = C(1, 2, 3)

2 |> {C(1, _, 3)} !> {print(_)} |> {print(_)}
//│ > C(1, 2, 3)
//│ > C(1, 2, 3)

(2 |> (new C(1, _, 3))) |> print
//│ > C(1, 2, 3)

2 |> (new C(1, _, 3)) |> print
//│ > C(1, 2, 3)


(_ - _) of 1, 2
//│ = -1

// * Note: missing parens
_ - _ of 1, 2
//│ = [function]


(_ - 2) <| 1
//│ = -1

1 |> (_ - 2)
//│ = -1

1
|> (_ - 2)
//│ = -1

:pe
|> 1
//│ ╔══[PARSE ERROR] Expected end of input; found literal instead
//│ ║  l.200: 	|> 1
//│ ╙──       	   ^
//│ = [function pipeInto]

:e
:re
|> (1)
//│ ╔══[ERROR] Expected 2 arguments, got 1
//│ ║  l.208: 	|> (1)
//│ ╙──       	   ^^^
//│ ═══[RUNTIME ERROR] TypeError: f1 is not a function

|> (1, _ - 2)
//│ = -1

1
  |> (_ - 2)
//│ = -1

1 |>
  _ - 2
//│ = -1

:sjs
1 . (_ - 2)
//│ JS (unsanitized):
//│ let lambda38; lambda38 = (undefined, function (_0) { return _0 - 2 }); Predef.passTo(1, lambda38)
//│ = [function]

:sjs
1 . (_ - 2)()
//│ JS (unsanitized):
//│ let tmp14, lambda39;
//│ lambda39 = (undefined, function (_0) {
//│   return _0 - 2
//│ });
//│ tmp14 = Predef.passTo(1, lambda39);
//│ runtime.safeCall(tmp14())
//│ = -1

1 . (_ - _)(2)
//│ = -1


// `_` here is interpreted as a UCS default case...
:sjs
let f = if _ then 1 else 0
//│ JS (unsanitized):
//│ let f15, tmp16; tmp16 = 1; f15 = tmp16;
//│ f = 1



