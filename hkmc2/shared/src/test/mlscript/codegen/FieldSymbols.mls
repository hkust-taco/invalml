:js


data class Foo(val x) with
  val y = x


// TODO add symbol to this Sel
:elt
Foo(42).x
//│ Elaborated tree:
//│ Blk:
//│   stats = Nil
//│   res = Sel:
//│     prefix = App:
//│       lhs = Ref:
//│         sym = member:Foo
//│         iargsLs = N
//│       rhs = Tup of Ls of 
//│         Fld:
//│           flags = ()
//│           term = Lit of IntLit of 42
//│           asc = N
//│       iargsLs = N
//│     nme = Ident of "x"
//│     iargsLs = N
//│ = 42


let foo = Foo(42)
//│ foo = Foo(42)

// TODO add symbol to this Sel
:elt
foo.x
//│ Elaborated tree:
//│ Blk:
//│   stats = Nil
//│   res = Sel:
//│     prefix = Ref:
//│       sym = foo
//│       iargsLs = N
//│     nme = Ident of "x"
//│     iargsLs = N
//│ = 42


// TODO add symbol to this Sel
:elt
foo.y
//│ Elaborated tree:
//│ Blk:
//│   stats = Nil
//│   res = Sel:
//│     prefix = Ref:
//│       sym = foo
//│       iargsLs = N
//│     nme = Ident of "y"
//│     iargsLs = N
//│ = 42


// * Notice that the `.x` selection has symbol, propagated to the lowered tree, as expected
:elt
:lot
case
  Foo(a) then a
//│ Elaborated tree:
//│ Blk:
//│   stats = Nil
//│   res = Lam:
//│     params = ParamList:
//│       flags = ()
//│       params = Ls of 
//│         Param:
//│           flags = ()
//│           sym = caseScrut
//│           sign = N
//│           modulefulness = Modulefulness of N
//│       restParam = N
//│     body = IfLike:
//│       kw = keyword 'if'
//│       desugared = Cons:
//│         head = Branch:
//│           scrutinee = Ref:
//│             sym = caseScrut
//│             iargsLs = N
//│           pattern = ClassLike:
//│             constructor = Ref:
//│               sym = member:Foo
//│               iargsLs = N
//│             arguments = S of Ls of 
//│               Tuple3:
//│                 _1 = $param0
//│                 _2 = Ident of "a"
//│                 _3 = N
//│             mode = Default
//│             refined = false
//│           continuation = Let:
//│             sym = a
//│             term = Ref:
//│               sym = $param0
//│               iargsLs = N
//│             tail = Else of Ref:
//│               sym = a
//│               iargsLs = N
//│         tail = End
//│ Lowered:
//│ Program:
//│   imports = Nil
//│   main = Define:
//│     defn = FunDefn:
//│       owner = N
//│       sym = member:lambda
//│       params = Ls of 
//│         ParamList:
//│           flags = ()
//│           params = Ls of 
//│             Param:
//│               flags = ()
//│               sym = caseScrut
//│               sign = N
//│               modulefulness = Modulefulness of N
//│           restParam = N
//│       body = Match:
//│         scrut = Ref of caseScrut
//│         arms = Ls of 
//│           Tuple2:
//│             _1 = Cls:
//│               cls = class:Foo
//│               path = Select{class:Foo}:
//│                 qual = Ref of member:Foo
//│                 name = Ident of "class"
//│             _2 = Assign:
//│               lhs = $param0
//│               rhs = Select{class:Foo.x}:
//│                 qual = Ref of caseScrut
//│                 name = Ident of "x"
//│               rest = Assign: \
//│               lhs = a
//│               rhs = Ref of $param0
//│               rest = Return: \
//│               res = Ref of a
//│               implct = false
//│         dflt = S of Throw of Instantiate:
//│           cls = Select:
//│             qual = Ref of globalThis:globalThis
//│             name = Ident of "Error"
//│           args = Ls of 
//│             Lit of StrLit of "match error"
//│         rest = End of ""
//│     rest = Assign: \
//│     lhs = $block$res
//│     rhs = Ref of member:lambda
//│     rest = Return: \
//│     res = Lit of UnitLit of false
//│     implct = true
//│ = [function]


// TODO support:
// data class Foo(x)

// Foo(123).0


