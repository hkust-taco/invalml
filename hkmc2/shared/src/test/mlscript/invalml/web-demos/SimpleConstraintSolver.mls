:invalml

:...
//│ ————————————————————————————————————————————————————————————————————————————————

// * In this file, we implement a simple constraint solver, originally presented in https://doi.org/10.1145/3410225
// * We only implement int type, function types, and type variables for simplicity

// *** infrastructures

class PairOf[A, B] with
  constructor
    Pair(fst: A, snd: B)

class Stack[A] with
  constructor
    Nil
    Cons(head: A, tail: Stack[out A])

class ArrayList[A, R]
class Iter[T, R]

class Option[A] with
  constructor
    None
    Some(value: A)


fun
  empty:   [A, R] -> Region[R] ->{R} ArrayList[A, out R]
  clear:   [A, R] -> (ArrayList[A, out R]) ->{R} ()
  push:    [A, R] -> (ArrayList[A, out R], A) ->{R} ()
  foreach: [E, R, T] -> (Iter[T, R], T ->{E} ()) ->{R | E} ()
  iter: [outer, Res, R, E extends ~R, T] ->
    (ArrayList[T, out R], [S extends ~outer] -> Iter[T, S] ->{S | E} Res) ->{E | R} Res
  next: [T, S] -> Iter[T, S] ->{S} Option[T]
  whileDo: [R] -> (() ->{R} Bool) ->{R} ()

fun error() = error()


// *** simple constraint solver


// Unif contains a type variable's id, lower bounds, and upper bounds.
class Type[R] with
  constructor
    IntType
    Unif(id: Int, lowerBounds: ArrayList[Type[R], out R], upperBounds: ArrayList[Type[R], out R])
    Fun(lhs: Type[R], rhs: Type[R])


fun solve(lst) = if lst is
  Nil then ()
  Cons(c, cs) then if c is
    Pair(lhs, rhs) then
      if lhs is
        IntType then if rhs is
          IntType then ()
          Fun(_, _) then error()
          Unif(id, lbs, ubs) then
            push(lbs, lhs)
            region r in
              let ncs = r.ref cs
              iter of ubs, it =>
                whileDo of () =>
                  if next(it) is
                    Some(x) then
                      ncs := Cons(Pair(lhs, x), !ncs)
                      true
                    None then false
              solve(!ncs)
        Fun(l1, r1) then if rhs is
          Fun(l2, r2) then
            solve(Cons(Pair(l2, l1), Cons(Pair(r1, r2), cs)))
          IntType then error()
          Unif(id, lbs, ubs) then
            push(lbs, lhs)
            region r in
              let ncs = r.ref cs
              iter of ubs, it =>
                whileDo of () =>
                  if next(it) is
                    Some(x) then
                      ncs := Cons(Pair(lhs, x), !ncs)
                      true
                    None then false
              solve(!ncs)
        Unif(id, lbs, ubs) then
          push(ubs, rhs)
          region r in
            let ncs = r.ref cs
            iter of lbs, it =>
              whileDo of () =>
                if next(it) is
                  Some(x) then
                    ncs := Cons(Pair(x, rhs), !ncs)
                    true
                  None then false
            solve(!ncs)

// *** error example

// if we call the `solve` function during the iteration, the `solve` function
// can only handle the cases where no allocation is required (i.e., no type variables)
// fun solve(lst) = if lst is
//   Nil then ()
//   Cons(c, cs) then if c is
//     Pair(lhs, rhs) then
//       if lhs is
//         IntType then if rhs is
//           IntType then ()
//           Fun(_, _) then error()
//           Unif(id, lbs, ubs) then
//             push(lbs, lhs)
//             iter of lbs, it =>
//               whileDo of () =>
//                 if next(it) is
//                   Some(x) then
//                     solve(Cons(Pair(lhs, x), Nil))
//                     true
//                   None then false
//             solve(cs)
//         Fun(l1, r1) then  if rhs is
//           Fun(l2, r2) then
//             solve(Cons(Pair(l2, l1), Cons(Pair(r1, r2), cs)))
//           IntType then error()
//           Unif(id, lbs, ubs) then
//             push(lbs, lhs)
//             iter of lbs, it =>
//               whileDo of () =>
//                 if next(it) is
//                   Some(x) then
//                     solve(Cons(Pair(lhs, x), Nil))
//                     true
//                   None then false
//             solve(cs)
//         Unif(id, lbs, ubs) then
//           push(ubs, rhs)
//           iter of lbs, it =>
//             whileDo of () =>
//               if next(it) is
//                 Some(x) then
//                   solve(Cons(Pair(x, rhs), Nil))
//                   true
//                 None then false
//           solve(cs)


// The error' version of `solve` function can only be used for constraints without type variables
// solve(Cons(Pair(IntType, IntType), Nil))

// Calling the `solve` function to solve constraints involving type variables will lead to type errors
// region r in
//   let v1 = Unif(1, empty(r), empty(r))
//   let v2 = Unif(2, empty(r), empty(r))
//   solve(Cons(Pair(v1, Fun(IntType, v2)), Nil))

// *** examples

region r in
  solve(Cons(Pair(IntType, IntType), Nil))

region r in
  solve(Cons(Pair(IntType, Fun(IntType, IntType)), Nil))

region r in
  let v1 = Unif(1, empty(r), empty(r))
  let v2 = Unif(2, empty(r), empty(r))
  solve(Cons(Pair(v1, Fun(IntType, v2)), Nil))

//│ ————————————————————————————————————————————————————————————————————————————————
