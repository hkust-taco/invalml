:invalml


class Reg[Rg, Br]

fun letreg: [E, Res] -> ([Rg] -> Reg[Rg, E] ->{E | Rg} Res) ->{E} Res

fun subreg: [E, Rg, Br, Res] -> Reg[Rg, Br] -> ([Rg2] -> Reg[Rg2 & ~Rg, E] ->{E | Rg2} Res) ->{E} Res

fun read: [Rg, Br] -> Reg[Rg, Br] ->{Br} Int
fun write: [Rg, Br] -> Reg[Rg, Br] ->{Rg} Int


fun borrow: [Rg, Br, Res] -> Reg[Rg, Br] ->{Rg} (() ->{Br} Res) ->{Br} Res

letreg of r =>
  read(r)
  borrow(r) of () =>
    read(r)
  write(r)
//│ Type: Int

:e
letreg of r =>
  read(r)
  borrow(r) of () =>
    write(r)
    read(r)
  write(r)
//│ ╔══[ERROR] Type error in block
//│ ║  l.24: 	letreg of r =>
//│ ║        	^^^^^^^^^^^^^^
//│ ║  l.25: 	  read(r)
//│ ║        	^^^^^^^^^
//│ ║  l.26: 	  borrow(r) of () =>
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.27: 	    write(r)
//│ ║        	^^^^^^^^^^^^
//│ ║  l.28: 	    read(r)
//│ ║        	^^^^^^^^^^^
//│ ║  l.29: 	  write(r)
//│ ║        	^^^^^^^^^^
//│ ╟── because: cannot constrain  'E  <:  ⊥
//│ ╟── because: cannot constrain  'Rg  <:  ⊥
//│ ╙── because: cannot constrain  ⊤  <:  ⊥
//│ Type: Int


fun borrow: [Rg, Br, Res] -> Reg[Rg, Br] ->{Rg} (() ->{Br | ~Rg} Res) ->{Br} Res

letreg of r =>
  read(r)
  borrow(r) of () =>
    read(r)
  write(r)
//│ Type: Int


:e
letreg of r =>
  read(r)
  borrow(r) of () =>
    write(r)
    read(r)
  write(r)
//│ ╔══[ERROR] Type error in block
//│ ║  l.60: 	letreg of r =>
//│ ║        	^^^^^^^^^^^^^^
//│ ║  l.61: 	  read(r)
//│ ║        	^^^^^^^^^
//│ ║  l.62: 	  borrow(r) of () =>
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.63: 	    write(r)
//│ ║        	^^^^^^^^^^^^
//│ ║  l.64: 	    read(r)
//│ ║        	^^^^^^^^^^^
//│ ║  l.65: 	  write(r)
//│ ║        	^^^^^^^^^^
//│ ╟── because: cannot constrain  'E  <:  ⊥
//│ ╟── because: cannot constrain  'Rg  <:  ⊥
//│ ╙── because: cannot constrain  ⊤  <:  ⊥
//│ Type: Int


// * TODO...


