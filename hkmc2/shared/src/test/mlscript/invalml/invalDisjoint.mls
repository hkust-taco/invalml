:invalml



data class Pair[P, Q](fst: P, snd: Q)

fun fork: [A, B extends ~A, T1, T2] -> (Any ->{A} T1, Any ->{B} T2) ->{A | B} Pair[out T1, out T2]
fork
//│ Type: ['A, 'B, 'T1, 'T2] -> ((⊤) ->{'A} 'T1, (⊤) ->{'B} 'T2) ->{'A ∨ 'B} Pair[out 'T1, out 'T2]
//│ Where:
//│   'B <: ¬'A


fun foo: Any -> Int
fun bar: Any -> Str


fork(foo, bar)
//│ Type: Pair[out Int, out Str]


:e
region x in
  fork((_ => x.ref 1), (_ => x.ref 2))
//│ ╔══[ERROR] Type error in function literal with expected type (⊤) ->{'B} 'T2
//│ ║  l.24: 	  fork((_ => x.ref 1), (_ => x.ref 2))
//│ ║        	                             ^^^^^^^
//│ ╟── because: cannot constrain  'reg  <:  'B
//│ ╟── because: cannot constrain  x  <:  'B
//│ ╟── because: cannot constrain  x  <:  ¬'A
//│ ╟── because: cannot constrain  'A  <:  ¬x
//│ ╙── because: cannot constrain  x  <:  ¬x
//│ Type: Pair[out Ref[Int, ?], out Ref[Int, ?]]



region x in
  region y in
    fork((_ => x.ref 1), (_ => y.ref 2))
//│ Type: Pair[out Ref[Int, ?], out Ref[Int, ?]]


let naive_helper = r1 => // cannot infer the outer variable!
  region r2 in
    fork((_ => r1.ref 1), (_ => r2.ref 2))
naive_helper
//│ Type: (Region[out 'reg]) ->{'reg} Pair[out Ref[Int, out 'reg], out Ref[Int, ?]]
//│ Where:
//│   'reg <: ⊥


fun f: [S, R, R extends ~S] -> (Region[out S], Region[out R]) ->{S | R} Int

:e
region r1 in
  let g = (r => region r2 in f(r, r2)) in
    region r3 in g(r3)
//│ ╔══[ERROR] Type error in reference with expected type 'r
//│ ║  l.57: 	    region r3 in g(r3)
//│ ║        	                   ^^
//│ ╟── because: cannot constrain  Region[in ⊥ out r3]  <:  'r
//│ ╟── because: cannot constrain  Region[in ⊥ out 'r31]  <:  'r
//│ ╟── because: cannot constrain  Region[in ⊥ out 'r31]  <:  Region[in ⊥ out 'S]
//│ ╟── because: cannot constrain  'r31  <:  'S
//│ ╟── because: cannot constrain  ¬r1  <:  'S
//│ ╟── because: cannot constrain  ¬r1  <:  ¬'r2 ∨ r1
//│ ╟── because: cannot constrain  'r2  <:  r1
//│ ╙── because: cannot constrain  ¬r1  <:  r1
//│ ╔══[ERROR] Type error in block
//│ ║  l.56: 	  let g = (r => region r2 in f(r, r2)) in
//│ ║        	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.57: 	    region r3 in g(r3)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  'eff  <:  ⊥
//│ ╟── because: cannot constrain  ¬'r11  <:  ⊥
//│ ╟── because: cannot constrain  ⊤  <:  'r11
//│ ╙── because: cannot constrain  ⊤  <:  ⊥
//│ Type: Int

fun g(r) =
  region r2 in f(r, r2)

region r1 in
  region r3 in g(r3)
//│ Type: Int


:e
region x in
  naive_helper(x)
//│ ╔══[ERROR] Type error in reference with expected type 'r1
//│ ║  l.90: 	  naive_helper(x)
//│ ║        	               ^
//│ ╟── because: cannot constrain  Region[in ⊥ out x]  <:  'r1
//│ ╟── because: cannot constrain  Region[in ⊥ out 'x1]  <:  'r1
//│ ╟── because: cannot constrain  Region[in ⊥ out 'x1]  <:  Region[in ⊥ out 'reg]
//│ ╟── because: cannot constrain  'x1  <:  'reg
//│ ╟── because: cannot constrain  ⊤  <:  'reg
//│ ╙── because: cannot constrain  ⊤  <:  ⊥
//│ ╔══[ERROR] Type error in block
//│ ║  l.90: 	  naive_helper(x)
//│ ║        	  ^^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  'eff  <:  ⊥
//│ ╟── because: cannot constrain  ¬'x2 ∧ 'eff1  <:  ⊥
//│ ╟── because: cannot constrain  'eff1  <:  'x2
//│ ╟── because: cannot constrain  'eff1  <:  ⊥
//│ ╟── because: cannot constrain  'reg  <:  ⊥
//│ ╙── because: cannot constrain  ⊤  <:  ⊥
//│ Type: Pair[out Ref[Int, ?], out Ref[Int, ?]]


fun helper(r1) =
  region r2 in
    fork((_ => r1.ref 1), (_ => r2.ref 2))
helper
//│ Type: [outer, 'reg] -> Region[out 'reg] ->{'reg} Pair[out Ref[Int, out 'reg], out Ref[Int, out ¬outer]]
//│ Where:
//│   'reg <: outer


region x in
  helper(x)
//│ Type: Pair[out Ref[Int, ?], out Ref[Int, ?]]


region x in
  (region y in let t = helper(y) in 42) as [A] -> Int
//│ Type: Int


region x in
  region y in
    let t = helper(x) in 42
//│ Type: Int


:e
region x in
  (region y in let t = helper(x) in 42) as [A] -> Int
//│ ╔══[ERROR] Type error in reference with expected type 'r1
//│ ║  l.139: 	  (region y in let t = helper(x) in 42) as [A] -> Int
//│ ║         	                              ^
//│ ╟── because: cannot constrain  Region[in ⊥ out x]  <:  'r1
//│ ╟── because: cannot constrain  Region[in ⊥ out x]  <:  Region[in ⊥ out 'reg]
//│ ╟── because: cannot constrain  x  <:  'reg
//│ ╟── because: cannot constrain  x  <:  'env
//│ ╙── because: cannot constrain  x  <:  outer ∨ y
//│ ╔══[ERROR] Type error in region expression with expected type [outer, 'A] -> Int
//│ ║  l.139: 	  (region y in let t = helper(x) in 42) as [A] -> Int
//│ ║         	                       ^^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  'eff  <:  ⊥
//│ ╟── because: cannot constrain  ¬'y1 ∧ x  <:  ⊥
//│ ╟── because: cannot constrain  x  <:  'y1
//│ ╙── because: cannot constrain  x  <:  ⊥
//│ Type: Int


fun anno: [outer A] -> Int ->{A} Int


fun anno2: [outer] -> Int ->{outer} Int


:e
fun badanno: outer
//│ ═══[ERROR] Illegal outer reference.
//│ ═══[ERROR] Invalid type

:e
fun badanno2: [outer A, outer B] -> Int ->{A | B} Int
//│ ╔══[ERROR] Only one outer variable can be bound.
//│ ║  l.170: 	fun badanno2: [outer A, outer B] -> Int ->{A | B} Int
//│ ╙──       	              ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Illegal forall annotation.
//│ ║  l.170: 	fun badanno2: [outer A, outer B] -> Int ->{A | B} Int
//│ ╙──       	              ^^^^^^^^^^^^^^^^^^
//│ ═══[ERROR] Invalid type


fun annohelper: [outer, T extends outer] -> Region[out T] ->{T} Pair[out Ref[Int, out T], out Ref[Int, out ~outer]]
fun annohelper(r1) =
  region r2 in
    fork((_ => r1.ref 1), (_ => r2.ref 2))
annohelper
//│ Type: [outer, 'T] -> (Region[out 'T]) ->{'T} Pair[out Ref[Int, out 'T], out Ref[Int, out ¬outer]]
//│ Where:
//│   'T <: outer


region x in
  annohelper(x)
//│ Type: Pair[out Ref[Int, ?], out Ref[Int, ?]]


fun annohelper: [outer, T] -> Region[out T & outer] ->{T & outer} Pair[out Ref[Int, out T & outer], out Ref[Int, out ~outer]]
fun annohelper(r1) =
  region r2 in
    fork((_ => r1.ref 1), (_ => r2.ref 2))
annohelper
//│ Type: [outer, 'T] -> (Region[out 'T ∧ outer]) ->{'T ∧ outer} Pair[out Ref[Int, out 'T ∧ outer], out Ref[Int, out ¬outer]]


region x in
  annohelper(x)
//│ Type: Pair[out Ref[Int, out 'env], out Ref[Int, ?]]
//│ Where:
//│   ⊤ <: 'env


// Cannot type check since foo: 'foo <: Region[T] ->{'eff} 'app 
// Annotation is required for recursive calls
:e
fun foo(r1) =
  region r2 in
    fork((_ => r1.ref 1), (_ => r2.ref 2))
    foo(r2)
//│ ╔══[ERROR] Type error in function literal
//│ ║  l.213: 	fun foo(r1) =
//│ ║         	        ^^^^^
//│ ║  l.214: 	  region r2 in
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.215: 	    fork((_ => r1.ref 1), (_ => r2.ref 2))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.216: 	    foo(r2)
//│ ║         	^^^^^^^^^^^
//│ ╟── because: cannot constrain  ('r1) ->{'eff} ('app)  <:  'foo
//│ ╟── because: cannot constrain  ('r1) ->{'eff} ('app)  <:  (Region[in ⊥ out 'r2]) ->{'eff1} ('app1)
//│ ╟── because: cannot constrain  Region[in ⊥ out 'r2]  <:  'r1
//│ ╟── because: cannot constrain  Region[in ⊥ out 'r2]  <:  Region[in ⊥ out 'reg]
//│ ╟── because: cannot constrain  'r2  <:  'reg
//│ ╟── because: cannot constrain  ¬outer  <:  'reg
//│ ╟── because: cannot constrain  ¬outer  <:  ¬'r21 ∨ outer
//│ ╟── because: cannot constrain  'r21  <:  outer
//│ ╙── because: cannot constrain  ¬outer  <:  outer


fun foo: [outer S, T extends S] -> Region[out T] ->{T} Nothing
fun foo(r1) =
  region r2 in
    foo(r2)
foo
//│ Type: [outer S, 'T] -> (Region[out 'T]) ->{'T} ⊥
//│ Where:
//│   'T <: S


fun foo: [outer To, T extends To] -> Region[out T] ->{T} ([outer So, S extends So] -> Region[S]->{S} Pair[out Ref[Int, out S], out Ref[Int, out Any]])
fun foo(r1) =
  r3 =>
    region r4 in
      fork((_ => r3.ref 3), (_ => r4.ref 4))


fun bar: [outer S, T extends S] -> Region[out T] ->{T} Int


bar as [outer Q, P extends Q] -> Region[P] ->{P} Int
//│ Type: [outer Q, 'P] -> (Region['P]) ->{'P} Int
//│ Where:
//│   'P <: Q


fun foo: [outer To, T extends To] -> Region[out T] ->{T} ([outer So, S extends So] -> Region[out S]->{S} Int)
fun foo(r1) = bar
foo
//│ Type: [outer To, 'T] -> (Region[out 'T]) ->{'T} [outer So, 'S] -> (Region[out 'S]) ->{'S} Int
//│ Where:
//│   'T <: To
//│   'S <: So


fun borrow: [S, T, E extends ~S] -> Region[out S] -> ([P] -> Region[out P] ->{E | P} T) ->{E} T


fun foo(f) =
  region r in
    let x = r.ref 0
    f(n => x := n)
    borrow(r) of it =>
      foo(f)
foo
//│ Type: [outer, 'n, 'eff] -> (('n ->{¬outer} ('n ∨ Int)) ->{'eff} ⊤) ->{'eff} ⊥
//│ Where:
//│   'n <: Int
//│   'eff <: outer
