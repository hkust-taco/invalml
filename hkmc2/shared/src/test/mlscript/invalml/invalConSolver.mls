:js

:global
:invalml


declare class Array[T]
declare class Map[K, V]

fun mkArray: [T] -> () -> Array[T]
fun mkArray() = @untyped globalThis.Array()

fun at: [T] -> (Array[T], Int) -> T
fun at(xs, i) = @untyped xs.at(i)

fun not(b) = if b then false else true
fun (;) seq(_, res) = res
fun id(x) = x

fun println: Any -> ()
fun println(s) = @untyped print(s)

fun (~) concat: (Str, Str) -> Str
fun concat(x, y) = @untyped x + y

fun toString: Any -> Str
fun toString(x) = @untyped x.toString()

fun (===) seq: (Str, Str) -> Bool
fun seq(x, y) = @untyped x == y

fun mkMap: [K, V] -> () -> Map[K, V]
fun mkMap() = @untyped id(new globalThis.Map())

fun has: [K, V] -> (Map[K, V], K) -> Bool
fun has(m, k) = @untyped m.has(k)

fun getFromMap: [K, V] -> (Map[K, V], K) -> V
fun getFromMap(m, k) = @untyped m.get(k)

fun setToMap: [K, V] -> (Map[K, V], K, V) -> ()
fun setToMap(m, k, v) = @untyped m.set(k, v)


fun error() = error()
fun (???) TODO() = TODO()




class PairOf[out A, out B] with
  constructor
    Pair(fst: A, snd: B)

class Option[out A] with
  constructor
    None()
    Some(value: A)

class List[out A] with
  constructor
    Nil()
    Cons(head: A, tail: List[A])

fun fold(x, xs, f) = if xs is
  Nil() then x
  Cons(y, ys) then fold(f(x, y), ys, f)

fun map(xs, f) = if xs is
  Nil() then Nil()
  Cons(x, xs) then Cons(f(x), map(xs, f))

fun each(xs, f) = if xs is
  Nil() then ()
  Cons(x, xs) then f(x); each(xs, f)

fun find(xs, f) = if xs is
  Nil() then None()
  Cons(x, xs) then
    if f(x) then Some(x)
    else find(xs, f)

class ArrayList[T, out R](val d: Array[T])
class Iter[T, out R](val arr: Array[T], val i: Ref[Int, out R], val step: Int, val end: Int)
class HashMap[K, V, out R](val d: Map[Str, V], val f: K -> Str)
class MapIter[T, out R](val it: Any)

// fun empty:   [A, R] -> Region[R] ->{R} ArrayList[out A, out R]  // TODO investigate: why does this break things?
fun empty: [A, R] -> Region[out R] ->{R} ArrayList[A, out R]
fun empty(r) = new ArrayList(mkArray())

fun clear: [A, R] -> (ArrayList[A, out R]) ->{R} ()
fun clear(arr) = @untyped arr.ArrayList#d.splice(0, arr.length); ()

fun push: [A, R] -> (ArrayList[A, R], A) ->{R} ()
fun push(arr, e) = @untyped arr.ArrayList#d.push(e); ()

fun len: [A, R] -> (ArrayList[A, R]) ->{R} Int
fun len(arr) = @untyped arr.ArrayList#d.length

fun iter: [Res, R, E extends ~R, T] -> (ArrayList[T, R], [S] -> Iter[T, S] ->{S | E} Res) ->{E | R} Res
fun iter(arr, f) =
  region r in f(new Iter(arr.ArrayList#d, (r.ref 0), 1, len(arr)))

fun next: [T, S] -> Iter[T, S] ->{S} Option[T]
fun next(it) =
  let i = !it.Iter#i
  if i == it.Iter#end then None()
  else
    let res = Some(at of it.Iter#arr, i)
    it.Iter#i := i + it.Iter#step
    res

fun whileDo: [R] -> (() ->{R} Bool) ->{R} ()
fun whileDo(f) =
  if f() then whileDo(f) else ()

fun foreach: [E, R, T] -> (Iter[T, R], T ->{E} ()) ->{R | E} ()
fun foreach(it, f) =
  whileDo of () =>
    if next(it) is
      Some(x) then f(x); true
      None then false

fun freeze: [R, E extends ~R, T] -> (Region[out R], () ->{~R & E} T) ->{R | E} T
fun freeze(r, f) = f()

fun max(x, y) = if x < y then y else x


fun mkHashMap: [R, K, V] -> (Region[out R], K -> Str) ->{R} HashMap[K, V, R]
fun mkHashMap(r, f) = new HashMap(mkMap(), f)

fun getOrUpdate: [R, K, V, E] -> (HashMap[K, V, R], K, () ->{E} V) ->{E | R} V
fun getOrUpdate(m, k, fv) =
  let sk = m.HashMap#f(k)
  if has(m.HashMap#d, sk) then getFromMap(m.HashMap#d, sk)
  else
    let res = fv()
    setToMap(m.HashMap#d, sk, res)
    res

fun hasOrUpdate: [R, K, V, E] -> (HashMap[K, V, R], K, () ->{E} V) ->{E | R} ()
fun hasOrUpdate(m, k, fv) = getOrUpdate(m, k, fv); ()

fun iterMap: [Res, R, E extends ~R, K, V] -> (HashMap[K, V, R], [S] -> MapIter[V, S] ->{S | E} Res) ->{E | R} Res
fun iterMap(m, f) = @untyped f(id(new MapIter(m.HashMap#d.values())))

fun nextVal: [T, S] -> MapIter[T, S] ->{S} Option[T]
fun nextVal(it) =
  @untyped id(let obj = it.MapIter#it.next() in if obj.done then None() else Some(obj.value) )


fun hasKey: [K, V, R] -> (HashMap[K, V, R], K) ->{R} Bool
fun hasKey(m, k) = has(m.HashMap#d, m.HashMap#f(k))


fun add: [K, V, R] -> (HashMap[K, V, R], K, V) ->{R} ()
fun add(m, k, v) = setToMap(m.HashMap#d, m.HashMap#f(k), v)


fun values: [E, R, T] -> (MapIter[T, R], T ->{E} ()) ->{R | E} ()
fun values(it, f) =
  whileDo of () =>
    if nextVal(it) is
      Some(x) then f(x); true
      None then false


class Type[out R] with
  constructor
    IntType()
    FunctionType(lhs: Type[R], rhs: Type[R])
    RecordType(fields: List[PairOf[Str, Type[R]]])
    TypeVariable(name: Str, level: Int, lowerBounds: ArrayList[Type[R], R], upperBounds: ArrayList[Type[R], R])
    

fun isSimpl(ty) = if ty is
  FunctionType(_, _) then false
  else true


fun ty2Str(ty) = if ty is
  IntType() then "Int"
  FunctionType(lhs, rhs) then
    let ls = if isSimpl(lhs) then ty2Str(lhs) else "(" ~ ty2Str(lhs) ~ ")"
    ls ~ " -> " ~ ty2Str(rhs)
  RecordType(fields) then "{ " ~ fold("", fields, (s, p) => if p is Pair(n, t) then s ~ n ~ ": " ~ ty2Str(t) ~ ", ") ~ "}"
  TypeVariable(name, level, _, _) then name ~ "_" ~ toString(level)

// fun levelOf: [R] -> Type[R] -> Int
fun levelOf(ty) = if ty is
  IntType() then 0
  FunctionType(lhs, rhs) then max(levelOf(lhs), levelOf(rhs))
  RecordType(fields) then fold(0, fields, (r, p) => if p is Pair(_, t) then max(r, levelOf(t)))
  TypeVariable(_, level, _, _) then level


:e
fun matchP = case
  Pair(IntType, IntType) then ()
//│ ╔══[ERROR] Pattern Ident(IntType) is not supported yet.
//│ ║  l.201: 	  Pair(IntType, IntType) then ()
//│ ╙──       	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Pattern Ident(IntType) is not supported yet.
//│ ║  l.201: 	  Pair(IntType, IntType) then ()
//│ ╙──       	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Expect 4 cases, but 1 got.
//│ ║  l.201: 	  Pair(IntType, IntType) then ()
//│ ╙──       	                ^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Expect 4 cases, but 1 got.
//│ ║  l.201: 	  Pair(IntType, IntType) then ()
//│ ╙──       	       ^^^^^^^^^^^^^^^^^^^^^^^^^


fun test: [R] -> (ArrayList[Int, R]) ->{R} Int
fun test(xs) =
  region r in
    iter of xs, it =>
      1

fun test: [outer, R extends outer] -> (Region[R]) ->{R} Int
fun test(xs) =
  region r in
    let ncs = r.ref 0
    freeze of xs, () =>
      ncs := 1

fun test: [outer, R extends outer] -> (ArrayList[Int, R]) ->{R} Int
fun test(xs) =
  region r in
    let ncs = r.ref 0
    iter of xs, it =>
      ncs := 1

// * Note the missing `outer` bound
// TODO: assume that bound implicitly?
:e
fun test: [R] -> (ArrayList[Int, R]) ->{R} Int
fun test(xs) =
  region r in
    let ncs = r.ref 0
    iter of xs, it =>
      ncs := 1
//│ ╔══[ERROR] Type error in function literal with expected type (Iter['T, out S]) ->{S ∨ 'E} 'Res
//│ ║  l.243: 	    iter of xs, it =>
//│ ║         	                ^^^^^
//│ ║  l.244: 	      ncs := 1
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  'reg  <:  S ∨ 'E
//│ ╟── because: cannot constrain  'reg  <:  'E ∨ S
//│ ╟── because: cannot constrain  'reg1  <:  'E ∨ S
//│ ╟── because: cannot constrain  ¬'S1 ∧ 'reg1  <:  'E
//│ ╟── because: cannot constrain  ¬'S1 ∧ 'reg1  <:  ¬'R
//│ ╟── because: cannot constrain  'R ∧ 'reg1  <:  'S1
//│ ╟── because: cannot constrain  'R ∧ 'reg1  <:  ⊥
//│ ╟── because: cannot constrain  'R  <:  ¬'reg1
//│ ╟── because: cannot constrain  R1  <:  ¬'reg1
//│ ╟── because: cannot constrain  'reg1  <:  ¬R1
//│ ╙── because: cannot constrain  r ∧ ¬outer  <:  ¬R1




fun report(lhs, rhs) =
  println("Cannot constrain " ~ ty2Str(lhs) ~ " <: " ~ ty2Str(rhs) ~ "!")


fun extrude: [outer, R extends outer] -> (Type[R], Bool, Int, (Str, Int) ->{R} Type[R], HashMap[PairOf[Type[R], PairOf[Int, Bool]], Type[R], R]) ->{R} Type[R]
fun extrude(ty, pol, lvl, freshVar, cache) = getOrUpdate of cache, Pair(ty, Pair(lvl, pol)), () =>
  if levelOf(ty) <= lvl then ty
  else if ty is
    IntType() then ty
    FunctionType(lhs, rhs) then
      FunctionType(extrude(lhs, not(pol), lvl, freshVar, cache), extrude(rhs, pol, lvl, freshVar, cache))
    RecordType(fields) then
      RecordType(map(fields, p => if p is Pair(name, ty) then Pair(name, extrude(ty, pol, lvl, freshVar, cache))))
    TypeVariable(name, level, lb, ub) then
      let nc = freshVar(name ~ "'" ~ (if pol then "+" else "-"), lvl)
      if pol then
        push(ub, nc)
        let nlb = if nc is
          TypeVariable(_, _, lb, _) then lb
          else error() // impossible
        region r in
          let nbd = empty(r)
          iter of lb, it => foreach(it, b => push(nbd, b))
          iter of nbd, it => foreach(it, b => push(nlb, extrude(b, pol, lvl, freshVar, cache)))
      else
        push(lb, nc)
        let nub = if nc is
          TypeVariable(_, _, _, ub) then ub
          else error() // impossible
        region r in
          let nbd = empty(r)
          iter of ub, it => foreach(it, b => push(nbd, b))
          iter of nbd, it => foreach(it, b => push(nub, extrude(b, pol, lvl, freshVar, cache)))
      nc

// fun solve: [outer, R extends outer] -> (List[PairOf[Type[R], Type[R]]], (Str, Int) ->{R} Type[R], HashMap[PairOf[Type[R], Type[R]], Any, R], () ->{R} HashMap[PairOf[Type[R], PairOf[Int, Bool]], Type[R], R]) ->{R} ()
fun solve(constraints, freshVar, cache, genExtrCache) = if constraints is
  Nil() then ()
  Cons(c, cs) then if c is
    Pair(lhs, rhs) then hasOrUpdate of cache, c, () =>
      if lhs is
        IntType() then if rhs is
          IntType() then solve(cs, freshVar, cache, genExtrCache)
          TypeVariable(name, level, lb, ub) then
            push(lb, lhs)
            region r in
              let ncs = r.ref cs
              iter(ub, it => foreach(it, b => ncs := Cons(Pair(lhs, b), !ncs); ()))
              solve(!ncs, freshVar, cache, genExtrCache)
          else report(lhs, rhs)
        FunctionType(arg, res) then if rhs is
          FunctionType(arg', res') then
            solve(Cons(Pair(arg', arg), Cons(Pair(res, res'), cs)), freshVar, cache, genExtrCache)
          TypeVariable(name, level, lb, ub) then
            if levelOf(lhs) <= level then
              push(lb, lhs)
              region r in
                let ncs = r.ref cs
                iter(ub, it => foreach(it, b => ncs := Cons(Pair(lhs, b), !ncs); ()))
                solve(!ncs, freshVar, cache, genExtrCache)
            else
              let lhs' = extrude(lhs, true, level, freshVar, genExtrCache())
              solve(Cons(Pair(lhs', rhs), cs), freshVar, cache, genExtrCache)
          else report(lhs, rhs)
        RecordType(flds) then if rhs is
          RecordType(flds') then each(flds', p' =>
            if p' is Pair(n', t') then
              if find(flds, p => if p is Pair(n, t) then n === n') is
                Some(p) then if p is Pair(n, t) then solve(Cons(Pair(t, t'), cs), freshVar, cache, genExtrCache)
                None() then println("Missing field " ~ n' ~ " in " ~ ty2Str(lhs))
            )
          TypeVariable(name, level, lb, ub) then
            if levelOf(lhs) <= level then
              push(lb, lhs)
              region r in
                let ncs = r.ref cs
                iter(ub, it => foreach(it, b => ncs := Cons(Pair(lhs, b), !ncs); ()))
                solve(!ncs, freshVar, cache, genExtrCache)
            else
              let lhs' = extrude(lhs, true, level, freshVar, genExtrCache())
              solve(Cons(Pair(lhs', rhs), cs), freshVar, cache, genExtrCache)
          else report(lhs, rhs)
        TypeVariable(name, level, lb, ub) then
          if levelOf(rhs) <= level then
            push(ub, rhs)
            region r in
              let ncs = r.ref cs
              iter(lb, it => foreach(it, b => ncs := Cons(Pair(b, rhs), !ncs); ()))
              solve(!ncs, freshVar, cache, genExtrCache)
          else
            let rhs' = extrude(rhs, false, level, freshVar, genExtrCache())
            solve(Cons(Pair(lhs, rhs'), cs), freshVar, cache, genExtrCache)


fun freshVar(r, ctx, name, lvl) =
  if (not of hasKey(ctx, name)) then
    add(ctx, name, 1)
    TypeVariable(name, lvl, empty(r), empty(r))
  else
    region r2 in
      let i = r2.ref 0
      let res = r2.ref None()
      whileDo of () =>
        let nn = name ~ toString(!i)
        if (not of hasKey(ctx, nn)) then
          res := Some(TypeVariable(nn, lvl, empty(r), empty(r)))
          add(ctx, nn, 1)
          false
        else
          i := !i + 1
          true
      if !res is
        Some(v) then v
        else error()


fun genHash(r) =
  mkHashMap(r, p => if p is Pair(x, y) then ty2Str(x) ~ " <: " ~ ty2Str(y))

fun genExtrHash(r) =
  () => mkHashMap(r, t => if t is Pair(ty, p) then if p is Pair(lvl, pol) then ty2Str(ty) ~ (if pol then "+_" else "-_") ~ toString(lvl))


fun printBounds(tv) = if tv is
  TypeVariable(name, level, lb, ub) then
    iter of lb, it =>
      foreach of it, b => println("  " ~ ty2Str(b) ~ " <: " ~ ty2Str(tv))
    iter of ub, it =>
      foreach of it, b => println("  " ~ ty2Str(tv) ~ " <: " ~ ty2Str(b))
  else ()

// fun printRes: [outer, R extends outer] -> (Type[R], Type[R]) ->{R} ()
fun printRes(lhs, rhs) =
  println(ty2Str(lhs) ~ " <: " ~ ty2Str(rhs))
  region r in
    let tvs = mkHashMap(r, s => s)
    // fun go: [outer, R extends outer, S extends outer] -> (Type[R], HashMap[Str, Type[R], S]) ->{R | S} ()
    fun go(t, tvs) = if t is
        IntType() then ()
        FunctionType(lhs, rhs) then go(lhs, tvs); go(rhs, tvs)
        RecordType(fields) then each(fields, p => if p is Pair(_, t) then go(t, tvs))
        TypeVariable(name, level, lb, ub) then
          getOrUpdate of tvs, name ~ toString(level), () =>
            region r2 in
              let tmp = empty(r2)
              iter of lb, it => foreach(it, ty => push(tmp, ty))
              iter of ub, it => foreach(it, ty => push(tmp, ty))
            t
          ()
    go(lhs, tvs); go(rhs, tvs)
    println("where: ")
    iterMap of tvs, it =>
      values of it, printBounds


region r in
  let ctx = mkHashMap(r, s => s)
  let lhs = FunctionType(IntType(), IntType())
  let rhs = IntType()
  solve(Cons(Pair(lhs, rhs), Nil()), (n, l) => freshVar(r, ctx, n, l), genHash(r), genExtrHash(r))
//│ > Cannot constrain Int -> Int <: Int!


region r in
  let ctx = mkHashMap(r, s => s)
  let lhs = FunctionType(IntType(), IntType())
  let a = freshVar(r, ctx, "a", 1)
  let rhs = FunctionType(a, a)
  solve(Cons(Pair(lhs, rhs), Nil()), (n, l) => freshVar(r, ctx, n, l), genHash(r), genExtrHash(r))
  printRes(lhs, rhs)
//│ > Int -> Int <: a_1 -> a_1
//│ > where: 
//│ >   Int <: a_1
//│ >   a_1 <: Int


region r in
  let ctx = mkHashMap(r, s => s)
  let lhs = RecordType(Cons(Pair("a", IntType()), Cons(Pair("b", FunctionType(IntType(), IntType())), Nil())))
  let a = freshVar(r, ctx, "a", 1)
  let b = freshVar(r, ctx, "b", 1)
  let rhs = RecordType(Cons(Pair("a", a), Cons(Pair("b", b), Nil())))
  solve(Cons(Pair(lhs, rhs), Nil()), (n, l) => freshVar(r, ctx, n, l), genHash(r), genExtrHash(r))
  printRes(lhs, rhs)
//│ > { a: Int, b: Int -> Int, } <: { a: a_1, b: b_1, }
//│ > where: 
//│ >   Int <: a_1
//│ >   Int -> Int <: b_1


region r in
  let ctx = mkHashMap(r, s => s)
  let a = freshVar(r, ctx, "a", 1)
  let b = freshVar(r, ctx, "b", 1)
  let lhs = a
  let rhs = b
  solve(Cons(Pair(lhs, rhs), Cons(Pair(rhs, lhs), Nil())), (n, l) => freshVar(r, ctx, n, l), genHash(r), genExtrHash(r))
  printRes(lhs, rhs)
  printRes(rhs, lhs)
//│ > a_1 <: b_1
//│ > where: 
//│ >   a_1 <: b_1
//│ >   b_1 <: a_1
//│ > b_1 <: a_1
//│ > where: 
//│ >   b_1 <: a_1
//│ >   a_1 <: b_1


region r in
  let ctx = mkHashMap(r, s => s)
  let lhs = RecordType(Cons(Pair("a", IntType()), Cons(Pair("b", FunctionType(IntType(), IntType())), Nil())))
  let b = freshVar(r, ctx, "b", 1)
  let rhs = RecordType(Cons(Pair("b", b), Nil()))
  solve(Cons(Pair(lhs, rhs), Nil()), (n, l) => freshVar(r, ctx, n, l), genHash(r), genExtrHash(r))
  printRes(lhs, rhs)
//│ > { a: Int, b: Int -> Int, } <: { b: b_1, }
//│ > where: 
//│ >   Int -> Int <: b_1


region r in
  let ctx = mkHashMap(r, s => s)
  let a = freshVar(r, ctx, "a", 1)
  let b = freshVar(r, ctx, "b", 1)
  let lhs = FunctionType(IntType(), a)
  let rhs = FunctionType(IntType(), b)
  if a is
    TypeVariable(_, _, _, ub) then push(ub, lhs)
    else error() // impossible
  if b is
    TypeVariable(_, _, lb, _) then push(lb, rhs)
    else error() // impossible
  solve(Cons(Pair(a, b), Nil()), (n, l) => freshVar(r, ctx, n, l), genHash(r), genExtrHash(r))
  printRes(a, b)
//│ > a_1 <: b_1
//│ > where: 
//│ >   a_1 <: Int -> a_1
//│ >   a_1 <: b_1
//│ >   Int -> b_1 <: b_1


region r in
  let ctx = mkHashMap(r, s => s)
  let a = freshVar(r, ctx, "a", 1)
  let lhs = a
  let rhs = FunctionType(IntType(), IntType())
  if a is
    TypeVariable(_, _, lb, ub) then push(lb, IntType())
    else error() // impossible
  solve(Cons(Pair(lhs, rhs), Nil()), (n, l) => freshVar(r, ctx, n, l), genHash(r), genExtrHash(r))
//│ > Cannot constrain Int <: Int -> Int!


region r in
  let ctx = mkHashMap(r, s => s)
  let a = freshVar(r, ctx, "a", 1)
  let b = freshVar(r, ctx, "b", 2)
  let lhs = FunctionType(IntType(), a)
  let rhs = FunctionType(IntType(), b)
  solve(Cons(Pair(lhs, rhs), Nil()), (n, l) => freshVar(r, ctx, n, l), genHash(r), genExtrHash(r))
  printRes(lhs, rhs)
//│ > Int -> a_1 <: Int -> b_2
//│ > where: 
//│ >   a_1 <: b'-_1
//│ >   b'-_1 <: b_2


region r in
  let ctx = mkHashMap(r, s => s)
  let a = freshVar(r, ctx, "a", 1)
  let b = freshVar(r, ctx, "a", 1)
  let lhs = a
  let rhs = b
  solve(Cons(Pair(lhs, rhs), Nil()), (n, l) => freshVar(r, ctx, n, l), genHash(r), genExtrHash(r))
  printRes(lhs, rhs)
//│ > a_1 <: a0_1
//│ > where: 
//│ >   a_1 <: a0_1


region r in
  let ctx = mkHashMap(r, s => s)
  let a = freshVar(r, ctx, "a", 1)
  let b = freshVar(r, ctx, "b", 2)
  let lhs = a
  let rhs = FunctionType(b, FunctionType(b, b))
  solve(Cons(Pair(lhs, rhs), Nil()), (n, l) => freshVar(r, ctx, n, l), genHash(r), genExtrHash(r))
  printRes(lhs, rhs)
//│ > a_1 <: b_2 -> b_2 -> b_2
//│ > where: 
//│ >   a_1 <: b'+_1 -> b'+_1 -> b'-_1
//│ >   b'-_1 <: b_2
//│ >   b_2 <: b'+_1


fun wrongSolve(constraints, freshVar, cache, genExtrCache) = if constraints is
  Nil() then ()
  Cons(c, cs) then if c is
    Pair(lhs, rhs) then hasOrUpdate of cache, c, () =>
      if lhs is
        IntType() then TODO()
        FunctionType(arg, res) then TODO()
        RecordType(flds) then TODO()
        TypeVariable(name, level, lb, ub) then
          if levelOf(rhs) <= level then
            push(ub, rhs)
            iter(lb, it => foreach(it, b => solve(Cons(Pair(b, rhs), Nil()), freshVar, cache, genExtrCache)))
            solve(cs, freshVar, cache, genExtrCache)
          else
            let rhs' = extrude(rhs, false, level, freshVar, genExtrCache())
            solve(Cons(Pair(lhs, rhs'), cs), freshVar, cache, genExtrCache)


:e
region r in
  let ctx = mkHashMap(r, s => s)
  let a = freshVar(r, ctx, "a", 1)
  let b = freshVar(r, ctx, "a", 1)
  let lhs = a
  let rhs = b
  wrongSolve(Cons(Pair(lhs, rhs), Nil()), (n, l) => freshVar(r, ctx, n, l), genHash(r), genExtrHash(r))
  printRes(lhs, rhs)
//│ > a_1 <: a0_1
//│ > where: 
//│ >   a_1 <: a0_1
//│ ╔══[ERROR] Type error in application with expected type 'constraints
//│ ║  l.586: 	  wrongSolve(Cons(Pair(lhs, rhs), Nil()), (n, l) => freshVar(r, ctx, n, l), genHash(r), genExtrHash(r))
//│ ║         	             ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  List[in ⊥ out 'A]  <:  'constraints
//│ ╟── because: cannot constrain  List[in ⊥ out 'A]  <:  List[in 'Cons out 'Cons1]
//│ ╟── because: cannot constrain  'A  <:  'Cons1
//│ ╟── because: cannot constrain  PairOf[in ⊥ out 'A1, in ⊥ out 'B]  <:  'Cons1
//│ ╟── because: cannot constrain  PairOf[in ⊥ out 'A1, in ⊥ out 'B]  <:  PairOf[in 'Pair out 'Pair1, in 'Pair2 out 'Pair3]
//│ ╟── because: cannot constrain  'A1  <:  'Pair1
//│ ╟── because: cannot constrain  'A2  <:  'Pair1
//│ ╟── because: cannot constrain  'A2  <:  Type[in 'TypeVariable out 'TypeVariable1]
//│ ╟── because: cannot constrain  'Some  <:  Type[in 'TypeVariable out 'TypeVariable1]
//│ ╟── because: cannot constrain  'A3  <:  Type[in 'TypeVariable out 'TypeVariable1]
//│ ╟── because: cannot constrain  Type[in ⊥ out 'R]  <:  Type[in 'TypeVariable out 'TypeVariable1]
//│ ╟── because: cannot constrain  'R  <:  'TypeVariable1
//│ ╟── because: cannot constrain  'R  <:  ⊥
//│ ╟── because: cannot constrain  'R1  <:  ⊥
//│ ╙── because: cannot constrain  r  <:  ⊥
//│ ╔══[ERROR] Type error in application with expected type 'constraints
//│ ║  l.586: 	  wrongSolve(Cons(Pair(lhs, rhs), Nil()), (n, l) => freshVar(r, ctx, n, l), genHash(r), genExtrHash(r))
//│ ║         	             ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  List[in ⊥ out 'A]  <:  'constraints
//│ ╟── because: cannot constrain  List[in ⊥ out 'A]  <:  List[in 'Cons out 'Cons1]
//│ ╟── because: cannot constrain  'A  <:  'Cons1
//│ ╟── because: cannot constrain  PairOf[in ⊥ out 'A1, in ⊥ out 'B]  <:  'Cons1
//│ ╟── because: cannot constrain  PairOf[in ⊥ out 'A1, in ⊥ out 'B]  <:  PairOf[in 'Pair out 'Pair1, in 'Pair2 out 'Pair3]
//│ ╟── because: cannot constrain  'B  <:  'Pair3
//│ ╟── because: cannot constrain  'A4  <:  'Pair3
//│ ╟── because: cannot constrain  'A4  <:  Type[in 'TypeVariable2 out 'TypeVariable3]
//│ ╟── because: cannot constrain  'Some1  <:  Type[in 'TypeVariable2 out 'TypeVariable3]
//│ ╟── because: cannot constrain  'A5  <:  Type[in 'TypeVariable2 out 'TypeVariable3]
//│ ╟── because: cannot constrain  Type[in ⊥ out 'R2]  <:  Type[in 'TypeVariable2 out 'TypeVariable3]
//│ ╟── because: cannot constrain  'R2  <:  'TypeVariable3
//│ ╟── because: cannot constrain  'R2  <:  'E
//│ ╟── because: cannot constrain  'R2  <:  'E1 ∨ 'S
//│ ╟── because: cannot constrain  ¬'E1 ∧ 'R2  <:  'S
//│ ╟── because: cannot constrain  ¬'E1 ∧ 'R2  <:  ⊥
//│ ╟── because: cannot constrain  'R2  <:  'E1
//│ ╟── because: cannot constrain  'R2  <:  ¬'R3
//│ ╟── because: cannot constrain  'R3  <:  ¬'R2
//│ ╟── because: cannot constrain  'R4  <:  ¬'R2
//│ ╟── because: cannot constrain  'TypeVariable1  <:  ¬'R2
//│ ╟── because: cannot constrain  'R5  <:  ¬'R2
//│ ╟── because: cannot constrain  'R2  <:  ¬'R5
//│ ╟── because: cannot constrain  'R6  <:  ¬'R5
//│ ╟── because: cannot constrain  r  <:  ¬'R5
//│ ╟── because: cannot constrain  'R5  <:  ¬r
//│ ╙── because: cannot constrain  r  <:  ¬r
//│ ╔══[ERROR] Type error in function literal with expected type 'freshVar
//│ ║  l.586: 	  wrongSolve(Cons(Pair(lhs, rhs), Nil()), (n, l) => freshVar(r, ctx, n, l), genHash(r), genExtrHash(r))
//│ ║         	                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  ('n, 'l) ->{'R7 ∨ 'R8 ∨ 'R9 ∨ 'R10 ∨ 'eff} (Type[in ⊥ out 'R11] ∨ 'A6 ∨ 'app)  <:  'freshVar
//│ ╟── because: cannot constrain  ('n, 'l) ->{'R7 ∨ 'R8 ∨ 'R9 ∨ 'R10 ∨ 'eff} (Type[in ⊥ out 'R11] ∨ 'A6 ∨ 'app)  <:  (Str, Int) ->{'R12} (Type[in ⊥ out 'R12])
//│ ╟── because: cannot constrain  Type[in ⊥ out 'R11] ∨ 'A6 ∨ 'app  <:  Type[in ⊥ out 'R12]
//│ ╟── because: cannot constrain  'R11  <:  'R12
//│ ╟── because: cannot constrain  r  <:  'R12
//│ ╟── because: cannot constrain  r  <:  'TypeVariable4
//│ ╟── because: cannot constrain  r  <:  'E2
//│ ╟── because: cannot constrain  r  <:  'E1 ∨ 'S1
//│ ╟── because: cannot constrain  ¬'E1 ∧ r  <:  'S1
//│ ╟── because: cannot constrain  ¬'E1 ∧ r  <:  ⊥
//│ ╟── because: cannot constrain  r  <:  'E1
//│ ╟── because: cannot constrain  r  <:  ¬'R3
//│ ╟── because: cannot constrain  'R3  <:  ¬r
//│ ╟── because: cannot constrain  'R4  <:  ¬r
//│ ╟── because: cannot constrain  'R13  <:  ¬r
//│ ╙── because: cannot constrain  r  <:  ¬r
//│ ╔══[ERROR] Type error in application with expected type 'cache
//│ ║  l.586: 	  wrongSolve(Cons(Pair(lhs, rhs), Nil()), (n, l) => freshVar(r, ctx, n, l), genHash(r), genExtrHash(r))
//│ ║         	                                                                            ^^^^^^^^^^
//│ ╟── because: cannot constrain  HashMap['K, 'V, in ⊥ out 'R14]  <:  'cache
//│ ╟── because: cannot constrain  HashMap['K, 'V, in ⊥ out 'R14]  <:  HashMap[in 'K1 out 'K2, in 'V1 out 'V2, in ⊥ out 'R15]
//│ ╟── because: cannot constrain  'R14  <:  'R15
//│ ╟── because: cannot constrain  r  <:  'R15
//│ ╟── because: cannot constrain  r  <:  'E1 ∨ 'S2
//│ ╟── because: cannot constrain  ¬'E1 ∧ r  <:  'S2
//│ ╟── because: cannot constrain  ¬'E1 ∧ r  <:  ⊥
//│ ╟── because: cannot constrain  r  <:  'E1
//│ ╟── because: cannot constrain  r  <:  ¬'R3
//│ ╟── because: cannot constrain  'R3  <:  ¬r
//│ ╟── because: cannot constrain  'R4  <:  ¬r
//│ ╟── because: cannot constrain  'R13  <:  ¬r
//│ ╙── because: cannot constrain  r  <:  ¬r
//│ ╔══[ERROR] Type error in application with expected type 'genExtrCache
//│ ║  l.586: 	  wrongSolve(Cons(Pair(lhs, rhs), Nil()), (n, l) => freshVar(r, ctx, n, l), genHash(r), genExtrHash(r))
//│ ║         	                                                                                        ^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  () ->{'R16} (HashMap['K3, 'V3, in ⊥ out 'R16])  <:  'genExtrCache
//│ ╟── because: cannot constrain  () ->{'R16} (HashMap['K3, 'V3, in ⊥ out 'R16])  <:  () ->{'eff1} ('app1)
//│ ╟── because: cannot constrain  HashMap['K3, 'V3, in ⊥ out 'R16]  <:  'app1
//│ ╟── because: cannot constrain  HashMap['K3, 'V3, in ⊥ out 'R16]  <:  HashMap[in PairOf[in ⊥ out Type[in ⊥ out 'R17], in ⊥ out PairOf[in ⊥ out Int, in ⊥ out Bool]] out PairOf[in ⊥ out Type[in ⊥ out 'R18], in ⊥ out PairOf[in ⊥ out Int, in ⊥ out Bool]], in Type[in ⊥ out 'R17] out Type[in ⊥ out 'R18], in ⊥ out 'R18]
//│ ╟── because: cannot constrain  'K3  <:  PairOf[in ⊥ out Type[in ⊥ out 'R18], in ⊥ out PairOf[in ⊥ out Int, in ⊥ out Bool]]
//│ ╟── because: cannot constrain  PairOf[in ⊥ out Type[in ⊥ out 'R17], in ⊥ out PairOf[in ⊥ out Int, in ⊥ out Bool]]  <:  PairOf[in ⊥ out Type[in ⊥ out 'R18], in ⊥ out PairOf[in ⊥ out Int, in ⊥ out Bool]]
//│ ╟── because: cannot constrain  Type[in ⊥ out 'R17]  <:  Type[in ⊥ out 'R18]
//│ ╟── because: cannot constrain  'R17  <:  'R18
//│ ╟── because: cannot constrain  'R17  <:  'TypeVariable5
//│ ╟── because: cannot constrain  'R17  <:  'E3
//│ ╟── because: cannot constrain  'R17  <:  'E1 ∨ 'S3
//│ ╟── because: cannot constrain  'R17 ∧ ¬'E1  <:  'S3
//│ ╟── because: cannot constrain  'R17 ∧ ¬'E1  <:  ⊥
//│ ╟── because: cannot constrain  'R17  <:  'E1
//│ ╟── because: cannot constrain  'R12  <:  'E1
//│ ╟── because: cannot constrain  'R19  <:  'E1
//│ ╟── because: cannot constrain  'R19  <:  ¬'R3
//│ ╟── because: cannot constrain  'R3  <:  ¬'R19
//│ ╟── because: cannot constrain  'R4  <:  ¬'R19
//│ ╟── because: cannot constrain  'R13  <:  ¬'R19
//│ ╟── because: cannot constrain  r  <:  ¬'R19
//│ ╟── because: cannot constrain  'R19  <:  ¬r
//│ ╙── because: cannot constrain  r  <:  ¬r
//│ ╔══[ERROR] Type error in application with expected type 'genExtrCache
//│ ║  l.586: 	  wrongSolve(Cons(Pair(lhs, rhs), Nil()), (n, l) => freshVar(r, ctx, n, l), genHash(r), genExtrHash(r))
//│ ║         	                                                                                        ^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  () ->{'R16} (HashMap['K3, 'V3, in ⊥ out 'R16])  <:  'genExtrCache
//│ ╟── because: cannot constrain  () ->{'R16} (HashMap['K3, 'V3, in ⊥ out 'R16])  <:  () ->{'eff1} ('app1)
//│ ╟── because: cannot constrain  HashMap['K3, 'V3, in ⊥ out 'R16]  <:  'app1
//│ ╟── because: cannot constrain  HashMap['K3, 'V3, in ⊥ out 'R16]  <:  HashMap[in PairOf[in ⊥ out Type[in ⊥ out 'R17], in ⊥ out PairOf[in ⊥ out Int, in ⊥ out Bool]] out PairOf[in ⊥ out Type[in ⊥ out 'R18], in ⊥ out PairOf[in ⊥ out Int, in ⊥ out Bool]], in Type[in ⊥ out 'R17] out Type[in ⊥ out 'R18], in ⊥ out 'R18]
//│ ╟── because: cannot constrain  'K3  <:  PairOf[in ⊥ out Type[in ⊥ out 'R18], in ⊥ out PairOf[in ⊥ out Int, in ⊥ out Bool]]
//│ ╟── because: cannot constrain  PairOf[in ⊥ out Type[in ⊥ out 'R17], in ⊥ out PairOf[in ⊥ out Int, in ⊥ out Bool]]  <:  PairOf[in ⊥ out Type[in ⊥ out 'R18], in ⊥ out PairOf[in ⊥ out Int, in ⊥ out Bool]]
//│ ╟── because: cannot constrain  Type[in ⊥ out 'R17]  <:  Type[in ⊥ out 'R18]
//│ ╟── because: cannot constrain  'R17  <:  'R18
//│ ╟── because: cannot constrain  'R17  <:  'TypeVariable5
//│ ╟── because: cannot constrain  'R17  <:  'E3
//│ ╟── because: cannot constrain  'R17  <:  'E1 ∨ 'S3
//│ ╟── because: cannot constrain  'R17 ∧ ¬'E1  <:  'S3
//│ ╟── because: cannot constrain  'R17 ∧ ¬'E1  <:  ⊥
//│ ╟── because: cannot constrain  'R17  <:  'E1
//│ ╟── because: cannot constrain  'R20  <:  'E1
//│ ╟── because: cannot constrain  'R13  <:  'E1
//│ ╟── because: cannot constrain  'R13  <:  ¬'R3
//│ ╟── because: cannot constrain  'R3  <:  ¬'R13
//│ ╟── because: cannot constrain  'R4  <:  ¬'R13
//│ ╟── because: cannot constrain  'R13  <:  ¬'R13
//│ ╟── because: cannot constrain  'R13  <:  ⊥
//│ ╙── because: cannot constrain  r  <:  ⊥


// * Paper example


region r in
  let xs = empty(r)
  xs
//│ = ArrayList([])
//│ Type: ArrayList['A, ?]

region r in
  let xs = empty(r)
  push(xs, "1")
  clear(xs)


region r in // This is used to delimit the scope of mutation
  let xs = empty(r)  // Creates a new mutable list in region r
  push(xs, "1"); push(xs, "2"); push(xs, "3")
  iter(xs, it => foreach(it, e => println(e)))
  clear(xs)
//│ > 1
//│ > 2
//│ > 3

:e
region r in // This is used to delimit the scope of mutation
  let xs = empty(r)  // Creates a new mutable list in region r
  push(xs, "1"); push(xs, "2"); push(xs, "3")
  iter(xs, it => foreach(it, e => println(e); clear(xs)))
//│ > 1
//│ > 2
//│ > 3
//│ ╔══[ERROR] Type error in function literal with expected type (Iter['T, out S]) ->{S ∨ 'E} 'Res
//│ ║  l.755: 	  iter(xs, it => foreach(it, e => println(e); clear(xs)))
//│ ║         	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  'R ∨ 'E1  <:  S ∨ 'E
//│ ╟── because: cannot constrain  'E1  <:  'E ∨ S
//│ ╟── because: cannot constrain  'R1  <:  'E ∨ S
//│ ╟── because: cannot constrain  ¬'S1 ∧ 'R1  <:  'E
//│ ╟── because: cannot constrain  ¬'S1 ∧ 'R1  <:  ¬'R2
//│ ╟── because: cannot constrain  'R2 ∧ 'R1  <:  'S1
//│ ╟── because: cannot constrain  'R2 ∧ 'R1  <:  ⊥
//│ ╟── because: cannot constrain  'R2  <:  ¬'R1
//│ ╟── because: cannot constrain  'R1  <:  ¬'R1
//│ ╟── because: cannot constrain  'R1  <:  ⊥
//│ ╙── because: cannot constrain  r  <:  ⊥



// ––––––––– TO IMPROVE LATER –––––––––

// TODO: simplify

fun test(x) = case
  IntType() then TODO()
  FunctionType(l1, r1) then TODO()
  RecordType(f) then TODO()
  TypeVariable(id, lvl, lbs, ubs) then clear(ubs)

test
//│ = [function test]
//│ Type: ['TypeVariable] -> ⊤ -> ((((Type[out 'TypeVariable] ∧ Type[?]) ∧ Type[?]) ∧ Type[?]) ->{'TypeVariable} ())





fun solve = case
  Nil then ()
  Cons(c, cs) then if c is
    Pair(lhs, rhs) then
      if lhs is
        IntType() then if rhs is
          IntType() then ()
          else error()
        FunctionType(l1, r1) then  if rhs is
          FunctionType(l2, r2) then
            solve(Cons(Pair(l2, l1), cs))
            solve(Cons(Pair(r1, r2), cs))
          else error()
        RecordType(f) then TODO()
        TypeVariable(id, lvl, lbs, ubs) then
          // Handle unification case here
          error() // Placeholder for unification logic


fun solve = case
  Nil then ()
  Cons(c, cs) and c is
    Pair(lhs, rhs) and lhs is
      IntType() and rhs is
        IntType() then ()
        else error()
      FunctionType(l1, r1) and rhs is
        FunctionType(l2, r2) then
          solve(Cons(Pair(l2, l1), cs))
          solve(Cons(Pair(r1, r2), cs))
        else error()
      RecordType(f) then TODO()
      TypeVariable(id, lvl, lbs, ubs) then
        // Handle unification case here
        error() // Placeholder for unification logic

solve
//│ = [function]
//│ Type: (List[out PairOf[out Type[?], out Type[?]]] ∧ List[?]) -> ()


