:js
:lift
:todo


// The following are problems with lifting functions inside other functions.


// Lifting functions with spread arguments is broken.
:expect [1]
fun f(x) =
  fun g(...rest) = 
    print(x)
    rest
  let a = g
  a(1)
f(2)
//│ > 2
//│ ═══[RUNTIME ERROR] Expected: '[1]', got: '[]'
//│ = []

// The following are problems with lifting classes inside other definitions.

// We use the optional `symbol` parameter of `Select` to detect references to the
// BlockMemberSymbol. But when this symbol is not present, there is no way to properly
// detect it.
// 
// The following could instead be lifted as:
//
// class B$(y)(a) with
//   fun getB() = a.x + y
// class A(x) with
//   fun B(y) = B$(y)(this)
//   set B.class = B // so that `new a.B(n)` still works
//   fun getA() = this.B(2).getB()
// A(1).getA()
//
// where B must be marked as final.
:expect 3
data class A(x) with
  data class B(y) with
    fun getB() = x + y
  fun getA() = this.B(2).getB()
A(1).getA()
//│ ═══[RUNTIME ERROR] TypeError: this.B is not a function
//│ ═══[RUNTIME ERROR] Expected: '3', got: 'undefined'

// This is due to the order of classes after lifting
class Test
fun hello() =
  class Test2 extends Test
  2
//│ ═══[RUNTIME ERROR] TypeError: Class extends value undefined is not a constructor or null

// This is due to subclasses not calling `super` with the required locals. The analysis to
// determine which locals are required is not in place yet.
:expect 2
fun test(x) =
  class A with
    fun get = x
  class B() extends A
  B().get
test(2)
//│ ═══[RUNTIME ERROR] Error: Access to required field 'get' yielded 'undefined'
//│ ═══[RUNTIME ERROR] Expected: '2', got: 'undefined'

/// The following are related to first-class classes, instance checks, and private fields. ///

:w
:expect 1
fun f(used1, unused1) =
  fun g(g_arg) =
    let used3 = 2
    fun h = used3
    used1 + h
  let unused2 = 2
  class Test(a) with
    fun get() = used1
  let foo = Test
  foo(unused1)
f(1, 2).get()
//│ ═══[WARNING] Cannot yet lift class `Test` as it is used as a first-class class.
//│ = 1


:todo
:w
fun foo(x, n) =
  class C()
  let res = if x is C then "Y" else "N"
  if n > 0 then res + foo(C(), n - 1) else ""
//│ ═══[WARNING] Cannot yet lift class/module `C` as it is used in an instance check.

:todo // should return the function that creates C instances
:w
fun foo() =
  class C()
  C
//│ ═══[WARNING] Cannot yet lift class `C` as it is used as a first-class class.

:w
fun foo() =
  class C()
  fun f = C()
  C
//│ ═══[WARNING] Cannot yet lift class `C` as it is used as a first-class class.

:todo
:expect "NN"
foo(0, 2)
//│ ═══[RUNTIME ERROR] Error: Function 'foo' expected 0 arguments but got 2
//│ ═══[RUNTIME ERROR] Expected: '"NN"', got: 'undefined'

// Since B extends A and A is not lifted, B cannot access A's BlockMemberSymbol. We can't lift B.
:todo
fun test(x) =
  class A with
    fun get = x
  class B() extends A
  0 is A
  B().get
test(2)
//│ ═══[WARNING] Cannot yet lift class/module `A` as it is used in an instance check.
//│ ═══[WARNING] Cannot yet lift class/module `B` as it extends an unliftable class.
//│ = 2

:expect 2
class A(a) with
  let x = 2
  fun f() =
    fun g() = x
    g()
A(2).f()
//│ ═══[COMPILATION ERROR] Uses of private fields cannot yet be lifted.
//│ ═══[RUNTIME ERROR] Error: MLscript call unexpectedly returned `undefined`, the forbidden value.
//│ ═══[RUNTIME ERROR] Expected: '2', got: 'undefined'

/// The following are related to modules and objects. ///

:todo
fun foo(x, y) =
  module M with
    val test = 2
    fun foo() =
      set y = 2
      x + y + test
  M.foo()
//│ ═══[WARNING] Modules are not yet lifted.

:expect 14
foo(10, 0)
//│ = 14

fun foo(x, y) =
  module M with
    fun foo() =
      set y = 2
      x + y
  fun foo = M.foo()
  foo
//│ ═══[WARNING] Modules are not yet lifted.
//│ /!!!\ Uncaught error: hkmc2.InternalError: Not in scope: member:M (class hkmc2.semantics.BlockMemberSymbol)

:expect 12
foo(10, 0)
//│ ═══[RUNTIME ERROR] ReferenceError: foo5 is not defined
//│ ═══[RUNTIME ERROR] Expected: '12', got: 'undefined'


data class A(x) with
  module M with
    fun getB() = x
  fun getA() = M.getB()
//│ ═══[WARNING] Modules are not yet lifted.

:expect 2
A(2).getA()
//│ = 2

// TODO: Foo needs to be put in a mutable capture. Also, we need to pass the Foo instance itself into Foo
fun foo(x) =
  object Foo with
    fun self1 = this
    fun self2 = Foo
  class Bar extends Foo
  (new Bar).self2
foo(2)
//│ /!!!\ Uncaught error: hkmc2.InternalError: Not in scope: Foo$ (class hkmc2.semantics.VarSymbol)

// `h` is lifted out, but then cannot access the BlockMemberSymbol M.
:fixme
fun f =
  module M with
    fun g =
      fun h = M.g
      h
  M.g
//│ ═══[WARNING] Modules are not yet lifted.
//│ /!!!\ Uncaught error: hkmc2.InternalError: Not in scope: member:M (class hkmc2.semantics.BlockMemberSymbol)
