:js
:todo


// ——— ——— ———

:fixme
while
    let arrMatches = true
    arrMatches
  do
    print(arrMatches)
//│ /!!!\ Uncaught error: scala.MatchError: InfixApp(IfLike(keyword 'while',None,Block(List(LetLike(keyword 'let',Ident(arrMatches),Some(BoolLit(true)),None), Ident(arrMatches)))),keyword 'do',Block(List(App(Ident(print),Tup(List(Ident(arrMatches))))))) (of class hkmc2.syntax.Tree$InfixApp)

// ——— ——— ———

let arrMatches = ()
//│ arrMatches = ()

// * Note: produces a match error
:fixme
if
  arrMatches !== null
  do
    ()
//│ ═══[ERROR] Unrecognized term split (null).
//│ ═══[RUNTIME ERROR] Error: match error

// * This one works:
if
  arrMatches !== null do
    ()

// ——— ——— ———

:fixme
if
  true and
  true do
    print("ok")
//│ /!!!\ Uncaught error: java.lang.Exception: Internal Error: infix on newline at Ln 2 Col 11:Ln 2 Col 11

if
  true and
    true do
      print("ok")
//│ > ok

:fixme
if
  true
  and
  true do
    print("ok")
//│ /!!!\ Uncaught error: java.lang.Exception: Internal Error: infix on newline at Ln 3 Col 6:Ln 3 Col 6

if
  true
  and true do
    print("ok")
//│ > ok

if
  true
  and true
  and true do
    print("ok")
//│ > ok

:fixme
if
  true
  and true
  let x = 1
  and true do
    print("ok")
//│ /!!!\ Uncaught error: scala.MatchError: InfixApp(InfixApp(IntLit(1),keyword 'and',BoolLit(true)),keyword 'do',Block(List(App(Ident(print),Tup(List(StrLit(ok))))))) (of class hkmc2.syntax.Tree$InfixApp)

// ——— ——— ———

// * Example confusing parses that should be fixed when we fix the parsing of operator splits

if 1 + 0
    == 0 then "X"
    == 1 then "A"
//│ = "A"

if 1 + 1
    * 2 == 4 then "X"
    * 2 == 1 then "A"
    |> id is r then r
//│ = 2

// ——— ——— ———

class Some(val v)

Some(1) is
  Some of [process, rest] do "hi"
//│ ╔══[ERROR] Unrecognized pattern (infix operator)
//│ ║  l.99: 	  Some of [process, rest] do "hi"
//│ ╙──      	          ^^^^^^^^^^^^^^^^^^^^^^^
//│ = false

// ——— ——— ———

class Some(val v)
object None

// :ucs normalized
// Uncomment the line above to see the explosion: ~1200 lines of code.
// If the number of branches continues to increase, the time duration of
// compilation will noticeably slow down.
fun parse(text: Str): [Int, Str] =
  fun char(idx: Int) = if idx < text.length then
    Some of text.charAt of idx
  else
    None
  
  // Some helper parsing utilities.
  fun a(idx: Int): [Int, Str] = ???
  fun b(idx: Int): [Int, Str] = ???
  fun c(idx: Int): [Int, Str] = ???
  fun d(idx: Int): [Int, Str] = ???
  fun e(idx: Int): [Int, Str] = ???
  fun f(idx: Int): [Int, Str] = ???
  fun g(idx: Int): [Int, Str] = ???
  
  // Note: Use `is` instead `==` can mitigate the explosion. Because the
  // specialization knows those literal string patterns are disjoint.
  fun launch(idx: Int) = if char(idx) is Some(ch) and ch ==
    "a" and a(idx + 1) is [idx', res] then ???
    "b" and b(idx + 1) is [idx', res'] then ???
    "c" and c(idx + 1) is [idx', res''] then ???
    "d" and d(idx + 1) is [idx', res'''] then ???
    "e" and e(idx + 1) is [idx', res''''] then ???
    "f" and f(idx + 1) is [idx', res'''''] then ???
    "g" and g(idx + 1) is [idx', res'''''''] then ???
    else [idx, ""]
  
  launch(0)

// ——— ——— ———

data class Tuple(a, b, c)

let foo =
  case
    Tuple(...elements) then elements
//│ ╔══[ERROR] mismatched arity: expect 3, found 1
//│ ║  l.149: 	    Tuple(...elements) then elements
//│ ╙──       	    ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Unrecognized pattern (spread)
//│ ║  l.149: 	    Tuple(...elements) then elements
//│ ╙──       	             ^^^^^^^^
//│ foo = [function]

foo(Tuple(1, 2, 3))
//│ ═══[RUNTIME ERROR] Error: match error

// ——— ——— ———

module Foo with
  class
    Bar
    Baz

fun foo(x) = if x is Foo.
  Bar then "Bar"
  Foo then "Foo"
//│ ╔══[ERROR] Unrecognized pattern split.
//│ ║  l.168: 	fun foo(x) = if x is Foo.
//│ ╙──       	                     ^^^
//│ ╔══[ERROR] Cannot use this identifier as an extractor
//│ ║  l.168: 	fun foo(x) = if x is Foo.
//│ ╙──       	                        ^
//│ ╔══[ERROR] Cannot use this identifier as an extractor
//│ ║  l.168: 	fun foo(x) = if x is Foo.
//│ ╙──       	                        ^

fun foo(x) = if x is Foo
  .Bar then "Bar"
  .Foo then "Foo"
//│ ╔══[PARSE ERROR] Expected an expression; found selector instead
//│ ║  l.182: 	  .Bar then "Bar"
//│ ╙──       	  ^^^^
//│ ╔══[PARSE ERROR] Unexpected selector here
//│ ║  l.182: 	  .Bar then "Bar"
//│ ╙──       	  ^^^^
//│ ╔══[ERROR] Unrecognized pattern split.
//│ ║  l.181: 	fun foo(x) = if x is Foo
//│ ║         	                     ^^^
//│ ║  l.182: 	  .Bar then "Bar"
//│ ╙──       	^^

// ——— ——— ———

