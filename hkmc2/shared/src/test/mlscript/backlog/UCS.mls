:js
:todo


// ——— ——— ———

:fixme
while
    let arrMatches = true
    arrMatches
  do
    print(arrMatches)
//│ /!!!\ Uncaught error: scala.MatchError: InfixApp(IfLike(keyword 'while',None,Block(List(LetLike(keyword 'let',Ident(arrMatches),Some(BoolLit(true)),None), Ident(arrMatches)))),keyword 'do',Block(List(App(Ident(print),Tup(List(Ident(arrMatches))))))) (of class hkmc2.syntax.Tree$InfixApp)

// ——— ——— ———

let arrMatches = ()

// * Note: produces a match error
:fixme
if
  arrMatches !== null
  do
    ()
//│ ═══[ERROR] Unrecognized term split (null).
//│ ═══[RUNTIME ERROR] Error: match error

// * This one works:
if
  arrMatches !== null do
    ()

// ——— ——— ———

:fixme
if
  true and
  true do
    print("ok")
//│ /!!!\ Uncaught error: scala.NotImplementedError: infix on newline at Ln 2 Col 11:Ln 2 Col 11

if
  true and
    true do
      print("ok")
//│ > ok

:fixme
if
  true
  and
  true do
    print("ok")
//│ /!!!\ Uncaught error: scala.NotImplementedError: infix on newline at Ln 3 Col 6:Ln 3 Col 6

if
  true
  and true do
    print("ok")
//│ > ok

if
  true
  and true
  and true do
    print("ok")
//│ > ok

:fixme
if
  true
  and true
  let x = 1
  and true do
    print("ok")
//│ /!!!\ Uncaught error: scala.MatchError: InfixApp(InfixApp(IntLit(1),keyword 'and',BoolLit(true)),keyword 'do',Block(List(App(Ident(print),Tup(List(StrLit(ok))))))) (of class hkmc2.syntax.Tree$InfixApp)

// ——— ——— ———

let audits = new Set()
//│ audits = Set{}

:fixme
if audits.has(1) === true do
  print("ok")
else
  1
//│ ╔══[ERROR] The following branches are unreachable.
//│ ╟── Because the previous split is full.
//│ ║  l.84: 	if audits.has(1) === true do
//│ ║        	   ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.85: 	  print("ok")
//│ ╙──      	^^^^^^^^^^^^^
//│ = 1

// ——— ——— ———

// * Example confusing parses that should be fixed when we fix the parsing of operator splits

if 1 + 0
    == 0 then "X"
    == 1 then "A"
//│ = "A"

if 1 + 1
    * 2 == 4 then "X"
    * 2 == 1 then "A"
    |> id is r then r
//│ = 2

// ——— ——— ———

class Some(v)

Some(1) is
  Some of [process, rest] do "hi"
//│ ╔══[ERROR] Unrecognized pattern (infix operation)
//│ ║  l.116: 	  Some of [process, rest] do "hi"
//│ ╙──       	          ^^^^^^^^^^^^^^^^^^^^^^^
//│ = false

// ——— ——— ———

object None

// :ucs normalized
// Uncomment the line above to see the explosion: ~1200 lines of code.
// If the number of branches continues to increase, the time duration of
// compilation will noticeably slow down.
fun parse(text: Str): [Int, Str] =
  fun char(idx: Int) = if idx < text.length then
    Some of text.charAt of idx
  else
    None
  
  // Some helper parsing utilities.
  fun a(idx: Int): [Int, Str] = ???
  fun b(idx: Int): [Int, Str] = ???
  fun c(idx: Int): [Int, Str] = ???
  fun d(idx: Int): [Int, Str] = ???
  fun e(idx: Int): [Int, Str] = ???
  fun f(idx: Int): [Int, Str] = ???
  fun g(idx: Int): [Int, Str] = ???
  
  // Note: Use `is` instead `==` can mitigate the explosion. Because the
  // specialization knows those literal string patterns are disjoint.
  fun launch(idx: Int) = if char(idx) is Some(ch) and ch ==
    "a" and a(idx + 1) is [idx', res] then ???
    "b" and b(idx + 1) is [idx', res'] then ???
    "c" and c(idx + 1) is [idx', res''] then ???
    "d" and d(idx + 1) is [idx', res'''] then ???
    "e" and e(idx + 1) is [idx', res''''] then ???
    "f" and f(idx + 1) is [idx', res'''''] then ???
    "g" and g(idx + 1) is [idx', res'''''''] then ???
    else [idx, ""]
  
  launch(0)
