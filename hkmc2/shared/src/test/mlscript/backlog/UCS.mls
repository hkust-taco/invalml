:js
:todo


// ——— ——— ———

:fixme
while
    let arrMatches = true
    arrMatches
  do
    print(arrMatches)
//│ /!!!\ Uncaught error: scala.MatchError: InfixApp(IfLike(keyword 'while',None,Block(List(LetLike(keyword 'let',Ident(arrMatches),Some(BoolLit(true)),None), Ident(arrMatches)))),keyword 'do',Block(List(App(Ident(print),Tup(List(Ident(arrMatches))))))) (of class hkmc2.syntax.Tree$InfixApp)

// ——— ——— ———

let arrMatches = ()
//│ arrMatches = ()

// * Note: produces a match error
:fixme
if
  arrMatches !== null
  do
    ()
//│ ═══[ERROR] Unrecognized term split (null).
//│ ═══[RUNTIME ERROR] Error: match error

// * This one works:
if
  arrMatches !== null do
    ()

// ——— ——— ———

if
  true and
  true do
    print("ok")
//│ > ok

if
  true and
  false do
    print("ok")

if
  true and
    true do
      print("ok")
//│ > ok

:fixme
if
  true
  and
  true do
    print("ok")
//│ ╔══[PARSE ERROR] Expected start of expression in this position; found new line instead
//│ ║  l.56: 	  and
//│ ║        	     ^
//│ ║  l.57: 	  true do
//│ ╙──      	^^
//│ ╔══[ERROR] Unrecognized term split (‹erroneous syntax›).
//│ ║  l.56: 	  and
//│ ║        	     ^
//│ ║  l.57: 	  true do
//│ ╙──      	^^
//│ > ok

if
  true
  and true do
    print("ok")
//│ > ok

if
  true
  and true
  and true do
    print("ok")
//│ > ok

:fixme
if
  true
  and true
  let x = 1
  and true do
    print("ok")
//│ /!!!\ Uncaught error: scala.MatchError: InfixApp(InfixApp(IntLit(1),keyword 'and',BoolLit(true)),keyword 'do',Block(List(App(Ident(print),Tup(List(StrLit(ok))))))) (of class hkmc2.syntax.Tree$InfixApp)

// ——— ——— ———

// * Example confusing parses that should be fixed when we fix the parsing of operator splits

if 1 + 0
    == 0 then "X"
    == 1 then "A"
//│ = "A"

if 1 + 1
    * 2 == 4 then "X"
    * 2 == 1 then "A"
    |> id is r then r
//│ ╔══[PARSE ERROR] Operator cannot be used inside this operator split
//│ ║  l.103: 	    * 2 == 4 then "X"
//│ ║         	        ^^
//│ ╟── as it has lower precedence than the splitting operator here
//│ ║  l.103: 	    * 2 == 4 then "X"
//│ ╙──       	    ^
//│ ╔══[PARSE ERROR] Unexpected literal in this operator split inner position
//│ ║  l.103: 	    * 2 == 4 then "X"
//│ ║         	           ^
//│ ╟── Note: the operator split starts here
//│ ║  l.103: 	    * 2 == 4 then "X"
//│ ╙──       	    ^
//│ ╔══[PARSE ERROR] Expected end of input; found literal instead
//│ ║  l.103: 	    * 2 == 4 then "X"
//│ ╙──       	           ^
//│ ═══[ERROR] Unrecognized term split (reference term).
//│ ╔══[ERROR] Unrecognized term split (integer literal).
//│ ║  l.103: 	    * 2 == 4 then "X"
//│ ╙──       	      ^
//│ ═══[RUNTIME ERROR] Error: match error

// ——— ——— ———

class Some(val v)

Some(1) is
  Some of [process, rest] do "hi"
//│ ╔══[ERROR] Unrecognized pattern (infix operator)
//│ ║  l.132: 	  Some of [process, rest] do "hi"
//│ ╙──       	          ^^^^^^^^^^^^^^^^^^^^^^^
//│ = false

// ——— ——— ———

class Some(val v)
object None

// :ucs normalized
// Uncomment the line above to see the explosion: ~1200 lines of code.
// If the number of branches continues to increase, the time duration of
// compilation will noticeably slow down.
fun parse(text: Str): [Int, Str] =
  fun char(idx: Int) = if idx < text.length then
    Some of text.charAt of idx
  else
    None
  
  // Some helper parsing utilities.
  fun a(idx: Int): [Int, Str] = ???
  fun b(idx: Int): [Int, Str] = ???
  fun c(idx: Int): [Int, Str] = ???
  fun d(idx: Int): [Int, Str] = ???
  fun e(idx: Int): [Int, Str] = ???
  fun f(idx: Int): [Int, Str] = ???
  fun g(idx: Int): [Int, Str] = ???
  
  // Note: Use `is` instead `==` can mitigate the explosion. Because the
  // specialization knows those literal string patterns are disjoint.
  fun launch(idx: Int) = if char(idx) is Some(ch) and ch ==
    "a" and a(idx + 1) is [idx', res] then ???
    "b" and b(idx + 1) is [idx', res'] then ???
    "c" and c(idx + 1) is [idx', res''] then ???
    "d" and d(idx + 1) is [idx', res'''] then ???
    "e" and e(idx + 1) is [idx', res''''] then ???
    "f" and f(idx + 1) is [idx', res'''''] then ???
    "g" and g(idx + 1) is [idx', res'''''''] then ???
    else [idx, ""]
  
  launch(0)

// ——— ——— ———

data class Tuple(a, b, c)

let foo =
  case
    Tuple(...elements) then elements
//│ ╔══[ERROR] Unrecognized pattern (spread)
//│ ║  l.182: 	    Tuple(...elements) then elements
//│ ╙──       	             ^^^^^^^^
//│ ╔══[ERROR] mismatched arity: expect 3, found 1
//│ ║  l.182: 	    Tuple(...elements) then elements
//│ ╙──       	             ^^^^^^^^
//│ foo = [function foo]

foo(Tuple(1, 2, 3))
//│ ═══[RUNTIME ERROR] Error: match error

// ——— ——— ———

module Foo with
  class
    Bar
    Baz

fun foo(x) = if x is Foo.
  Bar then "Bar"
  Foo then "Foo"
//│ ╔══[ERROR] Unrecognized pattern split (operator application).
//│ ║  l.201: 	fun foo(x) = if x is Foo.
//│ ║         	                     ^^^^
//│ ║  l.202: 	  Bar then "Bar"
//│ ╙──       	^^

fun foo(x) = if x is Foo
  .Bar then "Bar"
  .Foo then "Foo"
//│ /!!!\ Uncaught error: scala.MatchError: OpSplit(Ident(Foo),List(InfixApp(Sel(SplitPoint(),Ident(Bar)),keyword 'then',StrLit(Bar)), InfixApp(Sel(SplitPoint(),Ident(Foo)),keyword 'then',StrLit(Foo)))) (of class hkmc2.syntax.Tree$OpSplit)

// ——— ——— ———

