:js
:todo


// ——— ——— ———

"a" +
  "b"
//│ = "ab"

// FIXME
"a" +
  // a
"b"
//│ = "b"

// FIXME
// :dp
"a" +
// a
"b"
//│ ╔══[PARSE ERROR] Expected start of statement in this position; found new line instead
//│ ║  l.20: 	// a
//│ ║        	    ^
//│ ║  l.21: 	"b"
//│ ╙──      	

// ——— ——— ———

true or true
//│ /!!!\ Uncaught error: scala.MatchError: InfixApp(BoolLit(true),keyword 'or',BoolLit(true)) (of class hkmc2.syntax.Tree$InfixApp)

:fixme
while false or false do print("ok")
//│ /!!!\ Uncaught error: scala.MatchError: InfixApp(BoolLit(false),keyword 'or',BoolLit(false)) (of class hkmc2.syntax.Tree$InfixApp)

// ——— ——— ———

:e
fun (**) f1(a, b) = "[" + a + " * " + b + "]"
fun (**) f2(a, b) = "(" + a + " + " + b + ")"

1 ** 2
//│ = "(1 + 2)"

// FIXME error is duplicated & refers to wrong name
:e
fun (**) t() = 0
fun (++) t() = 1
//│ ╔══[ERROR] Multiple definitions of symbol '**'
//│ ╟── defined here
//│ ║  l.48: 	fun (**) t() = 0
//│ ║        	    ^^^^^^^^^^^^
//│ ╟── defined here
//│ ║  l.49: 	fun (++) t() = 1
//│ ╙──      	    ^^^^^^^^^^^^
//│ ╔══[ERROR] Multiple definitions of symbol '++'
//│ ╟── defined here
//│ ║  l.48: 	fun (**) t() = 0
//│ ║        	    ^^^^^^^^^^^^
//│ ╟── defined here
//│ ║  l.49: 	fun (++) t() = 1
//│ ╙──      	    ^^^^^^^^^^^^
//│ ╔══[ERROR] Multiple definitions of symbol 't'
//│ ╟── defined here
//│ ║  l.48: 	fun (**) t() = 0
//│ ║        	    ^^^^^^^^^^^^
//│ ╟── defined here
//│ ║  l.49: 	fun (++) t() = 1
//│ ╙──      	    ^^^^^^^^^^^^

// ——— ——— ———

let g = [0]
//│ g = [0]

:fixme
set g.0 += 1 // FIXME
//│ /!!!\ Uncaught error: scala.MatchError: LetLike(keyword 'set',App(Ident(+=),Tup(List(Sel(Ident(g),Ident(0)), IntLit(1)))),None,None) (of class hkmc2.syntax.Tree$LetLike)

:fixme
set g.0 = g.0 + 1
//│ > let selRes, discarded, tmp1;try { selRes = g[0]; discarded = g["0$__checkNotMethod"]; if (selRes === undefined) {   throw new this.Error("Access to required field '0' yielded 'undefined'"); } tmp1 = selRes + 1; g.0 = tmp1; block$res8 = runtime.Unit; undefined } catch (e) { console.log('\u200B' + e + '\u200B'); }
//│ >                                                                                                                                                                                                                     ^^
//│ ═══[COMPILATION ERROR] [Uncaught SyntaxError] Unexpected number

// ——— ——— ———

:todo // TODO instrument Predef
:re
id(1, 2)
//│ ╔══[ERROR] Expected 1 arguments, got 2
//│ ║  l.91: 	id(1, 2)
//│ ╙──      	^^
//│ = 1

// ——— ——— ———

:todo // TODO confusing formatting should not be allowed
:e
let x = if true
then 1
else 0
//│ x = 1

// ——— ——— ———

// TODO we should give reasonable meaning to `==`
//  notably taking into account arrays and data classes;
//  and deprecated `===` (notably does not work for arrays)

undefined == null
//│ = true

undefined === null
//│ = false

// ——— ——— ———

Infinity
//│ = Infinity

:sjs
val Infinity = 1
//│ JS (unsanitized):
//│ let Infinity; Infinity = 1;
//│ ═══[COMPILATION ERROR] [Uncaught SyntaxError] Identifier 'Infinity' has already been declared
//│ Infinity = Infinity

:sjs
Infinity
//│ JS (unsanitized):
//│ Infinity
//│ = Infinity

module Test with
  val Infinity = 1

Test.Infinity
//│ = 1

// ——— ——— ———

fun f(a)(b) = [a, b]
fun g(a, b) = [a, b]

// TODO support?
:pe
f of
    g of
      1
      2
  of 3
//│ ╔══[PARSE ERROR] Expected end of input; found indented block instead
//│ ║  l.153: 	  of 3
//│ ╙──       	^^
//│ = [function]

(f of
  g of
    1
    2
) of 3
//│ = [[1, 2], 3]

// ——— ——— ———

fun p: Int

:fixme // make this a proper error
p
//│ /!!!\ Uncaught error: hkmc2.InternalError: Not in scope: member:p (class hkmc2.semantics.BlockMemberSymbol)


:ctx
fun (++) test: (Int, Int) -> Int
//│ Env:
//│   ++ -> RefElem(member:test)
//│   test -> RefElem(member:test)

test(1, 2)
//│ /!!!\ Uncaught error: hkmc2.InternalError: Not in scope: member:test (class hkmc2.semantics.BlockMemberSymbol)

:sjs
1 ++ 1
//│ /!!!\ Uncaught error: hkmc2.InternalError: Not in scope: member:test (class hkmc2.semantics.BlockMemberSymbol)

// ——— ——— ———

// TODO forbid declarations inside local blocks
:todo
:e
fun main() =
  declare fun foo: Int
  ()

// TODO forbid unimplemented signatures inside local blocks
:todo
:e
fun main() =
  fun bar: Int
  ()

// ——— ——— ———

// * Objects should not be allowed to have parameters...
// * Or these parameters should have default values.

:sjs
data object Cls(x) with
  fun huh = x
//│ JS (unsanitized):
//│ let Cls1;
//│ const Cls$class = class Cls {
//│   constructor(x1) {
//│     this.x = x1;
//│   }
//│   get huh() {
//│     return this.x;
//│   }
//│   toString() { return "Cls(" + globalThis.Predef.render(this.x) + ")"; }
//│ }; Cls1 = new Cls$class;
//│ Cls1.class = Cls$class;

:e
Cls.x
//│ ╔══[ERROR] Object 'Cls' does not contain member 'x'
//│ ║  l.226: 	Cls.x
//│ ╙──       	   ^^
//│ ═══[RUNTIME ERROR] Error: Access to required field 'x' yielded 'undefined'

:fixme
Cls.huh
//│ ═══[RUNTIME ERROR] Error: Access to required field 'huh' yielded 'undefined'

let c = new Cls(123)
//│ c = Cls(123)

c.x
//│ = 123

// ——— ——— ———

class Foo' with
  class Bar'
//│ > let Foo$_1;try { Foo$_1 = class Foo$_ {   constructor() {     this.Bar' = class Bar$_ {       constructor() {}       toString() { return "Bar'"; }     };   }   toString() { return "Foo'"; } }; block$res32 = undefined; } catch (e) { console.log('\u200B' + e + '\u200B'); }
//│ >                                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ═══[COMPILATION ERROR] [Uncaught SyntaxError] Unexpected string

// ——— ——— ———

module Example with
// whoops
  val a = this
//│ ╔══[PARSE ERROR] Expected block after type declaration body; found new line instead
//│ ║  l.252: 	module Example with
//│ ║         	                   ^
//│ ║  l.253: 	// whoops
//│ ╙──       	
//│ ╔══[PARSE ERROR] Expected an expression; found block instead
//│ ║  l.254: 	  val a = this
//│ ╙──       	  ^
//│ ╔══[PARSE ERROR] Expected end of input; found indented block instead
//│ ║  l.254: 	  val a = this
//│ ╙──       	^^

// ——— ——— ———

:fixme // ("Not in scope" error)
let xs = new Oopsie
//│ ╔══[ERROR] Name not found: Oopsie
//│ ║  l.270: 	let xs = new Oopsie
//│ ╙──       	             ^^^^^^
//│ /!!!\ Uncaught error: hkmc2.InternalError: Not in scope: xs (class hkmc2.semantics.VarSymbol)

// ——— ——— ———

:todo // TODO: warn against using `undefined`
:w
fun oops = undefined

:re
oops
//│ ═══[RUNTIME ERROR] Error: MLscript call unexpectedly returned `undefined`, the forbidden value.

// ——— ——— ———

// TODO prevent explicit accesses to Unit, Int etc. from Prelude or elaborate them

Unit
//│ ═══[RUNTIME ERROR] Error: Access to required field 'Unit' yielded 'undefined'

Int
//│ ═══[RUNTIME ERROR] Error: Access to required field 'Int' yielded 'undefined'

// ——— ——— ———

class C

:sjs
class D extends id(C)
//│ JS (unsanitized):
//│ let D1;
//│ D1 = class D extends Predef.id.class {
//│   constructor() {
//│     super(C1);
//│   }
//│   toString() { return "D"; }
//│ };
//│ ═══[RUNTIME ERROR] TypeError: Class extends value undefined is not a constructor or null

// ——— ——— ———

let x = 0
//│ x = 0

set x += 1; ()
//│ /!!!\ Uncaught error: scala.MatchError: LetLike(keyword 'set',App(Ident(;),Tup(List(App(Ident(+=),Tup(List(Ident(x), IntLit(1)))), Unt()))),None,None) (of class hkmc2.syntax.Tree$LetLike)

[x, set x += 1; x]
//│ /!!!\ Uncaught error: scala.MatchError: LetLike(keyword 'set',App(Ident(;),Tup(List(App(Ident(+=),Tup(List(Ident(x), IntLit(1)))), Ident(x)))),None,None) (of class hkmc2.syntax.Tree$LetLike)

// ——— ——— ———

// TODO `baz()` should be in tail position (this is due to its by-name nature)
:sjs
fun baz = 1
fun bar() = baz
//│ JS (unsanitized):
//│ let bar, baz;
//│ baz = function baz() {
//│   return 1
//│ };
//│ bar = function bar() {
//│   let tmp10;
//│   tmp10 = baz();
//│   return tmp10
//│ };

// ——— ——— ———

import "../../mlscript-compile/Stack.mls"

// The parser rejects this, but it should be allowed.
open Stack { ::, Nil }
//│ ╔══[PARSE ERROR] Expected start of statement in this position; found comma instead
//│ ║  l.345: 	open Stack { ::, Nil }
//│ ╙──       	               ^
//│ ╔══[PARSE ERROR] Unexpected comma in this position
//│ ║  l.345: 	open Stack { ::, Nil }
//│ ╙──       	               ^
//│ ╔══[PARSE ERROR] Unexpected identifier here
//│ ║  l.345: 	open Stack { ::, Nil }
//│ ╙──       	                 ^^^
//│ ╔══[ERROR] Illegal 'open' statement shape.
//│ ║  l.345: 	open Stack { ::, Nil }
//│ ╙──       	     ^^^^^^^^^^^

// Instead, if we parenthesize the operator, it is rejected by the elaborator.
open Stack { (::), Nil }
//│ ╔══[ERROR] Illegal 'open' statement element.
//│ ║  l.360: 	open Stack { (::), Nil }
//│ ╙──       	             ^^^^

open Stack { Nil, :: }

:sjs
1 :: Nil
//│ JS (unsanitized):
//│ Stack["::"](1, Stack.Nil)
//│ ═══[RUNTIME ERROR] TypeError: Stack.:: is not a function

// ——— ——— ———

mkStr of ... // hello
"oops"
//│ ╔══[PARSE ERROR] Expected start of statement in this position; found new line instead
//│ ║  l.375: 	mkStr of ... // hello
//│ ║         	                     ^
//│ ║  l.376: 	"oops"
//│ ╙──       	
//│ = "oops"

// ——— ——— ———

set [].0 = 1
//│ > try { [].0 = 1; block$res49 = runtime.Unit; undefined } catch (e) { console.log('\u200B' + e + '\u200B'); }
//│ >         ^^
//│ ═══[COMPILATION ERROR] [Uncaught SyntaxError] Unexpected number

let arr = []
set arr.0 = 1
//│ > let arr;try { arr = []; arr.0 = 1; block$res50 = runtime.Unit; undefined } catch (e) { console.log('\u200B' + e + '\u200B'); }
//│ >                            ^^
//│ ═══[COMPILATION ERROR] [Uncaught SyntaxError] Unexpected number
//│ ═══[RUNTIME ERROR] ReferenceError: arr is not defined

// ——— ——— ———

data class Foo(x, y)

// TODO missing sanity check
Foo(1)
//│ = Foo(1, undefined)

// ——— ——— ———

