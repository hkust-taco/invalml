:js
:todo


// ——— ——— ———

"a" +
  "b"
//│ = "ab"

// FIXME
"a" +
  // a
"b"
//│ = "b"

// FIXME
// :dp
"a" +
// a
"b"
//│ ╔══[PARSE ERROR] Expected start of statement in this position; found new line instead
//│ ║  l.20: 	// a
//│ ║        	    ^
//│ ║  l.21: 	"b"
//│ ╙──      	

// ——— ——— ———

true or true
//│ /!!!\ Uncaught error: scala.MatchError: InfixApp(BoolLit(true),keyword 'or',BoolLit(true)) (of class hkmc2.syntax.Tree$InfixApp)

:fixme
while false or false do print("ok")
//│ /!!!\ Uncaught error: scala.MatchError: InfixApp(BoolLit(false),keyword 'or',BoolLit(false)) (of class hkmc2.syntax.Tree$InfixApp)

// ——— ——— ———

:e
fun (**) f1(a, b) = "[" + a + " * " + b + "]"
fun (**) f2(a, b) = "(" + a + " + " + b + ")"

1 ** 2
//│ = "(1 + 2)"

// FIXME error is duplicated & refers to wrong name
:e
fun (**) t() = 0
fun (++) t() = 1
//│ ╔══[ERROR] Multiple definitions of symbol '**'
//│ ╟── defined here
//│ ║  l.48: 	fun (**) t() = 0
//│ ║        	    ^^^^^^^^^^^^
//│ ╟── defined here
//│ ║  l.49: 	fun (++) t() = 1
//│ ╙──      	    ^^^^^^^^^^^^
//│ ╔══[ERROR] Multiple definitions of symbol '++'
//│ ╟── defined here
//│ ║  l.48: 	fun (**) t() = 0
//│ ║        	    ^^^^^^^^^^^^
//│ ╟── defined here
//│ ║  l.49: 	fun (++) t() = 1
//│ ╙──      	    ^^^^^^^^^^^^
//│ ╔══[ERROR] Multiple definitions of symbol 't'
//│ ╟── defined here
//│ ║  l.48: 	fun (**) t() = 0
//│ ║        	    ^^^^^^^^^^^^
//│ ╟── defined here
//│ ║  l.49: 	fun (++) t() = 1
//│ ╙──      	    ^^^^^^^^^^^^

// ——— ——— ———

let g = [0]
//│ g = [0]

:fixme
set g.0 += 1 // FIXME
//│ /!!!\ Uncaught error: scala.MatchError: LetLike(keyword 'set',App(Ident(+=),Tup(List(Sel(Ident(g),Ident(0)), IntLit(1)))),None,None) (of class hkmc2.syntax.Tree$LetLike)

set g.0 = g.0 + 1

// ——— ——— ———

:todo // TODO instrument Predef
:re
id(1, 2)
//│ ╔══[ERROR] Expected 1 arguments, got 2
//│ ║  l.87: 	id(1, 2)
//│ ╙──      	  ^^^^^^
//│ = 1

// ——— ——— ———

:todo // TODO confusing formatting should not be allowed
:e
let x = if true
then 1
else 0
//│ x = 1

// ——— ——— ———

// TODO we should give reasonable meaning to `==`
//  notably taking into account arrays and data classes;
//  and deprecated `===` (notably does not work for arrays)

undefined == null
//│ = true

undefined === null
//│ = false

// ——— ——— ———

Infinity
//│ = Infinity

:sjs
val Infinity = 1
//│ JS (unsanitized):
//│ let Infinity; Infinity = 1;
//│ ═══[COMPILATION ERROR] [Uncaught SyntaxError] Identifier 'Infinity' has already been declared
//│ Infinity = Infinity

:sjs
Infinity
//│ JS (unsanitized):
//│ Infinity
//│ = Infinity

module Test with
  val Infinity = 1

Test.Infinity
//│ = 1

// ——— ——— ———

fun f(a)(b) = [a, b]
fun g(a, b) = [a, b]

// TODO support?
:pe
f of
    g of
      1
      2
  of 3
//│ ╔══[PARSE ERROR] Expected end of input; found indented block instead
//│ ║  l.149: 	  of 3
//│ ╙──       	^^
//│ = [function]

(f of
  g of
    1
    2
) of 3
//│ = [[1, 2], 3]

// ——— ——— ———

fun p: Int

p
//│ ╔══[COMPILATION ERROR] No definition found in scope for 'p'
//│ ║  l.164: 	fun p: Int
//│ ╙──       	    ^^^^^^
//│ ═══[RUNTIME ERROR] ReferenceError: p is not defined


:ctx
fun (++) test: (Int, Int) -> Int
//│ Env:
//│   ++ -> RefElem(member:test)
//│   test -> RefElem(member:test)

test(1, 2)
//│ ╔══[COMPILATION ERROR] No definition found in scope for 'test'
//│ ║  l.174: 	fun (++) test: (Int, Int) -> Int
//│ ╙──       	    ^^^^^^^^^^^^^^^^^^^^^
//│ ═══[RUNTIME ERROR] ReferenceError: test is not defined

:sjs
1 ++ 1
//│ ╔══[COMPILATION ERROR] No definition found in scope for 'test'
//│ ║  l.174: 	fun (++) test: (Int, Int) -> Int
//│ ╙──       	    ^^^^^^^^^^^^^^^^^^^^^
//│ JS (unsanitized):
//│ let tmp8; tmp8 = test(); runtime.safeCall(tmp8(1, 1))
//│ ═══[RUNTIME ERROR] ReferenceError: test is not defined

// ——— ——— ———

// TODO forbid declarations inside local blocks
:todo
:e
fun main() =
  declare fun foo: Int
  ()

// TODO forbid unimplemented signatures inside local blocks
:todo
:e
fun main() =
  fun bar: Int
  ()

// ——— ——— ———

// * Objects should not be allowed to have parameters...
// * Or these parameters should have default values.

:sjs
data object Cls(x) with
  fun huh = x
//│ JS (unsanitized):
//│ let Cls1;
//│ const Cls$class = class Cls {
//│   constructor(x1) {
//│     this.x = x1;
//│   }
//│   get huh() {
//│     return this.x;
//│   }
//│   toString() { return "Cls(" + runtime.render(this.x) + ")"; }
//│ }; Cls1 = new Cls$class;
//│ Cls1.class = Cls$class;

:e
Cls.x
//│ ╔══[ERROR] Object 'Cls' does not contain member 'x'
//│ ║  l.232: 	Cls.x
//│ ╙──       	   ^^
//│ ═══[RUNTIME ERROR] Error: Access to required field 'x' yielded 'undefined'

:fixme
Cls.huh
//│ ═══[RUNTIME ERROR] Error: Access to required field 'huh' yielded 'undefined'

let c = new Cls(123)
//│ c = Cls(123)

c.x
//│ = 123

// ——— ——— ———

class Foo' with
  class Bar'
//│ > let Foo$_1;try { Foo$_1 = class Foo$_ {   constructor() {     this.Bar' = class Bar$_ {       constructor() {}       toString() { return "Bar'"; }     };   }   toString() { return "Foo'"; } }; block$res33 = undefined; } catch (e) { console.log('\u200B' + e + '\u200B'); }
//│ >                                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ═══[COMPILATION ERROR] [Uncaught SyntaxError] Unexpected string

// ——— ——— ———

module Example with
// whoops
  val a = this
//│ ╔══[PARSE ERROR] Expected block after type declaration body; found new line instead
//│ ║  l.258: 	module Example with
//│ ║         	                   ^
//│ ║  l.259: 	// whoops
//│ ╙──       	
//│ ╔══[PARSE ERROR] Expected an expression; found block instead
//│ ║  l.260: 	  val a = this
//│ ╙──       	  ^
//│ ╔══[PARSE ERROR] Expected end of input; found indented block instead
//│ ║  l.260: 	  val a = this
//│ ╙──       	^^

// ——— ——— ———

let xs = new Oopsie
//│ ╔══[ERROR] Name not found: Oopsie
//│ ║  l.275: 	let xs = new Oopsie
//│ ╙──       	             ^^^^^^
//│ ╔══[COMPILATION ERROR] No definition found in scope for 'xs'
//│ ║  l.275: 	let xs = new Oopsie
//│ ╙──       	    ^^
//│ ═══[RUNTIME ERROR] ReferenceError: xs is not defined

// ——— ——— ———

:todo // TODO: warn against using `undefined`
:w
fun oops = undefined

:re
oops
//│ ═══[RUNTIME ERROR] Error: MLscript call unexpectedly returned `undefined`, the forbidden value.

// ——— ——— ———

// TODO prevent explicit accesses to Unit, Int etc. from Prelude or elaborate them

Unit
//│ ═══[RUNTIME ERROR] Error: Access to required field 'Unit' yielded 'undefined'

Int
//│ ═══[RUNTIME ERROR] Error: Access to required field 'Int' yielded 'undefined'

// ——— ——— ———

class C

:sjs
class D extends id(C)
//│ JS (unsanitized):
//│ let D1;
//│ D1 = class D extends Predef.id.class {
//│   constructor() {
//│     super(C1);
//│   }
//│   toString() { return "D"; }
//│ };
//│ ═══[RUNTIME ERROR] TypeError: Class extends value undefined is not a constructor or null

// ——— ——— ———

let x = 0
//│ x = 0

set x += 1; ()
//│ /!!!\ Uncaught error: scala.MatchError: LetLike(keyword 'set',App(Ident(;),Tup(List(App(Ident(+=),Tup(List(Ident(x), IntLit(1)))), Unt()))),None,None) (of class hkmc2.syntax.Tree$LetLike)

[x, set x += 1; x]
//│ /!!!\ Uncaught error: scala.MatchError: LetLike(keyword 'set',App(Ident(;),Tup(List(App(Ident(+=),Tup(List(Ident(x), IntLit(1)))), Ident(x)))),None,None) (of class hkmc2.syntax.Tree$LetLike)

// ——— ——— ———

// TODO `baz()` should be in tail position (this is due to its by-name nature)
:sjs
fun baz = 1
fun bar() = baz
//│ JS (unsanitized):
//│ let bar, baz;
//│ baz = function baz() {
//│   return 1
//│ };
//│ bar = function bar() {
//│   let tmp11;
//│   tmp11 = baz();
//│   return tmp11
//│ };

// ——— ——— ———

import "../../mlscript-compile/Stack.mls"

// The parser rejects this, but it should be allowed.
open Stack { ::, Nil }
//│ ╔══[PARSE ERROR] Expected start of statement in this position; found comma instead
//│ ║  l.353: 	open Stack { ::, Nil }
//│ ╙──       	               ^
//│ ╔══[PARSE ERROR] Unexpected comma in this position
//│ ║  l.353: 	open Stack { ::, Nil }
//│ ╙──       	               ^
//│ ╔══[PARSE ERROR] Unexpected identifier here
//│ ║  l.353: 	open Stack { ::, Nil }
//│ ╙──       	                 ^^^
//│ ╔══[ERROR] Illegal 'open' statement shape.
//│ ║  l.353: 	open Stack { ::, Nil }
//│ ╙──       	     ^^^^^^^^^^^

// Instead, if we parenthesize the operator, it is rejected by the elaborator.
open Stack { (::), Nil }
//│ ╔══[ERROR] Illegal 'open' statement element.
//│ ║  l.368: 	open Stack { (::), Nil }
//│ ╙──       	             ^^^^

open Stack { Nil, :: }

:sjs
1 :: Nil
//│ ╔══[ERROR] Module 'Stack' does not contain member '::'
//│ ║  l.376: 	1 :: Nil
//│ ╙──       	  ^^
//│ JS (unsanitized):
//│ Stack["::"](1, Stack.Nil)
//│ ═══[RUNTIME ERROR] TypeError: Stack.:: is not a function

// ——— ——— ———

mkStr of ... // hello
"oops"
//│ ╔══[PARSE ERROR] Expected start of statement in this position; found new line instead
//│ ║  l.386: 	mkStr of ... // hello
//│ ║         	                     ^
//│ ║  l.387: 	"oops"
//│ ╙──       	
//│ = "oops"

// ——— ——— ———

data class Foo(x, y)

// TODO missing sanity check
Foo(1)
//│ = Foo(1, undefined)

// ——— ——— ———

data class Foo(...args)

Foo(1, 2, 3).args
//│ ═══[RUNTIME ERROR] Error: Access to required field 'args' yielded 'undefined'

:todo
if Foo(1, 2, 3) is Foo(...args) then args
//│ ╔══[ERROR] the constructor does not take any arguments but found 1
//│ ║  l.411: 	if Foo(1, 2, 3) is Foo(...args) then args
//│ ╙──       	                   ^^^^^^^^^^^^
//│ ╔══[ERROR] Name not found: args
//│ ║  l.411: 	if Foo(1, 2, 3) is Foo(...args) then args
//│ ╙──       	                                     ^^^^
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing

if Foo(1, 2, 3) is Foo(a, b, c) then [a, b, c]
//│ ╔══[ERROR] the constructor does not take any arguments but found 3
//│ ║  l.420: 	if Foo(1, 2, 3) is Foo(a, b, c) then [a, b, c]
//│ ╙──       	                   ^^^^^^^^^^^^
//│ ╔══[ERROR] Name not found: a
//│ ║  l.420: 	if Foo(1, 2, 3) is Foo(a, b, c) then [a, b, c]
//│ ╙──       	                                      ^
//│ ╔══[ERROR] Name not found: b
//│ ║  l.420: 	if Foo(1, 2, 3) is Foo(a, b, c) then [a, b, c]
//│ ╙──       	                                         ^
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing

if Foo(1, 2, 3) is Foo(arg) then arg
//│ ╔══[ERROR] the constructor does not take any arguments but found 1
//│ ║  l.432: 	if Foo(1, 2, 3) is Foo(arg) then arg
//│ ╙──       	                   ^^^^^^^^
//│ ╔══[ERROR] Name not found: arg
//│ ║  l.432: 	if Foo(1, 2, 3) is Foo(arg) then arg
//│ ╙──       	                                 ^^^
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing

// ——— ——— ———

