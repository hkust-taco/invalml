:js




id(123)
//│ = 123

:e
:re
id()
//│ ╔══[ERROR] Expected 1 arguments, got 0
//│ ║  l.11: 	id()
//│ ╙──      	  ^^
//│ ═══[RUNTIME ERROR] Error: MLscript call unexpectedly returned `undefined`, the forbidden value.


print(1, 2, 3)
//│ > 1 2 3

1 print()
//│ > 1

1 . print()
//│ > 1

1 . (print(_))()
//│ > 1

{1 . print(_)}(2)
//│ > 1 2

1
  . print()
//│ > 1


2 + 2 |> print
//│ > 4

print <| 2 + 2
//│ > 4

(_ * 2) <| 2 + 2 |> (_ + 1)
//│ = 9

2 + 2 !> print
//│ > 4
//│ = 4

print <! 2 + 2
//│ > 4
//│ = 4

print <! 2 + 2 |> (_ + 1)
//│ > 4
//│ = 5

(_ + 1) <| 2 + 2 !> print
//│ > 4
//│ = 5


fun f(x)(a) = x + a

123 |> f of 1
//│ = 124

123 |> f <| 1
//│ = 124

fun f(x)(y)(a) = x + y + a

123 |> f(1) of 2
//│ = 126


tuple passing(1, 2, 3) <| 4
//│ = [1, 2, 3, 4]

passing(tuple, 1, 2, 3) of 4, 5, 6
//│ = [1, 2, 3, 4, 5, 6]

(tuple passing(1, 2, 3)) of 4, 5, 6
//│ = [1, 2, 3, 4, 5, 6]

:re
tuple passing(1, 2, 3) of 4, 5, 6
//│ ═══[RUNTIME ERROR] TypeError: f3.bind is not a function


:re
??("oops")
//│ ═══[RUNTIME ERROR] Error: Not implemented: oops

:re
:sjs
???
//│ JS (unsanitized):
//│ Predef.notImplementedError
//│ ═══[RUNTIME ERROR] Error: Not implemented

:re
??? + 1
//│ ═══[RUNTIME ERROR] Error: Not implemented

:re
1 + ???
//│ ═══[RUNTIME ERROR] Error: Not implemented


// * Function composition is associative

let
  f = ((_ + 1) >> (_ * 2)) >> (_ - 1)
  g = (_ + 1) >> ((_ * 2) >> (_ - 1))
//│ f = [function]
//│ g = [function]

[f(123), g(123)]
//│ = [247, 247]


// *** Folding ***


fold(+)(0, 1, 2, 3)
//│ = 6

fold(-)(0, 1, 2, 3)
//│ = -6

fold(print)(0, 1, 2, 3)
//│ > 0 1
//│ > () 2
//│ > () 3

fold(tuple)(0, 1, 2, 3)
//│ = [[[0, 1], 2], 3]

fold(+) of
  0
  1
  2
  3
//│ = 6

:todo
:re
:e
fold(+)()

fold(tuple) of
  "A" +
  "B"
  "C"
//│ = ["AB", "C"]


foldr(+)(0, 1, 2, 3)
//│ = 6

foldr(-)(0, 1, 2, 3)
//│ = -2

foldr(tuple)(0, 1, 2, 3)
//│ = [0, [1, [2, 3]]]

:todo
:re
foldr(+)()
//│ ╔══[ERROR] Expected at least 1 arguments, got 0
//│ ║  l.171: 	foldr(+)()
//│ ╙──       	        ^^


// An alternative implementation of foldr
fun foldr(f)(first, ...rest) =
  let len = rest.length
  if len == 0 then first else...
  let
    init = rest.at(len - 1)
    i = len - 2
  while i >= 0 do
    set
      init = f(rest.at(i), init)
      i -= 1
  f(first, init)

foldr(+)(0, 1, 2, 3)
//│ = 6

foldr(-)(0, 1, 2, 3)
//│ = -2


fold(+) of
  "0"
  "1"
  "2"
  "3"
//│ = "0123"

import "../../mlscript-compile/Iter.mls"

Iter.joined(_, "") of [
  "0"
  "1"
  "2"
  "3"
]
//│ = [function]


mkStr of
  "0"
  "1"
  "2"
  "3"
//│ = "0123"

mkStr of
  "0"
  1
//│ // Standard Error:
//│ Assertion failed
//│ 
//│ = "01"


